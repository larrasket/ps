#+TITLE: Designing RESTful APIs


* Representational State Transfer APIs: Basics to Design
*** Introduction and History
I'm not going to talk about how to implement these web APIs, but talk about the design
aspects of how to design them so that they're easier to use and easier to maintain. The goal
here is for you to understand REST's role in creation of this API, not to simply adhere to
the dogma that surrounds REST. I want to introduce you to a way of designing APIs that's
pragmatic and simple.

When you consider creating a web API, I want you to realize that this is a problem that has
a long history. We've been trying to connect different systems together for a long time.  In
the early days, we were just getting started with distributed computing, and so the first
ideas of RPC, or remote procedure call, were being invented as early as the early 1970s. We
get into an early version of messaging and then even looking at things like queuing. And
both messaging and queuing, even though they've evolved over the years, still exist today.
Later in the 1980s and 1990s, we started building object oriented APIs as our programming
started to be more and more object oriented. And so you see COM and DCOM come out of
Microsoft, CORBA come out of the Java community, and Java and RMI come out of Java central
as well.

And these were ways to try to create distributed computing around the concepts of object
orientation. During the .com boom of the late 1990s, we started to think about the web as
being the way we're going to build APIs, much in the way that you're considering creating a
web API to be able to communicate with remote servers yourself. This started with XMLHTTP,
which was an early component inside of browsers, and that people started using to do
communication between browsers and servers.

Soon after REST was introduced, but it really didn't get large adoption until a few years
after its introduction. In the meantime, something called SOAP came out of the Microsoft
camp as a solution to this. And it tried to solve a lot of solutions and generally has
fallen out of favor lately, but you still see it used a lot in enterprises. But it tries to
solve some of the same problems that REST is.


More recently, we've seen some new approaches to how to solve some of these problems, like
GraphQL and gRPC. For creating distributed APIs that are going to work with communication
between apps and servers or websites and servers or even business to business servers, REST
still represents a great percentage of the kind of work that's being done, and has reached a
level of maturity that's really useful. That doesn't mean you shouldn't be looking at
GraphQL and gRPC as other ways to solve those problems, but they are segmented for very
specific use cases.

*** Oversimplified HTTP

In many ways, we take the web for granted. When we open up a browser, go to a webpage, we
expect it to open up and work. What's going on under the covers is a ballet of simplicity.
There's a lot of things happening, but the type of calls that are being made are actually
really simple and have stood the test of time from their very early creation points. So
let's talk about what happens when we make those sort of requests. So when a client of some
sort, you on your laptop going to google.com or any web page, it's going to make a request
to some remote server. We're not going to talk about how that address gets converted into a
server address, that's not really necessary for this talk, but we have this idea of a
request, which is just actually a text document. This document contains three pieces, a verb
for what action to take, headers, which is information about the request, and then content
that is optionally asked for.

So for example, if we wanted to create a new thing on that server, we might post, which is
one of the verbs, and we'll talk about all of those in a minute. We have some metadata that
says, hey the length of this request is 11 bytes in this case, and then we're sending Hello
World as the content we want it to post.


The server gets this request and can either recognize it as something it can do or it might
go ahead and reject it, but then it sends back a response. And notice that these are two
individual calls essentially. You do not have a connection from client to server that lasts
very long. The only way to scale up these sort of situations is that each network request is
short lived.  You make a request, you get a response, you make another request, you get a
response, and so there's a lot of these happening, sometimes even in parallel from your
browser. This response is, again, just a typical piece of data. It's just, you can think
about it as a textual document that contains a status code, and that status code says, did
it succeed? Did it fail? Why did it fail? Any headers that might be useful to you, and then
any content that the server wants to send back as part of that response.

So in this case, it might do a 201, and we'll get to what those status codes all mean, but
that essentially says, oh I'd created that thing you asked me to, and then I'm going to
return you some data, so I'm going to tell you that the body is of some content type, in
this case it's just text, and then I'm going to send you back Hello World to confirm that I
got what you sent. One of the important ideas here is that the server itself is typically
stateless. So that you're not going to care between these requests that you're stuck onto
the same server. A request is coming in, the server is going to try to fulfill it, and then
it's going to forget about you as soon as it sends the response. And in this way, it can
handle lots and lots of requests, instead of having all this state that's filling up the
memory and disk, waiting for you to make another call. Because unlike having a strong
connection to the server, which you might be used to in database programming or game
programming, the idea here is that it doesn't know if you're going to make another call
because every connection to the server is very short lived.

Let's take that idea of the request document and let's deconstruct it a little. The verb is
this action that you want to have performed on the server. So this is a short verb that says
please do something for me. And the most common of these is GET. When you want a web page,
it goes and says, hey server go get me the home page of google.com. You can also say POST,
which is please create that new thing I'm asking you to create on your server, maybe that's
storing it in the server, maybe it's starting some process like creating an invoice or
making a payment. PUT asked to update a resource that already exists on that server.
There's also sometimes used PATCH, which is to say please update this part of the data of
this resource. A common example of PATCH is please update the address of the customer. I
don't need you to send me the entire customer just to update the address, so PATCH is going
to allow me to do these updates within a resource. Then there's DELETE, which should be
pretty obvious. Get rid of some resource that exists on your server, it may be deleting an
object that I didn't mean to create or it may mean that I'm going to unregister with your
website, whatever it is, it says delete some resource. And then there's actually a bunch
more verbs, but these are the five that are used 99.5 % of the time. We'll actually see some
other verbs like OPTION being used a couple times in our discussions, but these are the five
that I would focus on.


The headers are a set of name value pairs that are metadata about the request. So some of
the common ones are what type of content is the content section holding?  It is binary data?
It is a JSON file? Is it an XML file? Is it plain text? This is to tell the server how to
deal with this request. The content length is there to hint at the server how much content
there is. So it doesn't go ahead and not know how the end of the content is as it's pulling
data across the wire. Authorization headers are there to says who's making the call. Accept
headers are there to say when you send me a response, what kind of data can I accept?
Cookies, this is data that's being sent with the request that expects the server to also
pass back as a way to have state through the entire process. And more, there's literally
hundreds of headers, and you can define your own headers, if those are useful to you, but
for the most part, these are the ones you're going to want to think about.

And finally, content, this could be anything. So if we look at a simple web page that you're
going to request, you're normally going to request and it's going to return an HTML page,
and then that HTML page might have CSS and JavaScript or JSON requests in it that are then
also requested in the same way, and that's why each of these requests are discrete. So a
simple HTML page may have dozens or hundreds of requests. The content for a request isn't
valid on some verbs. The most of these is GET. GET never has a content body because GET is
just requesting that you return something that it wants. So as per the spec, you can't
really send any information about what you want, as content has to be in the URI or in the
headers.


Let's do the same thing with the response, just so we can really understand this.  The
status code is simply a number that represents what kind of success, and it does this in a
series of ranges, 100 to 199 are informational, you'll rarely see 100 status codes, but they
do exist. The most common you're going to see is 200 to 299, and these are status codes that
say, hey what you asked for, here it is, and I was able to do it successfully, 200 being the
most common of these. Three hundred to 399 are return when what you requested for needs to
be gotten some place else. So this is how you can say hey you need to go to this new place
for your web page or this is data is already cached for one reason or another. So these are
about redirection to different sites. So when you think about redirection, it isn't saying
it succeeded in getting you the data, but it's not saying you failed in requesting it, just
that you asked for it in the wrong place. Then 400 to 499 are errors.  These are typically
errors in the way you made the request. You may have not included a query string or some
part of the URI that makes sense, or simply the URI doesn't exist. The famous 404, of
course, is in this range. And then 500 to 599 are errors that the server has, something went
wrong on the server, it's not your fault, it's our fault. Same idea here with headers,
they're very much similar to what we're going to see in the requests, except we're going to
tell it this is the kind of data it is that we're sending back to you, this is the length of
that data, this is how long that data should be cached. So the idea of expires is that the
browser or some other thing might cache it for 10 minutes, 30 seconds, 2 years, because it's
not apt to change. And then cookies are being sent back normally from the cookies that are
being included in the request. Though there may be more cookies included on the server that
are then expected to be passed in subsequent calls. And finally, the content is very much
like it is on the request, it might be HTML, CSS, might have images like blobs, or APIs can
often have their own types as well. So this is just the guts of whatever is being sent back
over the wire.

*** What is REST
The term RESTful really means they are a pragmatic approach to using REST. We may not be
100% REST-based in what we're doing, but we're going to lean on the benefits of REST as much
as possible. So what does the term REST mean? It is actually a pseudo acronym for
REpresentational State Transfer. The idea here is to have transfer of data or state be
representational of the kinds of messages that you want to use. And so these concepts
include:

- Separation of client and server
- All the server requests should continue to be stateless,
- All the request you make should support cacheability
- That they're all going to use a uniform interface or a URI.

And all this comes directly from the source of REST, Roy Fielding's doctoral dissertation.
So from that dissertation, the fundamentals of what it really means to be RESTful are
brought forward. But we're going to talk about, again, the pieces of REST that are going to
benefit you to create great software that's going to live for a long time.

The reason we're not going to go deep into making it perfectly or dogmatically REST is that
REST itself has some problems. Sometimes it's too difficult to make sure your application is
completely RESTful. There's some concepts that can get in the way of making sure that your
API is completely qualified as REST. This sort of dips a toe into the idea of the dogma of
REST versus the pragmatism. I'm very much on the pragmatic side.

*** Designing REST
I think it's important when you're building an API to design it first. That should be the
first step in the creation of a new API, instead of just starting to write code and getting
on with it. I understand the temptation certainly, but by designing it, you've going to gain
some real benefits.


The biggest problem is you can't fix an API after publishing it. You're going to have
clients that are reliant on what your API looks like. So if you make mistakes in the way the
API is designed, you're going to have to live with that, unless, of course, you can talk
your clients into allowing you to break them. It's also just too easy to try to solve
individual use cases by adding ad-hoc endpoints. I really want you to understand the
requirements of an API before you build it, and not just take the boilerplate of what you've
seen in other organizations. Not all APIs are just simply data access. Often you're trying
to do something more interesting to match the requirements of an API.

Remember that as you build an API, that is the starting point for that API to live. As it
matures, you want an API to be able to not have to be changed in large ways, that it can
evolve over time. But enough speeches, let's start to look at the real problem.

When we think about REST APIs, I want you to think about the different pieces of it before
we decide what to put in each of those parts. What's important to note is you're designing
each part of a REST API, not just the URL. So, of course, the starting point is that URI,
what that path is on some web server. But we've also got the verb. This is the indicator of
what your intention to do at that URI is, and then as we've talked about with HTTP, part of
that REST API is whether you're going to use headers, whether your clients are going to need
to use headers or need to be able to read headers, and then the request body if any.

When we look at the response you're sending back, you also have that similar set of parts of
the API. You have the status code, what sort of response is going to be sent back to say
that it succeeded or failed or how it's going to fail. You have headers that may be sent
back to the client to indicate things, and then the response body, the thing they asked for.

Let's start the discussion with URIs. In REST, URIs are just paths to resources. So when you
have your server, there is an API, it's whatever path follows your server name to indicate
how to get to some object on that server.

Part of that URI that we don't think about when we're designing the APIs is often the query
strings. So the things that can be added to the end of the URIs to indicate things. Now
*query strings should always be optional*, when you think about them logically.  And so
they're often used for things like formatting and sorting and searching.

So as you design your API, I want you to think about the nouns. *Nouns are good, verbs are*
*bad*. And here are some examples:

#+begin_src txt
/getCustomers
/getCustomersByName
/getCustomersByPhone
/getNewCustomer
/verifyCredit
/saveCustomer
/updateCustomer
...
#+end_src

Early on when I was building APIs, it was very easy for me to think of these as just
endpoints to some remote procedure call. So get customers, verify credit, update customer,
all of that made sense. But in REST APIs, what we're going to actually look at is that we
prefer nouns:

#+begin_src txt
/customer
/invoices
/products
/employees
...
#+end_src

So these are going to be customers, invoices, products, sites in our case. They're going to
be the indicator that this is some container that holds resources that the user may or may
not want. These are going to hold resources that the developer is going to want access to.
For the most part, they're always going to be pluralized, unless you're only giving someone
access to a single item. The difference there is you may look at customers as the complete
list of customers or you might think of it like we saw in the GitHub where it might be user/
and then the name because you're always dictating that they're going to get a single object
back. But most of the time, you're going to be dealing in plurals.


I've used the word resources a couple of times. What do I really mean by this? Now on the
face of it, we can think about it as just a collection of those nouns, right? People in an
organization, invoices that exist in an accounting system, payments that were made, let's
say through the web, products that can be sold, these are what I think of as, you know, the
canonical resources. These are nouns that you want to expose through the API, but it can be
more complicated than that because it's easy to think of resources as just the entities that
some data store holds. And so I want you to think about resources as being inside of
something like a context. So it may be that individual people are a type of resource. But
you could also imagine a resource being an invoice and that invoice is more complicated. It
might have, you know, the invoice itself and then all the items that are contained in the
invoice. So this complex object that we're thinking about is still considered a single
resource. You wouldn't necessarily need an API that exposes each line item individually.
You're really going to want to think of these as an entire resource. And this could be a
very complex object. You can imagine in like a book depository that the header information
about a book, who wrote it, how many pages, and such, may be a resource in itself, even
though the contents of the book might be something you could look at individually. So don't
get your head too much around that just because we have an entity that's stored as an
individual item somewhere in a data store, that that's what we're talking about as a
resource. We're talking about the complex objects, and sometimes single objects, that you're
exposing through the API.


In our case, we're dealing with really three objects in our API that we're going to be
building. We're going to be building an API that exposes some data about UNESCO Heritage
Sites. And so we have this object that is a site that tells some information about it, that
has a description, has an id and a name, and then has these relationships. And in our case,
the idea of a site and its location, its location being what country it's in, what latitude
and longitude it's in, that is a discrete resource. You can't really have a site without the
location. The location is, you know, in some ways thought of as a sub-object of there, but
contextually in the API, that's going to be one sort of object. Whereas then categories and
regions could be thought about as their own resources as well. When we're talking about
identifiers in URIs, we're talking about being able to access individual items in a resource
collection. So these need to be unique identifiers because in URIs we want to have each
individual URI point at a specific resource. You're not always going to be searching, you're
usually going to have some URI that uniquely identifies one resource somewhere in your
system. These don't have to be the primary keys, so they don't have to be GUIDs, if that's
how you're storing it, or integers or whatever it can be.


And so while the URI for stone-henge itself should be unique, what you design for the unique
identifier to uniquely identify it is really up to you. The further you can get away from
needing to have primary keys or other sort of keys in your system that do that, the better
design your REST API normally is. Again, if we look back to the way GitHub did it, it uses a
unique identifier throughout its system to represent individual people, individual
repositories, etc. It never is just giving you a number or a perfectly unique number for
that object. It makes it easier for it to know that those identifiers are unique, as well as
making it easier for the developer to be able to see just from the URI what they're actually
looking at. Because ultimately URIs, even though they're just addresses to some resource, at
some point developers are looking and working with these. So you don't want them necessarily
to error on readability, but if you can get both, you can have the benefits of readability,
as well as functionally unique.


While designing your URI, you also want to think about how you're going to use query
strings. So these are typically used for non-resource properties.  So it could be in the way
you want to use query strings to sort, to page, to specify format, etc. This really comes
down to not requiring any of these, but allowing developers to have more control over how
you're going to get this information in the way of, you know, getting page results versus
sorted results, etc., so that you can allow them to do things that aren't about necessarily
specifying how the resource is going to be constituted, but how the resource is returned.
Now that we've talked about URIs, let's talk a little bit about the next piece and that is
the nouns that are part of our API.


**** Verbs

- /GET/ wants to retrieve a resource, whether that's a collection of resources, as in the case of sites in our example, or it might be an individual site.
- /POST/ is adding a new resource, or you could think about it as creating a resource.
- /PUT/ is updating an existing resource, so taking a resource with information that might
  have been changed and updating it to reflect new data.
- /PATCH/ is very similar to PUT except it's updating a resource with certain data changes.
  So instead of using PUT to send a whole object, you might just send some partial object.
  You could imagine in our example that we might send a location to patch information about
  just the location inside of our site.
- /DELETE/ removes an existing resource.

  And, of course, all these different verbs are
going to be dependent on who's making the call, how they're authenticated, etc. You're not
just going to open up an API and let anyone with anonymous access delete resources in your
database or update them, or even create them. These are just the terms you're going to use
to indicate what you want to do on a specific request. Now most of the web runs on this GET
request, right? You're getting a page, you're getting JavaScript, you're getting CSS, but
we're going to start digging into these POST, PUT, PATCH, and DELETE as verbs to indicate
that you want to make a change.

To put it more concretely, what should verbs do when we're
using them with URIs? So in this case, we have a resource called /customers:

- If we issue a GET, we should be returning a list of those customers.
- If we issue a POST, we should be creating a new customer.
- If we do a PUT to the endpoint that is the collection, I expect that that PUT should update a bunch of customers at once. Because, remember, the URI for customers is representing the complete collection of customers, not an individual customer.
- And trying to delete that collection of customers should probably error out because you probably can't find a use case for deleting an entire collection. Now this is up to the requirements of your system, you might find some sub-object like deleting all appointments for a particular customer might make sense in that case, but you're rarely going to want to do this at top level resources in your system.


When we're dealing with individual items in those collections, those verbs do different
things. So in the case of a specific customer, a GET should return just that item. Doing a
POST to that collection doesn't make any sense, so it should return an error because you
can't create an object that's already been created, right? That's why you typically POST to
the collection and you PUT to the item, right? Those are sort of analogous to each other.
POST is about creating a new customer, so creating a new customer inside this customer, it
just doesn't make sense, so error typically what you're going to want to do. PUT will update
an individual item and then DELETE should delete that individual item.

Now one note on this update batch, I have implemented this once and only once. Rarely do I
actually support this.  But it is a use case that you may find necessary as you're
developing complex systems.
**** Idempotency
So one of the constraints that REST tells you when you're going to create an API that you
need to deal with is idempotency. And at first, if you're not familiar with the term, I want
to make sure it's really clear, it simply _means that an operation, if executed multiple
times, should do the same thing_. So if we look at an example of this, operations that you
execute should have the same side effect, if any. So for GET, PUT, PATCH, and DELETE, it
should do the same thing no matter what. DELETE should delete the item or return an error.
GET should always return the same data, assuming nothing has changed in the system. PUT
should keep on making the same change if necessary, and PATCH. This means that if you issue
a PUT or a PATCH twice or three times in a row, it shouldn't fail the second or third
because there were no changes, it should just work. An important exception to this is POST.
POST is never idempotent. You should assume that every time you POST to an API that it's
going to return a brand new object each and every time, so you don't have to worry about
idempotency in the case of POST.


*** Designing Results
Now so far in our examples, we've simply been returning the
data that we saw, right? And this is an example of the structuredness, right? It's just a
simple object that represents one of the UNESCO Heritage Sites, and then we have a couple of
complex objects. We have the location, which is part of this Heritage site, and then we have
category and region, which are related to them as well. Now we may decide that what we
actually return is very different than this. What you're ultimately doing to make it easier
on the developer is to figure out how to name each of these pieces, how to describe them,
even data types and structure. You could see that something like the location of our UNESCO
Heritage Site could easily be flattened and just be other properties. It's up to you to
decide what that form is and whether it's easy for ultimately the developer to deal with it.

So it's often thought of when you're developing an API, well I'll just take the same
structure I have in some data store and I'll just return it. And that is easy, but often
you're going to want to think about the use cases for the people wanting to use this, and
that may not be the best format. Often the format that you're storing it in is not the best
version of it in an API. Certainly not never a good idea, but it is often a good idea to
change the format of it, to map it to a design that's going to be more useful in your API
than how you're actually storing it. This is especially true in the case of SQL data stores,
right? The idea of taking a relational store for data and then just exposing it as a set of
relationships in an API often isn't a terribly good idea, because what's efficient to store
and query may not be useful from the developer using your API. So I want you to think about
those structures.

When you're designing your results, I want you to think about members
names and that these shouldn't necessarily expose server details. I'm not saying that you
need to change every name just because it might be something on the server, but if you're
using specific platforms, like Ruby, Java, .NET, even Node, there may be conventions that
make perfect sense inside of those languages, but you can't assume, in many cases, that the
users are using that same thing. And so I typically, for JSON especially, prefer to
camelCase most of my member names because I know that for a lot of the APIs I'm using, the
Java or JavaScript clients are going to be used to that kind camelCasing already. Even
though I develop mostly .NET solutions, where they're using pascal case inside, I'm not
going to assume that the clients are all going to be familiar with that. And if you use
things like Ruby and Python where you're using like underscores or dashes to separate names,
exposing them through your API doing that is just going to make it a bit harder for
consumers to it if they're not using the same sort of backend or platforms that you're
using. So don't expose those, find something that's platform agnostic. If you don't agree
and you, you know, you want your underscores between words because that's just the way you
live your life, as long as it's not objectionable, at least be consistent. Don't use it in
one place where you're exposing those server details and then in other places you're
changing the names, at least be consistent so that the developers don't have to learn what
those conventions are for specific endpoints that you're dealing with.


Now designing
collections is a little different. You could just do like we've done in the examples I've
shown you and return just the collection as an array of results, but it's often helpful to
think about designing collections in a different way, like including how many results are
there, including next and previous page for paging because often you're not going to want to
simply return all 10, 000 or a million rows of a collection. You might be limiting that user
to what data they can get at because you can assume that the correct thing is often not
going to be the easiest thing. What I mean by that is if someone naively goes and selects
all the customers or, more importantly like all the invoices in your accounting system,
returning the 7 years of invoices you have stored in some data store is probably not what
the user meant, right? And so it's flooding your server and then flooding the network with,
you know, the 7 million invoices you have on your system, probably isn't even what they
intended. And at the worst case, you want to prevent people from like just scraping all that
data accidentally, and so for security reasons you're going to want to do things like paging
anyways. So think about how these collections are going to work and how it's most useful for
users to include it. An including properties that have the navigation to different parts of
the website isn't about id, and we'll actually be touching on some benefits of doing that a
little later on in this course. But even if you're not going to down that hypermedia route,
it's still very useful to be able to design the collections that you're returning to be more
useful in that way.

**** Hyber Media
Hypermedia is an idea that is part of what REST wants you to do. And I think it's useful in
some cases and really not useful in others. The idea behind hypermedia is simple, it wants
results to be self-describing. So it allows programmatic navigation of URI endpoints. It
adds complexity in the way that you're building your APIs and how you're exposing these and
having to support them. So my opinion is that you don't always need to include hypermedia,
but use it as a tool to figure out how you can better serve your clients.

So let's see an
example of hypermedia. Now in the case of returning a collection, we've seen this example
already of returning individual simple results, but we could also have a collection of
links, often called _links, inside individual results, that tell about different parts of
our API. So we can see link to our self is api, looking at the region that we're associated
with as a different link and a different link for related sites. And so the idea behind the
hypermedia really is to say we want there to be links or other things that describe our
objects so that we can use software to navigate to these different things more automatically
or more simply without us having to figure out what they are.

I'm still not on board with
doing this in each and every project, but there are projects, especially ones that may be
generatively created, that can benefit from using hypermedia. I think it's one of those
things that the complexity it adds isn't always worth the cost of actually developing it. It
depends, again, on your users and the requirements. Ultimately I think pragmatism needs to
win here and that most projects that I've dealt with don't need hypermedia, but every once
in a while it comes and it's super useful, so understanding it as something you can
optionally include in your APIs is important. I just want to get stuck in that if it doesn't
include hypermedia or links to other parts that are self-describing, that you're purposely
RESTful. Again, I want to error on pragmatism versus dogma. Let's wrap up this module.



*** TODO Check HTTP Responses List
*** TODO Check HTTP Full Requests List
* Going Complex
** Associations

When I talk about
associations, I typically mean sub-objects for existing APIs. For example, I might have the
invoices related to a specific customer, I might have the ratings related to a specific
game, I might have the payments related to a specific invoice. The idea behind associations
in these simple cases is to allow the navigation of the URL to imply ownership. You would
never use this customers/123/Invoices URI as a way to look at all invoices, it's clear that
this should be the invoices of that specific customer.

In the same way, both of these URIs,
one that returns all or individual invoices, should also return the same type of shape that
the invoices within a specific customer would return. The difference here is the scope. The
invoices inside an individual customer should return a collection, but only invoices that
belong to that customer. Where the other URI, a top-level URI, would return invoices across
different customers. In this same way, URI endpoints can have multiple associations. So even
though we have invoices for a specific customer, we could also have payments for a specific
customer or shipments for a specific customer. There's not a limitation that an endpoint
for, let's say, a particular customer or a particular resource, has to have only one
association to it. It's pretty common for it to have multiple associations. These
associations shouldn't be confused with search queries. In the last module, we talked about
the uses for query strings. I wouldn't use navigation or associations as a way to get things
like all of the customers within a state or all the customers that belong to a certain sales
id. I would certainly use query strings to do that instead.
** Paging
Now let's look at paging. Most lists that you're going to be dealing with inside of your API
should probably support paging, and the idea here is pretty simple, that unless your list is
a very concrete list, let's say you have an API to show all of the countries in the world or
all the states in the United States, etc., those are pretty fixed lists that you're going to
always want to return as a block. But anything else in your system, especially typical day
to day resources, you're going to want to support paging for a few reasons. One, to make
sure clients don't pull back everything just because they don't know any better, but also b)
to allow you to have the interactions with users that make more sense to them.

Query strings are commonly used to do this paging. Some people do use URI sections to do
this, but I almost always suggest query strings because query strings are saying we want to
do something different with an existing API. And as we saw in the last module, we'll often
want to wrap our results inside of a wrapper section in order to give this information. And
so having an API that specifies what page they're looking for, as well as optionally a page
size, is a pretty typical way to go. You may want to control this and always have the same
page size, but I find using the page size ends up being pretty simple.

And then you can simply return, as part of the results, the next and previous page, as well
as the total results, as that's something that's very commonly shown to the user, so they
don't just go next, next, next, next, and realize they have a million records that they
might be paging through. They might change their query instead. If you've ever done a Google
search with a billion results, you know that adding terms to the search is often a better
solution.
** Error Handling
Now let's talk about error handling. In your API, you certainly can just return status
codes, and most developers will be able to make sense of that, but it's often helpful to
allow you to communicate information about the errors. You want to use error handling to
help your users recover from errors that are related to them.So if they've made a mistake,
we want to be able to communicate that something's wrong with their request.

So often this
is returning the object with the error information. So you might return a bad request
because they've made a mistake, but also something about the error to say how to fix it. You
failed to supply the id, therefore you want to fix that and try to resubmit it. Now this
isn't always the best idea. In the case of security concerns, you'll often want to just
return the failure without an indication. What I mean by that is if you have an API that
does login and they've supplied a username and password, you might not want to return bad
password, didn't match with username, or username doesn't exist. Those can give users of
those APIs a false sense of what is wrong, which is a security problem for you, because that
means once they start hitting correct user ids, then it becomes a little simpler for them to
just barrage you with passwords, hoping to get the right one. And so use this wherever you
think it's helpful to the user but doesn't compromise your own security. There are cases
where you don't need to return a body because the error is just obvious on its own. The most
common of these is file not found. You might also do this for authorization or
authentication errors. Let's see this in practice next.
** Caching
So now let's talk about caching. Caching is one of those ideas that is required to be truly
RESTful. It's a basic tenant of the way that you would build REST APIs. Now not every API
needs to have caching, but in order to scale up and be really useful, you should think about
designing caching into your API. While supplying server-side caching of results is good,
that's not really what REST is talking about. If four people ask for the same customer,
you've cached it on the server, so you can return it faster, awesome. That's not really what
the REST API needs to worry about for caching.

What they mean in these cases is to use HTTP
for caching. Now what does this involve? When you make a request over HTTP and they ask for
something and include the last version that they were given, the response should be a Not
Modified. And so in this way, the client can ask the server, do I have the latest version,
without the server having to find it and then send it back so you can compare it. So in some
ways this really is versioning of individual instances of data or resources that you're
returning from servers. Another way it does this is on the request it can use a header
called If-Match. So I retrieved this object and got a magic number or magic identifier to
say this is the version I have on the server, and then when I try to go update it in a way
of doing concurrency, I can say, hey, make these changes, put these fields in the right
place, if your version is the same as my version. And if there is no match, if it has been
updated on the server since I retrieved it, the return code that you can expect to send back
is precondition failed, because the header here becomes a precondition.

A great way to
handle this caching is something called entity tags, or ETags for short. They support strong
and weak caching, so basically the idea would be is this a version tag for this payload that
you can hold onto for a long time or a short amount of time? Strong means I can go ahead and
store it in my rich client or on my phone app and 4 weeks later I should be able to send it
back with changes and this ETag should be able to be constructed by the server to see
whether there's a change. Weak caching support is for things that are just very short lived.
These ETags are returned in the response and we can see ETag as a header type with some
identifier, in this case it is a unique string that represents the version of the resource
on the server. And if you want to return a weak type, you start it with W/ and then use that
same format in an ETag. You want to indicate to the developer how strongly this caching
support is included.

Essentially this means that if you're doing a GET, you should use
If-Match, and to indicate 304, if it is already cached, and don't return it back. So like we
saw in the other example, if I request it and say do a GET, but only if it's not the version
I already have, and that's what the If-None-Match means, all that gets returned from the
server is not modified. So the version you have is the latest version I have. And so that
server communication can become very cheap because it should be a very quick roundtrip.
Similarly, on PUT and DELETE, you're going to indicate 412 if the version they have is not
the same. So this is different. On a GET, you're going to return a 3 or 4 if it is the same
and for PUT and DELETE, you're going to return a 412 if it's not the same. And so, for
example, here is a PUT, we can say please update these fields if it matches this and if it
doesn't match it, so we didn't actually have success in executing the PUT or DELETE, we can
say precondition failed in this case. Now because it's in 412, it's in the failure part of
the status codes, so whether you look for 412 specifically or you just show failure, you're
still doing the right thing.
** Functional APIs
Ultimately when I'm building a RESTful API, again, I want to be
pragmatic about it. Ultimately the goal of a REST-based API is to fulfill some set of
requirements, some needs, some customer requests. And so functional APIs are not terribly
RESTful. But occasionally, you know, once or twice in any large project, you're going to
need some call to the server that needs to do something that is functional. Restart a
machine, recalculate totals, whatever the case may be. There are these one-off operational
APIs that you're going to want to support, but aren't truly necessarily RESTful. Now what I
find some people doing to make sure that they stay perfectly RESTful is they'll build a
whole new sort of system to handle these operational things, but most projects only need a
small handful of them. So why not bake them into your RESTful API?

Because of their very
nature, you're going to want to make sure these are well documented so people can understand
the side effects because almost always these APIs will have some side effects. Make sure
they're completely functional and that you're not starting to build an RPC layer over REST
just because you don't understand what you're trying to accomplish with REST.

So typically
functional APIs should be the exception rather than the rule. If you find yourself designing
dozens of these or even as little as 10 of these, you're probably trying to get around the
limitations of REST and you need to go back and look at your design. So here's an example of
calculateTax, I'm going to send you the state and I'm going to send you the total and you
would return me back because you have implicit knowledge on the server about what those
state requirements about a tax would be. Or in this case, restart the server. Start a cold
boot because you're going to allow some server to be restarted because you have found some
functional issue. Of course, one of these might be very useful to your users and one of
these might be very useful to your IT team.
* Versioning REST
So the first question you're going to want to ask yourself is whether you should version
your API at all. It's a good thing to think about because once you publish an API, it is set
in stone. Once clients have written against the API, you're going to have to maintain that
version of your API. And once you have users that rely on the API, you're not going to want
to change it willy-nilly. You're going to want to make decisions about how to handle changes
in your API without breaking the clients.

Now if you have an API that's only being used by
your own team, maybe versioning is overkill. But as soon that API has internal or external
customers, if it has users that are actually writing code that may not be just your small
team, versioning in an API is super important, and it's easier to handle during the first
version of your API than trying to shoehorn it in later. ultimately your API will have
changes in requirements no matter what you do, no matter how well you've designed it, and so
your API is apt to change. The goal here is to evolve your API without breaking existing
clients. Now we don't mean that every time you release a product version that you're going
to change the version of your API. They can be decoupled. Tying them together is just
confusing, especially if the API doesn't have actual changes to it.

API versioning is harder
than product versioning. The reason for this is you need to support for old and new versions
and to have a story about deprecation over time. In theory, you can have side-by-side
deployment of multiple versions, but it usually isn't feasible. You usually want some
indication from the users about what versions they want to use. And allow older code to not
have to make changes to continue to use an API unless you truly do want to sunset those
APIs. Ultimately the decision is up to you, but planning for and designing versioning up
front will make maintenance of your API easier longer term. So let's look at some of these
strategies for versioning so you can decide which ones, if any, are ones you want to choose.
** Designing Versioning

There are a lot of ways to version an API. Not all of them are ones I would recommend.
You're going to want to find the mechanism or the way of doing versioning that makes the
most sense to your organization. And this is going to depend a bit on the requirements.
Ultimately you're serving your clients, not yourselves. Making versioning easy to use for
your clients is way more important than making it easier on your development staff.
*** Versioning with The URI Path
The first option for versioning that I will talk about is one that I see pretty commonly
used, and that is versioning in the URI path. We can see in this example:
~foo.org/api/v2/Customers/~ that the v2 inside the path to our customers API is indicating
what version of the API. While it's very clear to clients which version they're using and
how it can be handled, it tends to be brittle. Every time you have a version change, you're
going to need to have clients change all the URIs.  And so usually I don't recommend this
path.


*** Versioning with Query String

Another versioning strategy is query string versioning. In this case, we can simply add a
query string that asks for a specific version of our API. The benefit here is that we can
have a default version that will always be used by our API when the version query string
isn't supplied and then simply add it to other versions. This often means that newer
versions of the API may need to include this every time, depending on where you want to do
your versioning. The big con here is it's too easy for clients to miss needing a version. So
helping those developers that want to use your API to remember what version to go for tends
to be problematic.


*** Versioning with Headers

The next type of versioning is
something called versioning with headers. You can see the X-Version here is a header that
specifies what version of an API to go after. And what's interesting about this approach is
that it has some of the benefits of query strings, but it does separate versioning from the
rest of your API so that the API writers don't necessarily have to change it, only an
interceptor in writing that API needs to put this version in the header. So it becomes a
little decoupled with the actual API calls. The issue with using headers is it often
requires a more sophisticated developer (lmao), one that knows how to add headers or how to
intercept those calls so that those headers can be added to their client code.


You can also
version with an accept header.This is beneficial because you're not creating your own
custom header, but instead you're using the accept header itself to ask for a specific
version of your API. In this example, we've seen that even though we're accepting
application/json, we're specifying the version in that accept header. And the benefit here
is the accept header also will keep the version that the client uses so that when the
content type is sent back to the server, it can include that version. You're having the
separation of versioning with both the content they're dealing with and the API calls. But
it is less discoverable than query strings and also has the same problems that simple
headers do, and that is, requires a little bit more sophistication to use.


*** Versioning with Content Type


The last one I'll talk about is versioning with content type. And this is the most complex
of them all to implement. But if you need it, it's really useful. The idea here is that you
would include a custom content type. The spec calls in content type to allow you to do vnd.
and then your application name as a special type of content. In this case, you could use the
accept header as well as the content type with a version embedded in it in order to specify
the kind of data you're looking for. This gives you much more granularity to dealing with
versions because then part of your application could be in one version, another part could
be in another version, and this is especially useful for long-lived applications.What I
mean by long-lived is if I go ahead and get a list of customers on a Tuesday and then 2
weeks later I want to update one of those customers, this will tell me that the version of
the API hasn't changed because the content and accept header, which usually are married with
the content that I'm storing, should tell me what version of the content that I received
from an API, not just the version of the API I'm using. It does require a lot more
development maturity to create and maintain the sort of code, but it is very powerful.




All of these different versioning types, you have to marry with the correct requirements.
Doing something as simple as query string for simple APIs that you want to maintain over a
lifespan is the perfectly correct choice for those sorts of APIs. If you're building a very
publicly used API, like our GitHub example earlier, going to the more complex situation,
like using custom content types and accept headers, may be the right choice because it gives
your developers the most flexibility to use your API.
