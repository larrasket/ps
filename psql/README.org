#+TITLE: PostgreSQL Notes
#+hugo_tags: "Computer Science" "Databases"
#+date: 2022-01-08T05:28:26+02:00

* Introduction into PostgreSQL
Notes:
+ SQL commands is not case sensitive, therefore ~SELECT~ = ~select~ = ~SeLeCt~
** Selecting
*** Regular Selection
:PROPERTIES:
:CUSTOM_ID: regular_selecting
:END:

Select syntax is being like this:

#+begin_src sql
SELECT
  * -- Everything
FROM
   real_person -- Table Name
LIMIT
        10;  -- Getting only they very first 5 IDs.
#+end_src


This will print all ~email~ (s) from the ~customer~ table.
*** Select distinct rows using ~distinct~ operator
:PROPERTIES:
:CUSTOM_ID: distinct
:END:
~DISTINCT~ clause is used to remove duplicates rows from the result output, it keeps only
one row for each group if duplicated. Consider the following example:
#+begin_src sql
SELECT
  * -- Everything
FROM
   real_person -- Table Name
LIMIT
        10;  -- Getting only they very first 5 IDs.
#+end_src


If we evaluate this we get:
#+RESULTS:
#+begin_example
| id | first_name  | last_name  | email                      | gender      | country |
|----+-------------+------------+----------------------------+-------------+---------|
| 1  | Ernestine   | Dobrowolny | edobrowolny0@google.com.hk | Male        | CN      |
| 2  | Evy         | Kornousek  |                            | Genderfluid | CR      |
| 3  | Jacquenette | Cleave     | jcleave2@phpbb.com         | Polygender  | CN      |
| 4  | Tobin       | Paule      |                            | Bigender    | CN      |
| 5  | Minta       | Ramos      | mramos4@sciencedaily.com   | Non-binary  | SE      |
| 6  | Alaster     | Loomis     |                            | Genderfluid | PH      |
| 7  | Nap         | Algie      | nalgie6@wunderground.com   | Non-binary  | PT      |
| 8  | Agnes       | Geck       |                            | Genderfluid | RU      |
| 9  | Hartwell    | Tetley     |                            | Male        | JP      |
| 10 | Scotti      | Abreheart  |                            | Female      | ID      |
#+end_example
You can see we have 4 out of 10 rows are from China (CN), suppose if we only want to observe
which countries are in our database system, it would be a waste of rows to have those 4
duplicated. We can use the ~distinct~ clause to get rid of this, for example:

#+begin_src sql
SELECT
   DISTINCT  * -- Everything, change it to `country` to get distinct results by countries.
FROM
   real_person -- Table Name
LIMIT
        10;  -- Getting only they very first 5 IDs.
#+end_src

#+RESULTS:
#+begin_example
| id  | first_name | last_name   | email                   | gender      | country |
|-----+------------+-------------+-------------------------+-------------+---------|
| 843 | Sigismund  | Revance     |                         | Bigender    | BR      |
| 594 | Ibbie      | Lamming     | ilamminggh@ibm.com      | Female      | OM      |
| 86  | Abelard    | Gumm        | agumm2d@free.fr         | Genderqueer | ID      |
| 853 | Veronika   | Vasyunichev | vvasyunichevno@home.pl  | Genderfluid | MX      |
| 457 | Joyous     | Alsobrook   |                         | Non-binary  | BR      |
| 505 | Shannen    | Sproat      |                         | Polygender  | CN      |
| 34  | Danila     | Stevings    | dstevingsx@netscape.com | Agender     | US      |
| 35  | Jean       | Lerner      | jlernery@ning.com       | Bigender    | RU      |
| 20  | Blaine     | Blakebrough |                         | Genderfluid | KE      |
| 613 | Vitia      | Rummings    |                         | Polygender  | DE      |
#+end_example
**** Distinct on
Consider the following example:
#+begin_src sql
SELECT
   DISTINCT gender, country
FROM
   real_person -- Table Name
LIMIT
        10;  -- Getting only they very first 5 IDs.
#+end_src

#+RESULTS:
#+begin_example
| gender      | country |
|-------------+---------|
| Female      | GR      |
| Bigender    | GU      |
| Male        | UA      |
| Non-binary  | MA      |
| Male        | SE      |
| Genderqueer | KZ      |
| Female      | ID      |
| Genderqueer | ID      |
| Polygender  | KZ      |
| Bigender    | PE      |
#+end_example
The meaning of ~DISTINCT gender, country~ is to make sure that there will not ever two rows
(or more) that have the same values in gender and country, therefore you can't find two
males from China in this output. But let's suppose we want to have distinct genders and
non-distinct countries, PostgreSQL provides the ~DISTINCT ON~ function to do so, for
example:
#+begin_src sql
SELECT
        DISTINCT ON (gender) gender,  country
FROM
        real_person
LIMIT 100;
#+end_src

#+RESULTS:
#+begin_example
| gender      | country |
|-------------+---------|
| Agender     | UA      |
| Bigender    | CN      |
| Female      | PL      |
| Genderfluid | BW      |
| Genderqueer | SE      |
| Male        | CN      |
| Non-binary  | GR      |
| Polygender  | NG      |
#+end_example

*** Sort rows using ~order by~

We use the clause ~order by~ to order selection output. Example:

#+begin_src sql
SELECT
    id, first_name, last_name
FROM
    real_person
ORDER BY
    first_name ASC -- If you leave it empty it will use ASC by default
                      -- Use DESC to get descending sorting.
LIMIT
    10;
#+end_src

#+RESULTS:

#+begin_example
| id  | first_name | last_name |
|-----+------------+-----------|
| 596 | Ab         | McCaghan  |
| 962 | Abdul      | Gingedale |
| 86  | Abelard    | Gumm      |
| 957 | Abelard    | Gartin    |
| 422 | Abrahan    | Pedro     |
| 234 | Abram      | Atcherley |
| 807 | Abramo     | Bristoe   |
| 88  | Ade        | Verrill   |
| 209 | Ade        | Brandsen  |
| 851 | Adriana    | Ogan      |
#+end_example

**** Order by String Length
You can use the ~Length()~ function with the ~order by~ clause to sort by the
string length:

#+begin_src sql
SELECT
    first_name, last_name, length(first_name || last_name) len
FROM
    real_person
ORDER BY
        LEN desc
LIMIT
    10;
#+end_src

*** Filter rows using ~where~
:PROPERTIES:
:CUSTOM_ID: where
:END:
You can get output from a column by checking a condition that you specify, for instance, if
you need to get full names of people from China in your database, you can use the ~where~
using the following syntax:
#+begin_src sql
SELECT first_name, country
        FROM real_person
             Where country = 'CN'
                   LIMIT 10;
#+end_src

#+RESULTS:
#+begin_example
| first_name  | country |
|-------------+---------|
| Ernestine   | CN      |
| Jacquenette | CN      |
| Tobin       | CN      |
| Marten      | CN      |
| Gideon      | CN      |
| Rayshell    | CN      |
| Hendrick    | CN      |
| Ronnie      | CN      |
| Nessie      | CN      |
| Ingaborg    | CN      |
#+end_example

Note that the condition that comes after  where, should return only true or false like basic
arithmetic operators: >, =, < etc. Let's manipulate it and try to get only the people with
first name that is less than 9 letters.
#+begin_src sql
    SELECT
        first_name || ' ' || last_name Full_Name
    FROM real_person
    WHERE LENGTH(first_name ||''|| last_name) < 9;
#+end_src

#+RESULTS:
#+begin_example
| full_name |
|-----------|
| Nap Algie |
| Dex Basil |
| Arty Cane |
| Leo Danko |
| Ralf Jzak |
| Ham Hayes |
| Susy Vye  |
| Beck Tew  |
| Had Rizzo |
| Cy Levay  |
| Ara Jorin |
| Vi Cagan  |
| Caro Vany |
| De Izatt  |
| Jon Scole |
#+end_example

You can use any of the following operators:
| Operator | Description                              |
|----------+------------------------------------------|
| =        | Equal to                                 |
| >        | Greater than                             |
| <        | Less than                                |
| >=       | Greater than or equal                    |
| <=       | Less than or equal                       |
| !=       | Not equal                                |
| AND      | Logical AND                              |
| OR       | Logical OR                               |
| LIKE     | Return true if a value matches a pattern |
| IS NULL  | Return true if a value is NULL           |
|----------+------------------------------------------|

*** IN
You use ~IN~ operator in the WHERE clause to check if a value matches any value in a list of values.

Suppose you want to know the rental information of customer id 1 and 2, you can use the IN
operator in the WHERE clause as follows:
#+begin_src sql
    SELECT customer_id,
           rental_id,
           return_date
    FROM rental
         WHERE
            customer_id IN (1,2)
            order by customer_id desc
    LIMIT 40;
#+end_src

#+RESULTS:
#+begin_example
| customer_id | rental_id | return_date           |
|-------------+-----------+-----------------------|
| 2           | 15907     | 2005-08-25 23:23:35.0 |
| 2           | 320       | 2005-05-28 04:30:24.0 |
| 2           | 2128      | 2005-06-24 00:41:58.0 |
| 2           | 5636      | 2005-07-13 02:36:24.0 |
| 2           | 5755      | 2005-07-19 17:02:56.0 |
| 2           | 7346      | 2005-08-02 16:48:42.0 |
| 2           | 7376      | 2005-08-04 10:35:02.0 |
| 2           | 7459      | 2005-08-02 21:07:20.0 |
| 2           | 8230      | 2005-08-06 19:52:59.0 |
| 2           | 8598      | 2005-08-01 08:39:59.0 |
| 2           | 8705      | 2005-08-02 16:01:29.0 |
| 2           | 9031      | 2005-08-04 10:45:10.0 |
| 2           | 9236      | 2005-08-08 18:52:43.0 |
| 2           | 9248      | 2005-08-05 11:19:11.0 |
| 2           | 9296      | 2005-08-08 11:57:13.0 |
| 2           | 9465      | 2005-08-06 16:43:53.0 |
| 2           | 10136     | 2005-08-03 19:44:56.0 |
| 2           | 10466     | 2005-08-06 06:28:26.0 |
| 2           | 10918     | 2005-08-02 21:23:56.0 |
| 2           | 11087     | 2005-08-10 10:37:41.0 |
| 2           | 11177     | 2005-08-10 10:55:48.0 |
| 2           | 11256     | 2005-08-04 16:39:53.0 |
| 2           | 11614     | 2005-08-20 07:04:18.0 |
| 2           | 12963     | 2005-08-23 11:37:04.0 |
| 2           | 14475     | 2005-08-27 08:59:32.0 |
| 2           | 14743     | 2005-08-29 00:18:56.0 |
| 2           | 15145     | 2005-08-31 15:51:04.0 |
| 1           | 8326      | 2005-08-01 05:16:49.0 |
| 1           | 15315     | 2005-08-30 01:51:46.0 |
| 1           | 14762     | 2005-08-23 01:30:57.0 |
| 1           | 11299     | 2005-08-10 16:40:52.0 |
| 1           | 11367     | 2005-08-04 13:19:38.0 |
| 1           | 14825     | 2005-08-27 07:01:57.0 |
| 1           | 11824     | 2005-08-19 10:11:54.0 |
| 1           | 573       | 2005-06-03 06:32:23.0 |
| 1           | 1185      | 2005-06-23 02:42:12.0 |
| 1           | 1422      | 2005-06-19 15:54:53.0 |
| 1           | 1476      | 2005-06-25 02:26:46.0 |
| 1           | 1725      | 2005-06-17 21:05:57.0 |
| 1           | 12250     | 2005-08-22 23:05:29.0 |
#+end_example

Notice that you can also use ~=~ and ~OR~ operators instead, like this:
#+begin_src sql
SELECT
	rental_id,
	customer_id,
	return_date
FROM
	rental
WHERE
	customer_id = 1 OR customer_id = 2
ORDER BY
	return_date DESC;
#+end_src

*** Group using ~group by~

:PROPERTIES:
:CUSTOM_ID: group_by
:END:
This statements illustrate the usage of ~group by~ clause:

#+begin_src sql
    SELECT
            country, count(country)
    FROM
            real_person
   GROUP BY country
   ORDER BY count(country) desc
   LIMIT 10;
#+end_src

This statement divide the rows by its ~count~ values and then group it by calculating the sum
of the total occurrence for each country, the result should be like:

#+RESULTS:
#+begin_example
| country | count |
|---------+-------|
| CN      | 173   |
| ID      | 114   |
| RU      | 60    |
| PH      | 48    |
| BR      | 41    |
| PL      | 38    |
| FR      | 37    |
| SE      | 35    |
| PT      | 27    |
| CZ      | 22    |
#+end_example

*** Filter group using ~having~
:PROPERTIES:
:CUSTOM_ID: having
:END:
#+NOTE: Since the HAVING clause is evaluated before the SELECT clause, you cannot use column aliases in the HAVING clause. Because at the time of evaluating the HAVING clause, the column aliases specified in the SELECT clause are not available.

The ~having~ clause specifies a search condition for a group or an aggregate. Its syntax
using is like the following:
#+begin_src sql
SELECT
	column1,
	aggregate_function (column2)
FROM
	table_name
GROUP BY
	column1
HAVING
	condition;
#+end_src

You might have noticed that it is to close to the clause ~WHERE~, that's almost right but:
PostgreSQL evaluates the ~having~ clause after ~from~, ~where~ and ~group by~. ~WHERE~
allows you to filter groups of rows according to a specified condition (see [[#where][where]]), ~HAVING~
allows you to apply the condition to a group of rows instead. Thus, it's used more
frequently with the clause ~GROUP BY~.

Consider the following example using group by to get the count numbers of each country:

#+begin_src sql
    SELECT
            country, count(country)
    FROM
            real_person
   GROUP BY country
   ORDER BY count(country) desc
   LIMIT 10;
#+end_src

#+RESULTS:
#+begin_example
| country | count |
|---------+-------|
| CN      | 173   |
| ID      | 114   |
| RU      | 60    |
| PH      | 48    |
| BR      | 41    |
| PL      | 38    |
| FR      | 37    |
| SE      | 35    |
| PT      | 27    |
| CZ      | 22    |
#+end_example

Using ~HAVING~ we can specify a condition in that group, let's say we only need to get the
countries with more than 100 count:

#+begin_src sql
    SELECT
            country, count(country)
    FROM
            real_person
   GROUP BY country
   HAVING count(country) > 100
   ORDER BY count(country) desc
   LIMIT 10;
#+end_src

#+RESULTS:

: | country | count |
: |---------+-------|
: | CN      | 173   |
: | ID      | 114   |

*** Perform set operations using ~UNION~, ~intersect~ and ~except~
**** ~UNION~

Consider the following two tables:
#+begin_src sql
SELECT * FROM
         top_rated_movies;
#+end_src

#+RESULTS:
: | title                    | release_year | id |
: |--------------------------+--------------+----|
: | The Shawshank Redemption | 1994         | 1  |
: | The Godfather            | 1972         | 2  |
: | 12 Angry Men             | 1957         | 3  |

#+begin_src sql
SELECT * FROM
         most_popular_films;
#+end_src

#+RESULTS:
: | title              | release_year | id |
: |--------------------+--------------+----|
: | An American Pickle | 2020         | 1  |
: | Greyhound          | 2020         | 3  |
: | The Godfather      | 1972         | 2  |

The ~UNION~ operator combines result sets of two or more ~SELECT~ statements into a single
result set. It uses the following syntax:
#+begin_src sql
SELECT select_list_1
FROM table_expresssion_1
UNION
SELECT select_list_2
FROM table_expression_2
#+end_src
Let's test it in ~top_rated_movies~ and ~most_popular_films~:
#+begin_src sql
SELECT * from top_rated_movies
         UNION
SELECT * from most_popular_films;
#+end_src

#+RESULTS:
: | title                    | release_year | id |
: |--------------------------+--------------+----|
: | The Godfather            | 1972         | 2  |
: | Greyhound                | 2020         | 3  |
: | 12 Angry Men             | 1957         | 3  |
: | The Shawshank Redemption | 1994         | 1  |
: | An American Pickle       | 2020         | 1  |

You may have noticed that Godfather occurs only once, this is because the ~UNION~ operator
removes all the duplicated rows, and by 'duplicated' we mean that they are the same in every
column (in this case, they should be equal in title, release_year, and id), to get rid of
that and get all the duplicated rows togother, use ~UNION ALL~ instead:

#+begin_src sql
SELECT * from top_rated_movies
         UNION ALL
SELECT * from most_popular_films;
#+end_src

#+RESULTS:
: | title                    | release_year | id |
: |--------------------------+--------------+----|
: | The Shawshank Redemption | 1994         | 1  |
: | The Godfather            | 1972         | 2  |
: | 12 Angry Men             | 1957         | 3  |
: | An American Pickle       | 2020         | 1  |
: | Greyhound                | 2020         | 3  |
: | The Godfather            | 1972         | 2  |
**** ~INTERSENCT~
The ~INTERSECT~ operator returns any rows that are available in both result sets:
#+begin_src sql
SELECT * from top_rated_movies
         INTERSECT
SELECT * from most_popular_films;
#+end_src

#+RESULTS:
: | title         | release_year | id |
: |---------------+--------------+----|
: | The Godfather | 1972         | 2  |
We got "The Godfather" as it is the only value that is available in both results.
**** ~EXCEPT~

The ~EXCEPT~ operator returns distinct rows from the first (left) query that are not in the
output of the second (right) query.

The following statement uses the ~EXCEPT~ operator to find the top-rated films that are not popular:

#+begin_src sql
SELECT * FROM top_rated_movies
EXCEPT
SELECT * FROM most_popular_films;
#+end_src

#+RESULTS:
: | title                    | release_year | id |
: |--------------------------+--------------+----|
: | The Shawshank Redemption | 1994         | 1  |
: | 12 Angry Men             | 1957         | 3  |
*** Grouping Sets
Consider the following table:
#+begin_src sql
    SELECT * FROM sales;
#+end_src

#+RESULTS:
: | brand | segment | quantity |
: |-------+---------+----------|
: | ABC   | Premium | 100      |
: | ABC   | Basic   | 200      |
: | XYZ   | Premium | 100      |
: | XYZ   | Basic   | 300      |

Suppose that we need to get the sum of quantity for each brand, we can implement this using
the following simple statement:
#+begin_src sql
    SELECT brand, sum(quantity)
           FROM sales
                GROUP by brand;
#+end_src

#+RESULTS:
: | brand | sum |
: |-------+-----|
: | ABC   | 300 |
: | XYZ   | 400 |

And if we need to know the quantity by its segment:
#+begin_src sql
    SELECT segment, sum(quantity)
           FROM sales
                GROUP by segment;
#+end_src

#+RESULTS:
: | segment | sum |
: |---------+-----|
: | Basic   | 500 |
: | Premium | 200 |

And, to get the total sum quantity we can do:

#+begin_src sql
    SELECT sum(quantity) total_sum
           FROM sales;
#+end_src

#+RESULTS:
: | total_sum |
: |-----------|
: | 700       |


Suppose we need to get all of those tables in the same query, we can use the ~union~ or
~union all~ clause like this:

#+begin_src sql
SELECT
    brand,
    segment,
    SUM (quantity)
FROM
    sales
GROUP BY
    brand,
    segment

UNION ALL

SELECT
    brand,
    NULL,
    SUM (quantity)
FROM
    sales
GROUP BY
    brand

UNION ALL

SELECT
    NULL,
    segment,
    SUM (quantity)
FROM
    sales
GROUP BY
    segment

UNION ALL

SELECT
    NULL,
    NULL,
    SUM (quantity)
FROM
    sales;
#+end_src

#+RESULTS:
#+begin_example
| brand | segment | sum |
|-------+---------+-----|
| XYZ   | Basic   | 300 |
| ABC   | Premium | 100 |
| ABC   | Basic   | 200 |
| XYZ   | Premium | 100 |
| ABC   |         | 300 |
| XYZ   |         | 400 |
|       | Basic   | 500 |
|       | Premium | 200 |
|       |         | 700 |
#+end_example


Notice that we added ~NULL~ twice in the last selection statement since all columns should
be equal as we use the ~union all~ clause.

Even though the above query works as you expected, it has two main problems:
- It's lengthy and can be implemented in shorter way.
- It has a performance issue because PostgreSQL has to scan the ~sales~ table separately for
  each query.
The ~GROUPING SETS~ allows you to define multiple grouping sets in the same query.

#+begin_src sql
SELECT
    brand,
    segment,
    SUM (quantity)
FROM
    sales
GROUP BY
GROUPING SETS(
(brand, segment),
(brand),
(segment),
()
     );
#+end_src

#+RESULTS:
#+begin_example
| brand | segment | sum |
|-------+---------+-----|
|       |         | 700 |
| XYZ   | Basic   | 300 |
| ABC   | Premium | 100 |
| ABC   | Basic   | 200 |
| XYZ   | Premium | 100 |
| ABC   |         | 300 |
| XYZ   |         | 400 |
|       | Basic   | 500 |
|       | Premium | 200 |
#+end_example
**** The ~GROUPING()~ Function
The GROUPING() function accepts an argument which can be a column name or an expression:

#+begin_src sql
GROUPING( column_name | expression)
#+end_src

It returns bit 0 if the argument is a member of the current grouping set and 1 otherwise,
consider the following example:
#+begin_src sql
SELECT grouping(brand) is_brand_grouped,
       grouping(segment) is_segment_grouped,
       brand,
       segment,
       sum(quantity)
FROM SALES
GROUP by
        grouping sets(
                (brand),
                    (segment),
                        ()
        );
#+end_src

#+RESULTS:
: | is_brand_grouped | is_segment_grouped | brand | segment | sum |
: |------------------+--------------------+-------+---------+-----|
: | 1                | 1                  |       |         | 700 |
: | 0                | 1                  | ABC   |         | 300 |
: | 0                | 1                  | XYZ   |         | 400 |
: | 1                | 0                  |       | Basic   | 500 |
: | 1                | 0                  |       | Premium | 200 |
**** ~ROLLUP~ and ~CUBE~
However we have saved some times using the ~grouping sets~ clause, it could be even better
if we didn't need to write all these argument to get the ~grouping by~ result for each
column. Thankfully PostgreSQL has two clauses, ~CUBE~ and ~ROLLUP~ which save us some time.

When you call the ~ROLLUP~ clause with the following argument like this: ~ROLLUP(c1,c2,c3)~
it generate the following 4 grouping sets:
#+begin_src
(c1, c2, c3)
(c1, c2)
(c1)
()
#+end_src

Example:
#+begin_src sql
SELECT brand, segment, sum(quantity) FROM sales GROUP BY ROLLUP (brand,segment) order by sum desc;

#+end_src

#+RESULTS:
: | brand | segment | sum |
: |-------+---------+-----|
: |       |         | 700 |
: | XYZ   |         | 400 |
: | ABC   |         | 300 |
: | XYZ   | Basic   | 300 |
: | ABC   | Basic   | 200 |
: | XYZ   | Premium | 100 |
: | ABC   | Premium | 100 |

The same thing is wise ~CUBE~ but instead of generating 4 tables for ~(c1,c2,c3)~, ~CUBE~
generate all possible grouping sets:
#+begin_src
 (c1,c2,c3),
 (c1,c2),
 (c1,c3),
 (c2,c3),
 (c1),
 (c2),
 (c3),
 ()
#+end_src
*** Joins
PostgreSQL join is used to combine columns from one (self-join) or more tables based on the
values of the common columns between related tables. The common columns are typically the
primary key columns of the first table and foreign key columns of the second table.

Consider those tables:
#+begin_src sql
SELECT * FROM basket_a;
#+end_src

#+RESULTS:
: | a | fruit_a  |
: |---+----------|
: | 1 | Apple    |
: | 2 | Orange   |
: | 3 | Banana   |
: | 4 | Cucumber |


#+begin_src sql
SELECT * FROM basket_b;
#+end_src

#+RESULTS:
: | b | fruit_b    |
: |---+------------|
: | 1 | Orange     |
: | 2 | Apple      |
: | 3 | Watermelon |
: | 4 | Pear       |

**** Inner Join

The following statement joins the first table (~basket_a~) with the second table (~basket_b~) by
matching the values in the ~fruit_a~ and ~fruit_b~ columns:

#+begin_src sql
SELECT
      *
FROM
      basket_a
INNER JOIN basket_b
     ON fruit_a = fruit_b;
#+end_src

#+RESULTS:
: | a | fruit_a | b | fruit_b |
: |---+---------+---+---------|
: | 1 | Apple   | 2 | Apple   |
: | 2 | Orange  | 1 | Orange  |

The inner join examines each row in the first table (~basket_a~). It compares the value in the
~fruit_a~ column with the value in the ~fruit_b~ column of each row in the second table
(~basket_b~). If these values are equal, the inner join creates a new row that contains
columns from both tables and adds this new row the result set.

{{< figure src="https://salehmu.github.io/images/PostgreSQL-Join-Inner-Join.png" alt="" >}}

*Notice* that If you reference columns with the same name from different tables in a query,
you will get an error. To avoid the error, you need to qualify these columns fully using the
following syntax:

#+begin_src sql
table_name.column_name
#+end_src

**** Left Join
The following statement uses the left join clause to join the ~basket_a~ table with the
~basket_b~ table. In the left join context, the first table is called the left table and the
second table is called the right table.

#+begin_src sql
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
LEFT JOIN basket_b
   ON fruit_a = fruit_b;
#+end_src

#+RESULTS:
: | a | fruit_a  | b | fruit_b |
: |---+----------+---+---------|
: | 1 | Apple    | 2 | Apple   |
: | 2 | Orange   | 1 | Orange  |
: | 3 | Banana   |   |         |
: | 4 | Cucumber |   |         |

The left join starts selecting data from the left table. It compares values in the fruit_a
column with the values in the fruit_b column in the basket_b table.

If these values are equal, the left join creates a new row that contains columns of both
tables and adds this new row to the result set.

In case the values do not equal, the left join also creates a new row that contains columns
from both tables and adds it to the result set. However, it fills the columns of the right
table (~basket_b~) with null.

The following Venn diagram illustrates the left join:
{{< figure src="https://salehmu.github.io/images/PostgreSQL-Join-Left-Join.png" alt="" >}}

**** Right Join
Just like above, but right.
**** Full Outer Join
Consider the following two tables:
#+begin_src sql
SELECT * FROM departments;
#+end_src

#+RESULTS:
: | department_id | department_name |
: |---------------+-----------------|
: | 1             | Sales           |
: | 2             | Marketing       |
: | 3             | HR              |
: | 4             | IT              |
: | 5             | Production      |

#+begin_src sql
SELECT * FROM employees;
#+end_src

#+RESULTS:
: | employee_id | employee_name   | department_id |
: |-------------+-----------------+---------------|
: | 1           | Bette Nicholson | 1             |
: | 2           | Christian Gable | 1             |
: | 3           | Joe Swank       | 2             |
: | 4           | Fred Costner    | 3             |
: | 5           | Sandra Kilmer   | 4             |
: | 6           | Julia Mcqueen   |               |


We use the ~FULL OTHER JOINT~ if we want to query data from both ~employee~ and
~departments~ tables, here is the syntax:
#+begin_src sql
SELECT * FROM A
FULL [OUTER] JOIN B on A.id = B.id;
#+end_src

For example, to get every employee who belongs to a department and every department which have an
employee:
#+begin_src sql
SELECT employees.employee_name, departments.department_name
        FROM employees
FULL OUTER JOIN departments on departments.department_id = employees.department_id;
#+end_src

#+RESULTS:
: | employee_name   | department_name |
: |-----------------+-----------------|
: | Bette Nicholson | Sales           |
: | Christian Gable | Sales           |
: | Joe Swank       | Marketing       |
: | Fred Costner    | HR              |
: | Sandra Kilmer   | IT              |
: | Julia Mcqueen   |                 |
: |                 | Production      |

**** Cross Join

*** Sub-queries
Suppose we want to find the films whose rental rate is higher than the average rental rate.
We can do it in two steps:

+ Find the average rental rate by using the SELECT statement and average function ~AVG~

  #+begin_src sql
SELECT
	AVG (rental_rate)
FROM
	film;
  #+end_src

  #+RESULTS:
  : | avg                |
  : |--------------------|
  : | 2.9800000000000000 |

+ Use the result of the first query in the second SELECT statement to find the films that we want.
#+begin_src sql
SELECT
	film_id,
	title,
	rental_rate
FROM
	film
WHERE
	rental_rate > 2.98
    LIMIT 10;
#+end_src

#+RESULTS:

#+begin_example
| film_id | title             | rental_rate |
|---------+-------------------+-------------|
| 133     | Chamber Italian   | 4.99        |
| 384     | Grosse Wonderful  | 4.99        |
| 8       | Airport Pollock   | 4.99        |
| 98      | Bright Encounters | 4.99        |
| 2       | Ace Goldfinger    | 4.99        |
| 3       | Adaptation Holes  | 2.99        |
| 4       | Affair Prejudice  | 2.99        |
| 5       | African Egg       | 2.99        |
| 6       | Agent Truman      | 2.99        |
| 7       | Airplane Sierra   | 4.99        |
#+end_example


This two steps can be shortened to one step using a subquery. A subquery is a query nested
inside another query such as ~SELECT~, ~INSERT~, ~DELETE~ and ~UPDATE~. In this tutorial, we are
focusing on the SELECT statement only.

To construct a subquery, we put the second query in brackets and use it in the WHERE clause
as an expression:
#+begin_src sql
    SELECT
        film_id,
            title,
                rental_rate
    FROM
        film
    WHERE
        rental_rate > (
        SELECT AVG(rental_rate) from film
                    ) limit 10;
#+end_src

#+RESULTS:
#+begin_example
| film_id | title             | rental_rate |
|---------+-------------------+-------------|
| 133     | Chamber Italian   | 4.99        |
| 384     | Grosse Wonderful  | 4.99        |
| 8       | Airport Pollock   | 4.99        |
| 98      | Bright Encounters | 4.99        |
| 2       | Ace Goldfinger    | 4.99        |
| 3       | Adaptation Holes  | 2.99        |
| 4       | Affair Prejudice  | 2.99        |
| 5       | African Egg       | 2.99        |
| 6       | Agent Truman      | 2.99        |
| 7       | Airplane Sierra   | 4.99        |
#+end_example

**** Subquery using ~IN~
We as a subquery can return a table as well, we can use the table output in another query,
for example, consider the following query to get the movies that returned date better
~2005-05-29~ and ~2005-05-30~:
#+begin_src sql
SELECT
	inventory.film_id
FROM
	rental
INNER JOIN inventory ON inventory.inventory_id = rental.inventory_id
WHERE
	return_date BETWEEN '2005-05-29'
AND '2005-05-30' LIMIT 10;
#+end_src

#+RESULTS:
#+begin_example
| film_id |
|---------|
| 870     |
| 971     |
| 573     |
| 288     |
| 89      |
| 681     |
| 858     |
| 776     |
| 257     |
| 397     |
#+end_example

Now we can use this output table in another query, say we want to get the full data about
those fimls:

#+begin_src sql
SELECT
	film_id,
	title
FROM
	film
WHERE
	film_id IN (
		SELECT
			inventory.film_id
		FROM
			rental
		INNER JOIN inventory ON inventory.inventory_id = rental.inventory_id
		WHERE
			return_date BETWEEN '2005-05-29'
		AND '2005-05-30'
	) limit 10;
#+end_src

#+RESULTS:
#+begin_example
| film_id | title             |
|---------+-------------------|
| 307     | Fellowship Autumn |
| 255     | Driving Polish    |
| 388     | Gunfight Moon     |
| 130     | Celebrity Horn    |
| 563     | Massacre Usual    |
| 397     | Hanky October     |
| 898     | Tourist Pelican   |
| 228     | Detective Vision  |
| 347     | Games Bowfinger   |
| 1000    | Zorro Ark         |
#+end_example

*** Exist
The ~EXIST~ operator is a boolean operator that returns the existence or rows in a subquery,
its syntax looks like the following:
#+begin_src sql
EXISTS (subquery)
#+end_src
If the subquery returns at least one row, the result of ~EXISTS~ is true. In case the subquery
returns no row, the result is of ~EXISTS~ is false.

*Note* that if the subquery returns NULL, the result of ~EXISTS~ is true.

Suppose we want to find the customers who have at least one payment whose amount is greater
than 11:
#+begin_src sql
SELECT first_name,
       last_name
FROM customer c
WHERE EXISTS
    (SELECT 1
     FROM payment p
     WHERE p.customer_id = c.customer_id
       AND amount > 11 )
ORDER BY last_name;
#+end_src

#+RESULTS:
#+begin_example
| first_name | last_name |
|------------+-----------|
| Kent       | Arsenault |
| Nicholas   | Barfield  |
| Victoria   | Gibson    |
| Tanya      | Gilbert   |
| Karen      | Jackson   |
| Terrance   | Roush     |
| Rosemary   | Schmidt   |
| Vanessa    | Sims      |
#+end_example

Of course we can implement it using ~inner join~:
#+begin_src sql
SELECT first_name,
       last_name
FROM customer c
         INNER JOIN payment p on c.customer_id = p.customer_id and p.amount > 11
order by last_name;
#+end_src

#+RESULTS:
#+begin_example
| first_name | last_name |
|------------+-----------|
| Kent       | Arsenault |
| Nicholas   | Barfield  |
| Victoria   | Gibson    |
| Tanya      | Gilbert   |
| Karen      | Jackson   |
| Terrance   | Roush     |
| Rosemary   | Schmidt   |
| Vanessa    | Sims      |
#+end_example

** Tables Management
*** Upsert
The idea of Upsert in PostgreSQL is that when you insert a new row into a table, PostgreSQL
will update the row if it already exists, otherwise it will insert the new row.

To use the upsert in PostgreSQL, we use the ~INSER ON CONFLICT~ statement as follows:
#+begin_src sql
INSERT INTO table_name(column_list)
VALUES(value_list)
ON CONFLICT target action;
#+end_src

Consider the following table:

#+begin_src sql
select * from customers;
#+end_src

#+RESULTS:
: | customer_id | name      | email                 | active |
: |-------------+-----------+-----------------------+--------|
: | 1           | IBM       | contact@ibm.com       | true   |
: | 2           | Microsoft | contact@microsoft.com | true   |
: | 3           | Intel     | contact@intel.com     | true   |

Suppose that there is a new customer, for instance let's say it's google, and we have
Microsoft changed their email address, instead of inserting google and update Microsoft, why
not insert both of them in one operating?
#+begin_src sql
INSERT INTO customers (name, email)
Values
        ('Google', 'fuckgoogle@ihategoogle.com')
        ('Misrosoft', 'microsoft@virtualmachine.com')
ON CONFLICT (name)
DO UPDATE SET email = excluded.email
#+end_src


#+begin_src sql
SELECT * FROM customers;
#+end_src


#+RESULTS:
: | customer_id | name      | email                        | active |
: |-------------+-----------+------------------------------+--------|
: | 1           | IBM       | contact@ibm.com              | true   |
: | 2           | Microsoft | contact@microsoft.com        | true   |
: | 3           | Intel     | contact@intel.com            | true   |
: | 4           | Google    | fuckgoogle@ihategoogle.com   | true   |
: | 5           | Misrosoft | microsoft@virtualmachine.com | true   |

*** Alert
To change the structure of an existing table, you use PostgreSQL ~ALTER TABLE~ statement
with the following
#+begin_src sql
ALTER TABLE table_name action;
#+end_src
Using ~ALERT~ we can do many actions:
**** Add a column
To add a new column to an existing table, you use the ~ALTER TABLE ADD COLUMN~ statement as
follows:
#+begin_src sql
ALTER TABLE table_name
ADD COLUMN new_column_name data_type constraint;
#+end_src

**** Drop a Column
To drop a column from a table, you use ~ALTER TABLE DROP COLUMN~ statement:
#+begin_src sql
ALTER TABLE table_name
DROP COLUMN column_name;
#+end_src

**** Rename a Column
To rename a column, you use the ~ALTER TABLE RENAME COLUMN TO~ statement:
#+begin_src sql
ALTER TABLE table_name
RENAME COLUMN column_name
TO new_column_name;
#+end_src

**** Rename a Table
ALTER TABLE table_name
RENAME TO new_table_name;
**** Change The Type of a Column
To change the data type of a column, you use the ~ALTER TABLE~ statement as follows:
#+begin_src sql
ALTER TABLE table_name
ALTER COLUMN column_name [SET DATA] TYPE new_data_type;
#+end_src

**** Change The Default Value of a Column
To change a default value of the column, you use ALTER TABLE ALTER COLUMN SET DEFAULT or
DROP DEFAULT:
#+begin_src sql
ALTER TABLE table_name
ALTER COLUMN column_name
[SET DEFAULT value | DROP DEFAULT];
#+end_src

**** Change ~NOT NULL~ Constrain
#+begin_src sql
ALTER TABLE table_name
ALTER COLUMN column_name
[SET NOT NULL| DROP NOT NULL];
#+end_src
**** Add Constrain
#+begin_src sql
ALTER TABLE table_name
ADD CONSTRAINT constraint_name constraint_definition;
#+end_src

**** Importing
To import ~CVS~
https://www.postgresqltutorial.com/export-postgresql-table-to-csv-file/
*** Truncate
https://www.postgresqltutorial.com/postgresql-truncate-table/
*** Temporary Tables
https://www.postgresqltutorial.com/postgresql-temporary-table/
To remove all data from a table, you use the DELETE statement. However, when you use the
DELETE statement to delete all data from a table that has a lot of data, it is not
efficient. In this case, you need to use the TRUNCATE TABLE statement:
#+begin_src sql
TRUNCATE TABLE table_name;
#+end_src
*** Other Utilities
**** Delete
The PostgreSQL DELETE statement allows you to delete one or more rows from a table with the
following syntax:
#+begin_src sql
DELETE FROM table_name
WHERE condition;
#+end_src

**** Update
We use the ~UPDATE~ statement to modify data in a table with the following syntax:
#+begin_src sql
UPDATE table_name
SET column1 = value1,
    column2 = value2,
    ...
WHERE condition;
#+end_src
The ~WHERE~ clause is optional. If you omit the ~WHERE~ clause, the UPDATE statement will update
all rows in the table.
The ~UPDATE~ statement has an optional ~RETURNING~ clause that returns the updated rows:

#+begin_src sql
UPDATE table_name
SET column1 = value1,
    column2 = value2,
    ...
WHERE condition
RETURNING * | output_expression AS output_name;
#+end_src
***** TODO Update Join

** Logging
PostgreSQL log_statement parameter is basically related to error and reporting to log error,
warning and database queries, we can log_statement in PostgreSQL as per options we
configured in configuration file. Default log_statement option in PostgreSQL configuration
file is none means nothing log anything into the error file. There are four options of
log_statement of error and SQL query reporting i.e. none, ddl, mod and all, DDL specifies
that log all ddl query into error log. All options of log_statement is defined as log all
queries of database server. Log_statement is important parameter in PostgreSQL.

*Example. 1*
#+begin_src sql
show log_statement;
select * from student;
insert into student values (12, 'PQR', 1234567890);
#+end_src

#+DOWNLOADED: screenshot @ 2022-03-14 01:46:13

#+DOWNLOADED: screenshot @ 2022-03-14 01:46:27
[[file:Introduction_into_PostgreSQL/2022-03-14_01-46-27_screenshot.png]]



*Example. 2*
#+begin_src sql
alter system set log_statement = 'DDL';
show log_statement;
insert into student values (14, 'PQR', 1234567890);id = 13;
delete from student where stud_id = 13;
select * from student;
#+end_src


[[file:Introduction_into_PostgreSQL/2022-03-14_01-47-23_screenshot.png]]

** Check
+ [[https://www.postgresql.org/docs/current/datatype.html][Data Types]]
+ [[https://www.postgresql.org/docs/9.5/sql-createsequence.html][Sequence]]
