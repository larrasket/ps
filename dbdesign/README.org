#+title: Relational Database Design

* f


** Introduction
Nowadays, when people talk about a database, they usually refer to a Relational database,
but that has not always been the case. In fact, the term database is defined, by the Merriam
Webster English dictionary as, a "usually large collection of data organized especially for
rapid search and retrieval (as by a computer)". The Relational model is one way to organize
a large collection of data, but not the only one.

In the earlier days of computing, there was only one way to organize data. Due to the
limitations of storage on punch cards, punch tape, or magnetic tape, data had to stored as a
single continuous stream of data. This model for storing is data is called the /Sequential
file format/ or the /flat/ file format. A typical flat file would contain a series of
records, which corresponds to individual cards in a deck of punch card. Each record would
contain some information and in most cases, the information only made sense in the
sequential context of the file. For instance, the record with generic information about a
customer, could be followed by one or two address records, each containing an address. The
processing program would know which customer the address belongs to by reading the records
in order and remembering the last customer read.

The structure of flat flies could easily become quite complex. For instance, the customer
would not only have one or two addresses, they would hopefully, also place many orders and
each order could encompass multiple product ordered records. Records that track the product
ordered along with the quantity, the price, and the promise discount, if any. If the same
company then also wanted to trick their product catalog and automatically watch stock
levels, the second flat file would have to be added for the products. Each product would
have one record with generic product information, followed by number of records for
deliveries adding to our stock level, and then all the product ordered records for that
product. These records are the same collection of records also included in the customers
file, but in a different order, and the limitations of Sequential storage left, there's no
choice but to accept this duplication and try to write program code to prevent, but also
detect report, and repair any inconsistencies.

When spinning discs became available and affordable, new storage models were designed to
take advantage of the new ability to do Random IO with only a minor performance hit. The
first new kid on the block was the Hierarchal database. Conceptually, this was not very
different from the flat file model. The same data could still be processed in the same
order, but now that order was no longer implemented by storing the records in that specific
order, they could be stored anywhere on the disc. The logical order was imposed by so called
pointer chains. Each record would store a few extra bytes, the pointer, containing the
location on disc of the record that was logically next.

This new model only actually developed into a hierarchy because more than one pointer was
added to each record, but order record would not only have a pointer to its first product or
order record, but it would also have a pointer to the customer that placed the order and the
pointer to the next order record for the same customer allowing programs to process all
orders for a customer without having to read all the details of the order. Some
implementations would even add extra pointers to allow navigation in two directions, but
since storage was still very expensive in those days, not everyone was willing to pay for
those extra bytes.

The advantages of hierarchal databases were clear. The extra navigational possibilities
combined with the higher speed of spinning discs enabled businesses to create their first
programs to read, act upon, and modify data in real-time, but there were disadvantages as
well. The design of the database was very ridged. Modifications often required the database
to be dumped to a flat file, dropped, recreated, and then rebuilt from that flat file and
then all application programs also had to be modified to support a new design. Plus, data
such as the product orders records, still had to be stored multiple times if it was part of
multiple hierarchies.

The next development the Network database solved that. This database used the same pointer
technique as the Hierarchal database, but now even more pointers could be added to a record,
so that it could be a member of multiple hierarchies. So each product ordered record would
not only have pointers to their owning order in logically next product ordered record within
that hierarchy, but it would also have pointers to their owning product, the product being
ordered, and the logically next record within that hierarchy. This solved the problem of
having to duplicate data, but at the price of added complexity into the design of the
database, which of course was just as ridged as a hierarchal database.

In 1970, Dr. E. F.  Codd published a milestone scientific paper. He proposed a model for
data storage that abstracted all storage internals, such as pointers or physical storage
order, away from the users of the database. In his proposal, the model for data storage was
based on Mathematical Set Theory. This paper laid the foundation for the Storage Model that
is the most wide used now, the Relational Database. It took a lot of time before the
Relational database actually started to make an impact on the market mainly because the
requirements to storage capacity and processing power exceeded what was available in the
1970's, but once the hardware developments caught up, Relational technology took off to
become the defector standard for generic data storage.

** The Relational Model
The Relational Model is based on mathematics or to be more precise, on Set Theory and
First-order predicate logic. That doesn't mean you have to be a mathematician to use a
Relational database, but having some knowledge of these underlying concepts can help
understand some of the typical behavior of Relational databases. However, none of the
mainstream Relational databases are a true implementation of the Relational model. They all
feature details the deviate from the original Relational model.


In a Relational database, data is stored in one or more tables. Each table is a collection
of rows and columns, however, in Relational theory other terms are commonly used. A *table
is called a relation*, a *row is called a tuple*, and a *column is often called an
attribute.* Data values can be stored at every intersection of a row and a column. Both the
rows and the columns within each table are by definition in order. You cannot reference a
column as the third column, nor a row s the 21st row. Columns have to be referenced by their
name, which therefore has to be unique within each table and rows are referenced by one or
more of their attributes that combined uniquely identify a single row. The attributes that
are used for this purpose are called the *primary key*. This is one of the features that set
Relational databases off from all other storage methods available at that time. There are
still separate storage containers for separate kinds of data like customer order, and
product ordered, but the relationships between them like which order was placed by what
customer, are now no longer implemented in terms of physical storage. Instead, the
connection is made only on a logical basis by adding the primary key of a customer in the
storage area for an order.

A second important difference is that the rules for Relational databases only describe the
behavior of the database, not the implementation. So if in the records still choose to
implement the relationship by order and customer using a pointer, as long as this
implementation is handled transparently by the Relational engine, none are exposed to the
outside world. You don't even need to know anything about how a specific database implements
things and you would still be able to use it. Just as you don't need to know anything about
car engines in order to drive one, however, just as with car engines, having some knowledge
about the internals will help you to get more performance out of the engine.

Dr. Codd formulated a set of rules that are now known as Codd's Twelve Rules, even though
there are actually 13. There rules govern the behavior of Relational database management
systems. I will not cover them all, but I will explain some of them.

Rule 1, the Information Rule states that information can only be stored as values in a table
not in any other way. Rule 2, the Guaranteed Access Rule states that every value must be
accessible using a combination of a table name, a column name, and values of the primary key
columns.  Rule 3, Systematic Treatment of Null Values defines how missing data should be
handled. Data values can be stored at every intersection of a row and a column, but this
rule says that every such intersection can also store a special marker to indicate that
there is no data value at this intersection. This marker should be independent of the
columns data type, and it should be different from any value supported by the data type. So
no magic values suggest 0 or -1. The database management system should treat these markers
in a systematic way. Rule 5, the Comprehensive Data Sublanguage Rule states that the
database management system must support a language for data and schema manipulation that can
be used both programmatically and interactively. In all mainstream Relational database
management systems this language is SQL the Structured Query Language. Rule 7, High-level
Insert, Update, and Delete states that the language must provide the ability to insert,
update, or delete data in whole sets at a time. Rules 8 and 9, Physical Data Independence
and Logical Data Independence are related to shielding the application program from
implementation detials so that implementations choices can be changed without requiring a
change to the application code. Rule 10, Integrity Independence states that the database
management system must support the ability to define rules that govern data integrity as
part of the schema and that the database management system will then ensure that those rules
are not violated.

** ER Modeling
There are many methods for designing a database and probably even more methods for
presenting a graphical representation of the design. Almost all modeling methods use some
variation of ER modeling, which is short for Entity Relationship modeling. I will use ER
modeling in this course as well and for the graphical representation of the model, I will
use the IDEF1x notation, which currently is very popular.

There are good reasons for the popularity of ER modeling. When used in communicating with
layman such as the subject matter experts that you're working with to create your model, but
also future users of the database application you are designing, or the managers who are
responsible for paying your bill, they are not ideal. Not everyone is able to think and
communicate at the abstraction layer where database models are, but they are at least a lot
easier to understand than some other diagramming techniques.Especially when used with a good
tool, automatically hiding details when looking at a helicopter perspective of entire data
model and then adding in more details as you zoom in specific subsections can be a great
help in getting to understand both the broad picture, as well as the detials you're
currently working on. Finally, it is extremely simple to convert a finished ER modeling into
a logical database design and it is in fact even possible to start with a database that was
already built and to reverse engineer that into an ER diagram that you can then use as a
starting point to get to understand the database design, find and repair its flaws, and
extend its functionality. However, there are also risks involved when using ER modeling.
Because the diagrams are accessible enough that the mangers and end users can mostly
understand them, IT professionals have fallen for the trap of having subject matter experts
or managers sign off on an ER diagram which is silly, even though the subject matter expert
or manager may get a generic understanding of such a diagram, he or she will not understand
the details nor be able to verify that everything is entirely accurate. A data modeler
asking for a sign off on an ER diagram and then blaming the customer if the finished
database does not work as intended is like an architect asking you to sign off on the
stability calculations for the house he designed for you, and then blaming you if the house
collapses.

Another risk with using ER diagrams is none of the available diagramming techniques can
capture all the details an analyst may discover during his work and details that are not
captured in a model often get lost and have to be discovered again. Finally, because there
are so many different diagramming techniques with sometimes only minor differences, people
with different backgrounds may think they use the same notation, even if that is not
actually the case.

*** Entity
The term Entity, refers to everything be it a physical object, a person, an event, or an
abstract notion that is relevant within the context of the information system being
designed. So if I am creating a data model for my local Snooker Club, examples of entities
that correspond to physical objects will be Snooker table 3, or the 4 bottles of Coke in
stock at the bar. Examples of persons will be Mary or Dave both members of the Club.
Relevant events will include the 2012 Christmas Tournament or my upcoming match against Mary
where I get to defend my second to last position in the C League, and examples of abstract
notions will be that same C League or Dave's January 2013 membership fee payment.


All the examples I have named are individual entities sometimes also explicitly called
entity instances. In data modeling, looking at individual instances may be a good way to ask
the subject matter expert a question or to clarify consequences of model choices, but the
model itself is concerned with a higher abstraction level. Entity instances, for which the
same kind of information is gathered, are grouped together in a new concept the entity type
or entity class. An entity type is a single concept to describe all instances of the same
type.  So, even though Mary, Dave, and I are very different we are all members of the
Snooker Club.  The Snooker Club tracks birthdates, membership fee payments, and met results
for all three of us. So in a data model, we are all instances of the same entity type
member.  Unfortunately, many people tend to shorten the term Entity type to just Entity,
which of course is very confusing because an entity is officially and entity instance.

For my Snooker Club I already mentioned the entity type member. Similarly, all Snooker
tables on the club are instances of the entity type table. Both the 2012 Christmas
Tournament and the 2013 Midsummer Tournament are instances of the entity type tournaments
and the A, B, C, and Junior Leagues are all instances of the Entity type League.

In IDEF1x, an Entity type is represented by a rectangle, horizontally divided into two areas
with the unique entity type name written on top of the rectangle. Some entity types are
represented by a rectangle with rounded corners.

[[file:2022-06-11_06-31-14_screenshot.png]]

*** Attributes


Neither Entity types nor Entity occurrences are very interesting on their own, but
occurrences become interesting by recording facts about them. So for one of our Snooker Club
members, we might record facts like one our members is named Dave. Dave has phone number
555-0163, then, Dave was born on December 12, 1982. These fact contain information about the
name, phone number, and birth date of a specific occurrence of the entity type member.
Abstracting these facts to the abstraction layer of the model, we call each class a fact an
attribute and each attribute is associated to exactly one entity type. For instance, the
facts Dave was born on December 12, 1982 and Mary was born April 18, 1948 are of the same
class. That effects about the birth date of a specific member of the Club. So in the ER
model, those effects and all others of the same class are abstracted to the attribute birth
date of the entity type member.

In an IDEF1x diagram, attributes are represented by their
name, placed in the rectangle that represents the entity type they belong to. Most attribute
names are places below dividing line in the entity type symbol. Only the so called key
attributes are placed above the dividing line.

So, what is a key attribute? This is actually
a concept we are all very familiar with. We all have been in situations where we wanted to
identify a single occurrence in a group. For instance, can you give me that apple? No, not
that one, the one just to the left of it looks tastier. Or, check out that girl over there,
not the tall one with the long dark hair, but the on just to the left of her, isn't she
great? So you all know how inconvenient it is if you cannot identify a single occurrence in
a group of similar entity occurrences. In our Snooker Club, it's no different. We are a
small club, so we are able to distinguish our members are name only, which is great. That
makes Name the key attribute of members in our club, but a much larger sports club like a
football club probably has many members named Dave and if one of them doesn't pay his
membership fees, none of the other Dave's should get into trouble over that. So the football
club will probably assign each member a unique number and use that to distinguish the
members from each other. In their data model Name, will be a regular non-key attribute of
the member entity type and member number will be the key attribute. There will not always be
a single attribute that identifies unique occurrences of the entity type. In those cases,
the combination of two or more attributes has to be used. The membership fee payment entity
type is a good example of this. There is not a single membership fee payment occurrence for
Dave, he has to pay his membership fee every month. There also is not a single membership
fee payment occurrence for January 2013, as all our members have to pay each month, but
there is only one membership fee payment for Dave's membership in January 2013. The
combination of member name, year, and month identifies a single membership fee payment. So
those three attributes are all key attributes for this entity type. The keys that are formed
out of more than one attribute are called composite keys. It's also possible for an entity
type to have more than one attribute or combination of attributes that could be used as the
key. In those cases, one of these so called candidates keys is chosen to be the primary key.
All other candidate keys become alternate keys. In IDEF1x, this is shown in a diagram by
placing an abbreviation AK in parentheses after the attribute name, because there can be
more than one Alternate Key, the letter AK are usually followed by a number.


[[file:2022-06-11_06-41-52_screenshot.png]]


*** Relationships

No man is an island and no thing stand on its own. That is true in the real world and
because the data model is supposed to model the real world, it is true in a data model as
well. Entities relate with each other both at the instance level and at the abstractive
class level. At the instance level, it is hard to tell the difference between an attribute
and a relationship because they both appear as facts.

For instance, Dave plays in the B
league. The only difference between facts of this type and the facts we saw before is that
in this case, the fact not only gives information about an instance entity type member, but
it also relates it to an instance of entity type league. So we can say that the relationship
is a class of facts that associate an instance of an entity type with another instance of an
entity type.

In an IDEF1x diagram, normal relationships are represented using dashed lines
connecting the entity types that play a role in the relationship. So for Dave plays in the B
league, a dashed line is drawn between the rectangles representing the member entity type
and the league entity type. An important property of relationships in an ER model is their
cardinality. A cardinality is a restriction on how often an entity occurrence may
participate in the collection effects represented by the relationship. Members or our club,
cannot compete in more than one league. So, since Dave already plays in the B league no
other similar facts about Dave can be valid at the same time and the same applies to all
members. No member can appear more than once in the collection of facts that this
relationship represents. We call this the maximum cardinality. The *maximum cardinality* of
entity type member in this relationship is 1.

However, we can have other similar facts about
the B league like for instance Mary plays in the B league. So the entity type league has a
maximum cardinality of *many* in this relationship. Relationships with a maximum cardinality
of 1 on one side and many on the other side are the most common relationships. They are
called one-to-many relationships. In these relationships the entity type whose instances can
participate in many facts is called the parent and the entity type whose instances can only
appear once is the child.


In IDEF1x, the parent entity type is visualized by placing a dot
at the end of the relationship line that connects to the child entity type. You can read
this dot s, the entity at the other end of this line, can appear more than once in this
relationship.

[[file:f/2022-06-11_06-45-12_screenshot.png]]


 Conversely, the child entity type is marked by not placing at a dot at the
parent end.

The absence of this dot can then be read as the entity type at the other end of
this line cannot appear more than once in this relationship. In addition, all key attributes
of the parent entity type are added as normal attributes for the child entity type and they
are marked FK for Foreign Key. The word key in this name can be confusing. They are not key
attributes in a child entity type, but normal attributes that reference the key of another
entity type, the parent. This Foreign Key attribute is how the relationship is implemented.
We track who plays in what league by adding the league code in the storage area for a clock
member. We cannot do it the other way around. If we wanted to add the member name in the
storage area for a league, we would have to reserve room for a potentially unlimited number
of members who play in that league.


In addition to the maximum cardinality, relationships
have a minimum cardinality as well. Our club has a few recreational members. They are free
to stop by and use the tables when they fancy a game of Snooker, but they are not scheduled
for the league competition matches. So for Jimmy, one of those recreational members, no fact
of the type Jimmy plays in league exist. That means that the minimum cardinality for entity
member in this relationship is 0. Looking at the other side of the relationship line, we see
the entity type league and since a league without members playing in them makes no sense,
the minimum cardinality for this entity type is 1. Notation of minimum cardinality in IDEF1x
is different for parent and child entities. For the child entity type, a minimum cardinality
of 0 is symbolized by placing a diamond at the end of the line that connects to the parent.
Each instance of the child entity type is associated with 0 or 1 parent occurrences. This is
also called an optional relationship. No symbol at the parent ends means that the minimum
cardinality for the child is 1, each child occurrence has to be associated with exactly one
parent. For the parent entity type a minimum cardinality of 1 is represented by placing a P
for positive next to the dot at the child end of the line and a minimum cardinality of 0 is
represented by leaving the dot as is.

IDEF1x also supports special cardinalities. For
instance, if we require all leagues to have exactly 10 members the symbol P can be replaced
with the number 10 or if each league has a minimum of 8 and the maximum of 12 members the
notation 8-12 would be used. Finally, for really odd requirements like every league has to
contain an even number of members, a parenthesized number can be used. This is a reference
to a note elsewhere on the page that explains the cardinality rule. Finally, to enable
better understanding of diagram, one or two readings of the relationship are added to the
line. The reading is the verb phrase of the facts represented by the relationship type.
However, IDEF1x requires that the reading must be in parent to child order, although the
child to parent reading can optionally be added as well.

For the required parent to child
reading, you may have to rephrase the facts. In our example case, the possible parent to
child reading could be contains. The child to parent reading is of course plays in. Now the
meaning end cardinality of a relationship can be reconstructed by following the line,
reading appropriate symbols along the way. Each league contains one or more members or going
in the other direction, each member plays in 0 or 1 league. One thing to be aware of when
working in auto languages is that creating and using relationship readings and this way
works great in English because most English sentences are built using the form subject, very
phrase, object. Other languages may use different word orders or even insert the object and
subject between parts of the verb phrase. In those languages, finding good reading for the
relationships can be challenging.
