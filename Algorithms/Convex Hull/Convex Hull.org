#+TITLE: Convex Hull
* Convex Hull
A convex hull of a set of points is the smallest convex polygon that contains every one of
the points. It is defined by a subset of all the points in the original set. One way to
think about a convex hull is to imagine that each of the points is a peg sticking up out of
a board. Take a rubber band and stretch it around all of the points. The polygon formed by
the rubber band is a convex hull.
* Left Point

+ It has the minimum Y
+ Smallest X
+ Creats angles $\leq 180$ with other points/edges

* Jarvi's Algorithm

The core of Jarvi's algorithm is described in the following points:

1. Initialize $p$ as leftmost point
2. Do the following as long as we don't come back to the leftmost point again:
   1. The next point $q$ is the point such that the triple $(p,\ q,\ r)$ is counterclockwise for any other point $r$.

      To find this we simply initialize $q$ as the next point, then we traverse through the
      all points. For any point $i$, if $i$ is more counterclockwise, then we update $q =
      i$. How to check if point is more counterclockwise? We can use orientation checker:

      You can do it using the cosine segemts formula:
      that, let $A$ and $B$ be two vectors, then $A \cdot B = |A| \cdot |B| \cos(\theta)$ where
      1. Calculate $\cos(\theta) = \frac{a \cdot b}{|a| \cdot |b| }$
      2. Use the $acos$ function to calculate $\theta$
            [[file:Jarvi's_Algorithm/2021-12-21_01-32-29_screenshot.png]]

            Or simpler
            [[file:Jarvi's_Algorithm/2021-12-21_04-01-10_screenshot.png]]
           Using slope value, calculate $(y2 - y1) \cdot (x3 - x2) - (y3 - y2) \cdot (x2 - x1)$
           If the subtraction in negative, then it's counterclockwise, if it is positive then it's
            clockwise, if it is 0 thin it is collinear.
            [[file:Jarvi's_Algorithm/2021-12-21_05-14-28_screenshot.png]]

            #+begin_src c++
              int orientation(Point p, Point q, Point r) {
                  int val = (q.y - p.y) * (r.x - q.x) -
                            (q.x - p.x) * (r.y - q.y);

                  if (val == 0) return 0;  // collinear
                  return (val > 0)? 1: 2; // clock or counterclock wise
              }
            #+end_src
            If it was collinear, we consider the longest distance point.
            $d = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2 )^2}$
            #+begin_src c++
            float distance(int x1, int y1, int x2, int y2) {
                return sqrt(pow(x2 - x1, 2) +
                            pow(y2 - y1, 2) * 1.0);
            }
            #+end_src

   2. next[p] = q (store $q$ as next of $p$ in the output convex hull)
   3. $p = q$ (Set p as q for the next iteration)
      [[file:Jarvi's_Algorithm/2021-12-21_04-26-24_screenshot.png]]


Now, let's repeat in C(++):

#+begin_src C++
#include <vector>
#include <iostream>
#include <cmath>
#define x 0
#define y 1
#define point vector<int>
using namespace std;
int orinetation(point p, point q, point r) {
    int val = (q[y] - p[y] ) * (r[x] - q[x]) -
        (q[x] - p [x] ) * (r[y] - q[y]);
    if (val ==0 ) return 0; // collinear
    return (val > 0) ? 1 : 2;

}

float dis(point p, point q) {
    return sqrt(   pow(p[x] - q[x], 2) +
                    pow(p[y] - q[y] , 2) * 1.0 );
}

vector<vector<int>> jarvis_march(vector<vector<int>> points) {
    int n = points.size();
    vector<vector<int>>hull;
    if (n < 3) return hull;
    // find list most
    int l = 0;
    for (int i = 1; i < n; i++) {
        if (points[i][x] < points[l][x])
            l = i;
    }
    int q, left = l;
    do {
    hull.push_back(points[l]);
    q = (l+1) % n;
    for (int i = 0; i < n; i++) {
        int direction = orinetation(points[l], points[i], points[q]);
        if(direction == 2 || ( direction == 0 && dis(points[i], points[l]) > dis(points[q],points[l]))  )
            q = i;
    }
    l=q;

    } while (l != left );
    return hull;
}
int main() {
    vector<vector<int>> po { {1,4}, {3,3} , {5,5} , {9,6} , {5,2}, {0,0} , {3,1} , {7,0} };
    vector<vector<int>>l = jarvis_march(po);
    for (auto i : l)
        {
        for (auto k : i)
            cout << k << " ";

                cout << endl;
        }

}
#+end_src

#+RESULTS:
| 0 | 0 |
| 7 | 0 |
| 9 | 6 |
| 1 | 4 |

Python implementation:
#+begin_src python
def jarvis_march(points):
    # find the leftmost point
    a =  min(points, key = lambda point: point.x)
    index = points.index(a)

    # selection sort
    l = index
    result = []
    result.append(a)
    while (True):
        q = (l + 1) % len(points)
        for i in range(len(points)):
            if i == l:
                continue
            # find the greatest left turn
            # in case of collinearity, consider the farthest point
            d = direction(points[l], points[i], points[q])
            if d > 0 or (d == 0 and distance_sq(points[i], points[l]) > distance_sq(points[q], points[l])):
                q = i
        l = q
        if l == index:
            break
        result.append(points[q])

    return result
#+end_src
A visualization:
{{< figure src="https://salehmu.github.io/images/Animation_depicting_the_gift_wrapping_algorithm.gif" alt="" >}}* Graham's scan Algorithm

** Trace
Let's try to trace the C(++) program above with the very same given points in the program:

#+DOWNLOADED: screenshot @ 2021-12-21 07:10:38
[[file:Jarvi's_Algorithm/2021-12-21_07-10-38_screenshot.png]]

The program first finds the leftmost point by sorting the points on x-coordinates. The
leftmost point for the above set of points is $l=(0,0)$. We insert the point $(0,0)$ into the
convex hull vertices as shown by the green circle in the figure below.

[[file:Jarvi's_Algorithm/2021-12-21_07-10-45_screenshot.png]]


Next we find the left most point from point $l=(0,0)$. The step by step process of finding the
left most point from $l=(0,0)$ is given below.

1. We pick a point following $l$ and call it $q$. Let $q$ be the point $(3,3)$ (You can pick any point, generally we pick next of $l$ in array of points).

2. Let all other points except $l$ and $q$ be $i$. Now we check whether the sequence of points ($l,i,q)$ turns right. If it turns right, we replace $q$ by $i$ and repeat the same process for remaining points.

3. Let $i=(7,0)$. The sequence $((0, 0), (7, 0), (3, 3))$ turns left. Since we only care about right turn, we donâ€™t do anything in this case and simply move on.

4. Let next $i=(3,1)$. The sequence $((0, 0), (3, 1), (3, 3))$ turns left and we move on without doing anything.

5. Let next $i=(5,2)$. The sequence $((0, 0), (5, 2), (3, 3))$ again turns left and we move on.

6. Next $i=(5,5)$. The sequence $((0, 0), (5, 2), (3, 3))$ is collinear. In the case of collinear, we replace $q$ with $i$ only if distance between $l$ and $i$ is greater than distance between $q$ and $l$. In this case the distance between $(0,0)$ and $(5,5)$ is greater than the distance between $(0,0)$ and $(3,3)$ we replace q with point $(5,5)$.

7. Let next $i=(1,4)$. The sequence $((0, 0), (1, 4), (5, 5))$ turns right. We replace $q$ by point $(1,4)$.

8. Finally the only choice for $i$ is $(9,6)$. The sequence $((0, 0), (9, 6), (1, 4))$ turns left. So we do nothing. We went through all the points and now $q=(1,4)$ is the left most point.

We add point $(1,4)$ to the convex hull.
[[file:Jarvi's_Algorithm/2021-12-21_07-10-57_screenshot.png]]

Next, we find the leftmost point from the point $(1,4)$ following the steps 1 - 8 mentioned
[[file:Jarvi's_Algorithm/2021-12-21_07-11-22_screenshot.png]]

above. If we follow all the steps, the leftmost point will be $(9,6)$.
[[file:Jarvi's_Algorithm/2021-12-21_07-11-46_screenshot.png]]

Using the same process, the leftmost point from $(9,6)$ will be the point $(7,0)$.
[[file:Jarvi's_Algorithm/2021-12-21_07-11-58_screenshot.png]]

Finally from $(7,0)$ we compute the leftmost point. The leftmost point from $(7,0)$ will be
the point $(0, 0)$. Since $(0,0)$ is already in the convex hull, the algorithm stops.

** Complexity
The algorithm spends $O(n)$ time on each convex hull vertex. If there are h convex hull
vertices, the total time complexity of the algorithm would be $O(nh)$. Since h is the number
of output of the algorithm, this algorithm is also called output sensitive algorithm since
the complexity also depends on the number of output.

** Further Reading
- Briquet, C. (n.d.). Introduction to Convex Hull Applications. Lecture. Retrieved August 23, 2018, from http://www.montefiore.ulg.ac.be/~briquet/algo3-chull-20070206.pdf
- Erickson, J. (n.d.). Convex Hulls. Lecture. Retrieved August 23, 2018, from http://jeffe.cs.illinois.edu/teaching/373/notes/x05-convexhull.pdf
- Mount, D. M. (n.d.). CMSC 754 Computational Geometry. Lecture. Retrieved August 23, 2018, from https://www.cs.umd.edu/class/spring2012/cmsc754/Lects/cmsc754-lects.pdf

* Monotone chain Algorithm
* Problems Demystified
Let's solve some problems.
