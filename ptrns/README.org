#+TITLE: Golang Design Patterns
#+DATA: <2022-01-15 Sat>
#+hugo_tags: "Computer Science"

#+BEGIN_PREVIEW
/Based on  Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph
Johnson and John Vlissides/
#+END_PREVIEW


* Introduction & Basic Definition

Christopher Alexander says, "Each pattern describes a problem which occurs over and over
again in our environment, and then describes the core of the solution to that problem, in
such a way that you can use this solution a million times over, without ever doing it the
same way twice". Even though Alexander was talking about patterns in buildings and towns,
what he says is true about object-oriented design patterns. Our solutions are expressed in
terms of objects and interfaces instead of walls and doors, but at the core of both kinds of
patterns is a solution to a problem in a context.  In general, a pattern has four essential
elements:

1. The pattern name is a handle we can use to describe a design problem, its so lutions, and consequences in a word or two. Naming a pattern immediately increases our design vocabulary. It lets us design at a higher level of abstraction. Having a vocabulary for patterns lets us talk about them with our colleagues, in our documentation, and even to ourselves. It makes it easier to think about designs and to communicate them and their trade-offs to others. Finding good names has been one of the hardest parts of developing our catalog.
2. The problem describes when to apply the pattern. It explains the problem and its context. It might describe specific design problems such as how to represent algo- rhythms as objects. It might describe class or object structures that are symptomatic of an inflexible design. Sometimes the problem will include a list of conditions that must be met before it makes sense to apply the pattern.
3. The solution describes the elements that make up the design, their relationships, responsibilities, and collaborations. The solution doesn't describe a particular concrete design or implementation, because a pattern is like a template that can be applied in many different situations. Instead, the pattern provides an abstract description of a design problem and how a general arrangement of elements (classes and objects in our case) solves it.
4. The consequences are the results and trade-offs of applying the pattern. Though consequences are often unvoiced when we describe design decisions, they are critical for evaluating design alternatives and for understanding the costs and benefits of applying the pattern.

* Behavioral Patterns [0/18]
** TODO Strategy
** TODO Singleton
** TODO Command
** TODO Null Object
** TODO Specification Pattern
** TODO State
** TODO Data Access Pattern
** TODO Mediator
** TODO Chain of Responsibility
** TODO Template Method
** TODO Visitor
** TODO Memento
** TODO Rules Engine Pattern
** TODO Bridge
** TODO Interpreter
** TODO Iterator
** TODO Observer
** TODO Discussion of Behavioral Patterns
* Creational Patterns [0/5]
** TODO Builder
** TODO Prototype
** TODO Factory Design Pattern
** TODO Factory Method
** TODO Abstract Factory
* Structural Patterns [0/7]
** TODO Facade
** TODO Decorator
** TODO Composite
** TODO Adapter
** TODO Flyweight
** TODO Proxy
** TODO Discussion of Structural Patterns
