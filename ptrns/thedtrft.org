#+TITLE: Golang Design Patterns
#+DATA: <2022-01-15 Sat>
#+hugo_tags: "Computer Science"

#+BEGIN_PREVIEW
/Based on  Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph
Johnson and John Vlissides/
#+END_PREVIEW


* Introduction & Basic Definition

Christopher Alexander says, "Each pattern describes a problem which occurs over and over
again in our environment, and then describes the core of the solution to that problem, in
such a way that you can use this solution a million times over, without ever doing it the
same way twice". Even though Alexander was talking about patterns in buildings and towns,
what he says is true about object-oriented design patterns. Our solutions are expressed in
terms of objects and interfaces instead of walls and doors, but at the core of both kinds of
patterns is a solution to a problem in a context.  In general, a pattern has four essential
elements:

1. The pattern name is a handle we can use to describe a design problem, its so lutions, and consequences in a word or two. Naming a pattern immediately increases our design vocabulary. It lets us design at a higher level of abstraction. Having a vocabulary for patterns lets us talk about them with our colleagues, in our documentation, and even to ourselves. It makes it easier to think about designs and to communicate them and their trade-offs to others. Finding good names has been one of the hardest parts of developing our catalog.
2. The problem describes when to apply the pattern. It explains the problem and its context. It might describe specific design problems such as how to represent algo- rhythms as objects. It might describe class or object structures that are symptomatic of an inflexible design. Sometimes the problem will include a list of conditions that must be met before it makes sense to apply the pattern.
3. The solution describes the elements that make up the design, their relationships, responsibilities, and collaborations. The solution doesn't describe a particular concrete design or implementation, because a pattern is like a template that can be applied in many different situations. Instead, the pattern provides an abstract description of a design problem and how a general arrangement of elements (classes and objects in our case) solves it.
4. The consequences are the results and trade-offs of applying the pattern. Though consequences are often unvoiced when we describe design decisions, they are critical for evaluating design alternatives and for understanding the costs and benefits of applying the pattern.

* Behavioral Patterns [0/17]
** TODO Strategy
** TODO Singleton
Singleton pattern is easy to remember. As the name implies, it will provide you a single
instance of an object and guarantee that there are no duplicates.

At the first call to use the instance, it is created and then reused between all the parts
in the application that need to use that particular behavior.


You'll use Singleton pattern in many different situations. For example:
+ When you want to use the same connection to a database to make every query
+ When you open a Secure Shell (SSH) connection to a server to do a few tasks, and don't want to reopen the connection for each task
+ If you need to limit the access to some variable or space, you use a Singleton as the door to this variable (We'll see in the following chapters that this is better achievable in Go using channels anyway)
+ If you need to limit the number of calls to some places, you create a Singleton instance to make the calls in the accepted window


The possibilities are endless, and we have just mentioned some of them.

As an example of an object of which we must ensure that there is only one instance, we will
write a counter that holds the number of times it has been called during program execution.
With these requirements, we can write the following acceptance criteria.


There are some requirements and acceptance criteria for using the unique criteria; they are
as follows:


+ When no counter has been created before, a new one is created with the value 0
+ If a counter has already been created, return this instance that holds the actual count
+ If we call the method AddOne, the count must be incremented by 1

We have a scenario with three tests to check in our unit tests.

Go's implementation of this pattern is slightly different from what you'll find in pure
object- oriented languages like Java or C++ where you have static members. In Go, there's
nothing like static members, but we have package scope to deliver a similar result. First,
we are going to write the package declarations for the ~singleton~ object:


#+begin_src go
type singleton struct {
	count int
}
var instance *singleton

func GetInstance() *singleton {
	return nil
}

func (s *singleton) AddOne() int {
	return 0
}
#+end_src

As we are following a TDD approach while writing the code, let's code the tests that use the
functions we have just declared. The tests are going to be defined:

#+begin_src go
package creational
import "testing"
func TestGetInstance(t *testing.T) {
counter1 := GetInstance()
if counter1 == nil {
//Test of acceptance criteria 1 failed
	t.Error("A new connection object must have been made")
}
expectedCounter := counter1
}
#+end_src


The first test checks something obvious, but not less important, in complex applications. We
actually receive something when we ask for an instance of the counter. We have to think of
it as of a Creational pattern. we delegate the creation of the object to an unknown package
that could fail in the creation or retrieval of the object. We also store the current
counter in the variable ~expectedCounter~ to make a comparison later.

#+begin_src go
currentCount := counter1.AddOne()
if currentCount != 1 {
t.Errorf("After calling for the first time to count, the count must be 1
but it is %d\n", currentCount)
}
#+end_src

Now we take advantage of the zero-initialization feature of Go. Remember that integer types
in Go cannot be nil and as we know that this is the first call to the counter and it is an
integer type of variable, we also know that it is zero-initialized. So after the first call
to ~AddOne()~ function, the value of the count must be 1.



** TODO Null Object
** TODO Specification Pattern
** TODO State
** TODO Data Access Pattern
** TODO Mediator
** TODO Chain of Responsibility
** TODO Template Method
** TODO Visitor
** TODO Memento
** TODO Rules Engine Pattern
** TODO Bridge
** TODO Interpreter
** TODO Iterator
** TODO Observer
** TODO Discussion of Behavioral Patterns
* Creational Patterns [0/6]
** TODO Command
** TODO Builder
** TODO Prototype
** TODO Factory Design Pattern
** TODO Factory Method
** TODO Abstract Factory
* Structural Patterns [0/7]
** TODO Facade
** TODO Decorator
** TODO Composite
** TODO Adapter
** TODO Flyweight
** TODO Proxy
** TODO Discussion of Structural Patterns
