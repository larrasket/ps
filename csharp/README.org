#+title: ".NET Notes in C#"
#+date: 2022-01-08T05:28:26+02:00
#+draft: false
#+categories: ["Computer Science"]
#+description: C# Notebook
#+hugo_tags: "Computer Science" ".NET"
* Speaking C#
** Discover C# Compiler Version
With the C# 7.x generation, Microsoft decided to increase the cadence of language
releases, releasing minor version numbers, also known as point releases, for the first
time since C# 1.1.

To discover your compiler version, you can go to your terminal and run the command:
#+begin_src shell
dotnet --version
#+end_src

#+RESULTS:
: 6.0.100

To determine which versions of the C# compiler you have available, enter
the following command:
#+begin_src shell
csc -langversion:?
#+end_src

#+RESULTS:
: 1
: 2
: 3
: 4
: 5
: 6
: 7.0
: 7.1
: 7.2
: 7.3
: 8.0 (default)
: latestmajor
: preview
: latest
*** Choose a Specific Language Version
Developer tools like Visual Studio Code and the dotnet command-line interface assume that
you want to use the latest major version of a C# language compiler by default. So before C#
8.0 was released, C# 7.0 was the latest major version and was used by default.

To use the improvements in a C# point release like 7.1, 7.2, or 7.3, you had to add a
configuration element to the project file, as shown in the following markup:
#+begin_src html
<LangVersion>7.3</LangVersion>
#+end_src
The parameter between ~Langversion~ should be one of the following:
| LangVersion           | Description                                                 |
|-----------------------+-------------------------------------------------------------|
| ~7, 7.2, 8~           | A specific version number will use that compiler.           |
| ~latestmajor~         | Uses the highest major version. (7.0 in 2019, 8.0 in 2020). |
| ~latest~              | uses the highest major and minor version (7.3) in 2018.     |
| ~preview~             | use the highest available prevew version.                   |

After creating a new project with the dotnet command-line tool, you can edit the
csproj file and add the ~<LangVersion>~ element, as shown highlighted in the
following markup:

#+begin_src html
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
<OutputType>Exe</OutputType>
<TargetFramework>netcoreapp3.0</TargetFramework>
<LangVersion>preview</LangVersion>
</PropertyGroup>
</Project>
#+end_src

Your projects must target either ~netcoreapp3.0~ or ~netstandard2.1~ to use the full
features of C# 8.0.
** C# Basics

C# indicates the end of a statement with a semicolon. A statement can be composed of
multiple variables and expressions. For example, in the following statement, ~totalPrice~ is a
variable and ~subtotal + salesTax~ is an expression:

#+begin_src C++
var totalPrice = subtotal + salesTax;
#+end_src

*** Comments

When writing your code, you're able to add comments to explain your code using a double
slash, //. By inserting it the compiler will ignore everything after the until the end of
the line, as shown in the following code:

#+begin_src C#
/*
This is a multi-line
comment.
*/
#+end_src
*** Blocks
In English, we indicate a paragraph by starting a new line. C# indicates a block of
code with the use of curly brackets, { }. Blocks start with a declaration to indicate
what it is being defined. For example, a block can define a namespace, class, method,
or a statement, something we will learn more about later.
#+begin_src csharp
foreach (var arg in Args) {
    Console.WriteLine(arg);
}
#+end_src
*** Methods

In English, verbs are doing or action words, like run and jump. In C#, doing or action
words are called methods. There are hundreds of thousands of methods available to
C#. In English, verbs change how they are written based on when in time the action
happens. For example, Amir was jumping in the past, Beth jumps in the present, they
jumped in the past, and Charlie will jump in the future.

In C#, methods such as WriteLine change how they are called or executed based
on the specifics of the action.
*** Types
In English, nouns are names that refer to things. For example, Fido is the name of
a dog. The word "dog" tells us the type of thing that Fido is, and so in order for Fido
to fetch a ball, we would use his name.

In C#, their equivalents are types, fields, and variables. For example, Animal and
Car are types; that is, they are nouns for categorizing things. Head and Engine
are fields, that is, nouns that belong to Animal and Car. Whilst Fido and Bob are
variables, that is, nouns for referring to a specific thing.

There are tens of thousands of types available to C#, though have you noticed how
I didn't say, "There are tens of thousands of types in C#?" The difference is subtle
but important. The language of C# only has a few keywords for types, such as
string and int, and strictly speaking, C# doesn't define any types. Keywords such
as string that look like types are aliases, which represent types provided by the
platform on which C# runs.
**** Sorting Basic Types
***** Text
Use ~string~ to store long text, and ~char~ to store a letter:
#+begin_src csharp
string x = "World";
char   c = 'W';
#+end_src
***** Numbers
Use ~int~ to store an integer, ~uint~ to store an unsigned integer:
#+begin_src csharp
int i = -32;
uint ii = 1412;
#+end_src
***** Whole Numbers

The decimal number system, also known as Base 10, has 10 as its base, meaning there
are ten digits, from 0 to 9. Although it is the number base most commonly used by
human civilizations, other number-base systems are popular in science, engineering,
and computing. The binary number system also known as Base 2 has two as its base,
meaning there are two digits, 0 and 1.

The following table shows how computers store the decimal number 10. Take note of
the bits with the value 1 in the 8 and the 2 columns; 8 + 2 = 10:

|-----+-----+-----+-----+-----+-----+-----+-----|
| 128 |  64 |  32 |  16 |   8 |   4 |   2 |   1 |
|-----+-----+-----+-----+-----+-----+-----+-----|
| *0* | *0* | *0* | *0* | *1* | *0* | *1* | *0* |
|-----+-----+-----+-----+-----+-----+-----+-----|

So, 10 in decimal is ~00001010~ in binary.

Two of the improvements seen in C# 7.0 and later are the use of the underscore
character, _, as a digit separator and support for binary literals. You can insert
underscores anywhere into the digits of a number literal, including decimal, binary,
or hexadecimal notation, to improve legibility. For example, you could write the
value for one million in decimal notation, that is, Base 10, as ~1_000_000~

Check if does it works, first initialize 3 values, and then check the equivalence

#+begin_src csharp
int dcml    = 2_000_000; // Two millions in dicimal;
int binary  = 0b_0001_1110_1000_0100_1000_0000;
int hexadecimal = 0x_001E8480;
// Check the equivalence and print it
Console.WriteLine( dcml == binary  );
Console.WriteLine( dcml == hexadecimal  );
#+end_src

#+RESULTS:
| True |
| True |
***** ~object~
There is a special type named object which can store any type of data, but its
flexibility comes at the cost of messier code and possibly poor performance, thuse you
should consider avoid using them as possible.

#+begin_src csharp
object height = 1.88; // storing a double in an object
object name = "Amir"; // storing a string in an object
Console.WriteLine($"{name} is {height} metres tall.");
// int length1 = name.Length; // gives compile error!
int length2 = ((string)name).Length; // tell compiler it's a string
Console.WriteLine($"{name} has {length2} characters.");
#+end_src

#+RESULTS:
: Amir  is   1.88  metres       tall.
: Amir  has     4  characters.

/*tip*/: You don't need to use this, don't use it ever.

***** ~dynamic~
There is another special type named dynamic that can also store any type of data, but
even more than object, its flexibility comes at the cost of performance. The dynamic
keyword was introduced in C# 4.0. However, unlike an object, the value stored in
the variable can have its members invoked without an explicit cast.

#+begin_src csharp
// storing a string in a dynamic object
dynamic anotherName = "Ahmed";
// this compiles but would throw an exception at run-time
// if you later store a data type that does not have a
// property named Length
int length = anotherName.Length;
#+end_src

The following is a comparison between ~object~ and ~dynamic~ types:
| Object                                                                                                          | Dyanmic                                                                                                                                                                                     |
|-----------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| It can store any value because "object" is the base class of all types in the .NET framework.                   | It can store any type of variable, similar to how Visual Basic handles a variable.                                                                                                          |
| Compiler has little information about the type.                                                                 | It is not type-safe, i.e., the compiler doesn't have any information about the type of variable.                                                                                            |
| We can pass the object type as a method argument, and the method also can return the object type.               | A method can both accept a Dynamic type as an argument and return it.                                                                                                                       |
| We need to cast object variables to the original type to use it and to perform desired operations.              | Casting is not required, but you need to know the properties and methods related to stored type.                                                                                            |
| Object can cause problems at run time if the stored value is not converted or cast to the underlying data type. | The Dynamic type can cause problems if the wrong properties or methods are accessed because all the information about the stored value is resolved at run time, compared to at compilation. |
| Useful when we don't have more information about the data type.                                                 | Useful when we need to code using reflection or dynamic languages or with the COM objects due to writing less code.                                                                         |

*** Comparing Double & Decimal Types

~0.1~ doesn't always equal to ~(double) 0.1~. This is a common confusion point in
programming languages, try to run the following code:
#+begin_src csharp
double a = 0.1;
double b = 0.2;
if (a + b == 0.3) {
    Console.WriteLine($"{a} + {b} is equal to  0.3");
} else {
    Console.WriteLine($"{a} + {b} is not equal to  0.3");

}
#+end_src

#+RESULTS:
: 0.1 + 0.2 is not equal to  0.3

The ~double~ type is not guaranteed to be accurate because some numbers
literally cannot be represented as floating-point values.

This is because that most decimals have infinite representations in binary. Take 0.1 for
example. It’s one of the simplest decimals you can think of, and yet it looks so complicated
in binary:

[[file:C#_Basics/2022-01-07_20-44-12_screenshot.png]]

The bits go on forever; no matter how many of those bits you store in a computer, you will
never end up with the binary equivalent of decimal 0.1.

Depending on how many bits of precision are used, the floating-point approximation of 0.1
could be less than 0.1. For example, in half-precision, which uses 11 significant bits, 0.1
rounds to 0.0001100110011 in binary, which is 0.0999755859375 in decimal.

You can just forget about all of that and take the rule of thumb, use ~double~ when accuracy
especially when you compare the equality of two numbers is not important, for example, when
you're measuring a person's height.

A good practice is to never compare ~double~ values using ~==~.

However, a work around is to use the ~decimal~ type with ~M~ suffix, which tells the
compiler that we're dealing with a decimal literal value:

#+begin_src csharp
decimal a = 0.1M;
decimal b = 0.2M;
if (a + b == 0.3M) {
    Console.WriteLine($"{a} + {b} is equal to  0.3");
} else {
    Console.WriteLine($"{a} + {b} is not equal to  0.3");
}
#+end_src

#+RESULTS:
: 0.1 + 0.2 is equal to  0.3

The decimal type is accurate because it stores the number as *a large integer and shifts*
the decimal point. For example, 0.1 is stored as 1, with a note to shift the decimal point
one place to the left. 12.75 is stored as 1275, with a note to shift the
decimal point two places to the left.
**** Getting Default Types
Most of the primitive types except ~string~ are value types, which means that
they must have a value. You can determine the default value of a type using the
~default()~ operator.

The ~string~ type is a *reference type*. This means that ~string~ variables contain the
memory address of a value, not the value itself. A reference type variable can have
a ~null~ value, which is a literal that indicates that the variable does not reference
anything (yet). ~null~ is the default for all reference types. We shall talk about this in
detail later.

#+begin_src csharp
Console.WriteLine($"default(int) = {default(int)}");
Console.WriteLine($"default(bool) = {default(bool)}");
Console.WriteLine($"default(DateTime) = {default(DateTime)}");
Console.WriteLine($"default(string) = {default(string)}");
#+end_src

#+RESULTS:
: default(int)       =  0
: default(bool)      =  False
: default(DateTime)  =  1/1/0001  12:00:00  AM
: default(string)    =

**** Storing Multiple Values

When you need to store multiple values of the same type, you can declare an array.
For example, you may do this when you need to store four names in a string array:

#+begin_src csharp
string[] names; // can reference any array of strings
// allocating memory for four strings in an array
names = new string[4];
// storing
names[0] = "Kate";
names[1] = "Jack";
names[2] = "Rebecca";
names[3] = "Tom";


for (int i = 0; i < names.Length; i++) {
Console.WriteLine(names[i]);
}
#+end_src

#+RESULTS:
| Kate    |
| Jack    |
| Rebecca |
| Tom     |
**** Making a Type 'nullable'
You have now seen how to store primitive values like numbers in variables. But what
if a variable does not yet have a value? How can we indicate that? C# has the concept
of a null value, which can be used to indicate that a variable has not been set.

By default, value types like int and ~DateTime~ must always have a value, hence their
name. Sometimes, for example, when reading values stored in a database that allows
empty, missing, or null values, it is convenient to allow a value type to be null, we
call this a nullable value type.
#+begin_src csharp
int thisCannotBeNull = 4;
// thisCannotBeNull = null; // compile error!
int? thisCouldBeNull = null;
Console.WriteLine(thisCouldBeNull);
Console.WriteLine(thisCouldBeNull.GetValueOrDefault());
thisCouldBeNull = 7;
Console.WriteLine(thisCouldBeNull);
Console.WriteLine(thisCouldBeNull.GetValueOrDefault());
#+end_src

#+RESULTS:
|   |
| 0 |
| 7 |
| 7 |

**** Make it Un-nullable
In some special cases we need to use ~null~, in more special cases we need to make sure that
there will be no ~null~ in our program. The most significant change to the language in C#
8.0 is the introduction of nullable and non-nullable reference types.

In C# 8.0, reference types can be configured to no longer allow the null value by setting a
file- or project-level option to enable this useful new feature. Since this is a big change
for C#, Microsoft decided to make the feature opt-in.

It will take multiple years for this new C# language feature to make an impact since
there are thousands of existing library packages and apps that will expect the old
behavior. Even Microsoft has not had time to fully implement this new feature in
all the core .NET packages. During the transition, you can choose between several
approaches for your own projects:

- Default: No changes needed. Non-nullable references types not supported.
- Opt-in files: Only enable the feature for individual files.
- Opt-in project, opt-out files: Enable the feature at the project level and for any files that need to remain compatible with old behavior, opt out. This is the approach Microsoft is using internally while it updates its own packages to use this new feature.

** Controlling Flow and Converting Types
~Operators~ apply simple operations such as addition and multiplication to operands
such as variables and literal values. They usually return a new value that is the result
of the operation that can be assigned to a variable.

Most operators are binary, meaning that they work on two operands, as shown in the
following pseudocode:
#+begin_src csharp
var result = firstOperand operator secondOperand;
#+end_src
Some operators are unary, meaning they work on a single operand, and can apply
before or after the operand, as shown in the following pseudocode:

#+begin_src csharp
var resultOfOperation = onlyOperand operator;
var resultOfOperation2 = operator onlyOperand;
#+end_src

*** Note on ~foreach~
The foreach statement is a bit different from the other iteration statements.

It is used to perform a block of statements on each item in a sequence, for example,
an array or collection. Each item is usually read-only, and if the sequence structure
is modified during iteration, for example, by adding or removing an item, then an
exception will be thrown

#+begin_src csharp
staring [] names = new string {"ahmed", "barry", "charlie"}
foreach (string name in names) {
Console.WriteLine($"{name} has {name.Length} charachters");
}
#+end_src

Technically, the foreach statement will work on any type that follows these rules:
1. The type must have a method named ~GetEnumerator~ that returns an object.
2. The returned object must have a property named Current and a method named ~MoveNext~.
3. The ~MoveNext~ method must return true if there are more items to enumerate through or false if there are no more items.

There are interfaces named ~IEnumerable~ and ~IEnumerable<T>~ that formally define
these rules but technically the compiler does not require the type to implement these
interfaces.

The compiler turns the foreach statement in the preceding example into something
similar to the following pseudocode:


#+begin_src csharp
IEnumerator e = names.GetEnumerator();
while (e.MoveNext()) {
string name = (string)e.Current; // Current is read-only!
WriteLine($"{name} has {name.Length} characters.");
}
#+end_src


Due to the use of an iterator, the variable declared in a foreach statement cannot be
used to modify the value of the current item.

*** Casting and Converting
Casting is an ubiquitous way to explicitly change the type of a variable, for example,
casting ~double~ variable into an intger:
#+begin_src csharp
double foo = 1.5;
// int bar = foo // gives compile error
int bar = (int)foo;
Console.WriteLine(bar); // loses the ~.5~ part
#+end_src

#+RESULTS:
: 1

Another way is using ~System.Convert~ which is a type converter in ~C#~:
#+begin_src csharp
double g = 9.4;
int i = Convert.ToInt32(g); // Round it to the an approximate value that has
                            // a shorter, simpler, or more explicit representation.
Console.WriteLine(i);
g = 9.6;
i = Convert.ToInt32(g);
Console.WriteLine(i);
#+end_src

#+RESULTS:
|  9 |
| 10 |

*** ~Parase~, ~TryParase~ and ~Convert~

~Parase~ is the opposite of ~ToString~:

#+begin_src csharp
string k = "21";
int i = int.Parse(k);
Console.WriteLine(i);
#+end_src

#+RESULTS:
: 21

However, this can cause some problems in exception, if you are taking some input from use,
you are not always sure that he will give you number:

#+begin_src csharp
string k = "two";
int i = int.Parse(k);
Console.WriteLine(i);
#+end_src

: Unhandled exception. System.FormatException: Input string was not in a correct format.
:   at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)
:   at System.Number.ParseInt32(ReadOnlySpan`1 value, NumberStyles styles, NumberFormatInfo info)
:   at System.Int32.Parse(String s)
:   at Program.Main(String[] args) in /home/slh/Dropbox/org/C-Sharp/Program.cs:line 6

To avoid such an exception, you can use ~TryParse~ instaed of ~Parse~, which shall return
~true~ or ~false~ depends on it worked or not:

#+begin_src csharp
Write("How many eggs are there? ");
int count;
string input = "two";

if (int.TryParse(input, out count)) {

WriteLine($"There are {count} eggs.");}

else {

WriteLine("I could not parse the input.");

}
#+end_src

#+RESULTS:
: How many eggs are there?
: I could not parse the input.

So, what is the difference between each of ~Parse~, ~TryParse~, and ~Convert~?

| /#/ | ~Int.Parase~ | ~Convert.ToInt32~ | ~TryParse~ |
|-----+--------------+-------------------+------------|
| *Null Value*         | ~ArgumentNullException~                                            | Returns ~0~                   | Returns ~0~, ~isParsed = false~         |
| *Not in format*      | ~FormatException~                                                  | ~FormatException~             | Returns ~0~, ~isParsed = false~         |
| *Value not in RANGE* | ~OverflowException~                                                | ~OverflowException~           | Returns ~0~, ~isParsed = false~         |
| *When to use*        | If you've got a string, and you expect it to always be an integer. | Sending object as an argument | If you're collecting input from a user, |
|----------------------+--------------------------------------------------------------------+-------------------------------+-----------------------------------------|

*** Handling Exceptions
When errors have occurred when converting types we say a runtime exception has been thrown.

As you have seen, the default behavior of a console application is to write a message
about the exception including a stack trace in the output and then stop running the
application.

**** Wrapping error-prone Code in a Try Block

When you know that a statement can cause an error, you should wrap that statement
in a ~try~ block. For example, parsing from text to a number can cause an error. Any
statements in the catch block will be executed only if an exception is thrown by a
statement in the ~try~ block. We don't have to do anything inside the ~catch~ block:

#+begin_src csharp
WriteLine("Before parsing");
Write("What is your age? ");
string input = Console.ReadLine();
try {
int age = int.Parse(input);
WriteLine($"You are {age} years old.");
}
catch {
}
WriteLine("After parsing");
#+end_src

This code includes two messages to indicate before parsing and after parsing
to make clearer the flow through the code. These will be especially useful as
the example code grows more complex.

To get information about any type of exception that might occur, you can declare a
variable of type System.Exception to the catch block.

#+begin_src csharp
WriteLine("Before parsing");
Write("What is your age? ");
try {
int age = int.Parse("two");
WriteLine($"You are {age} years old.");}
catch(Exception ex) {
WriteLine($"{ex.GetType()} says {ex.Message}");
}
WriteLine("After parsing");
#+end_src

#+RESULTS:
 :  Before  parsing
 :  What  is  your  age?
 :  System.FormatException  says  Input  string  was  not  in  a  correct  format.
 :  After parsing

**** Catching Specific Exceptions
Now that we know which specific type of exception occurred, we can improve our
code by catching just that type of exception and customizing the message that we
display to the user.

#+begin_src csharp
WriteLine("Before parsing");
Write("What is your age? ");

try {

int age = int.Parse("two");
WriteLine($"You are {age} years old.");}

catch (FormatException) {
WriteLine("The age you entered is not a valid number format.");
}

catch(Exception ex) {
WriteLine($"{ex.GetType()} says {ex.Message}");

}
WriteLine("After parsing");
#+end_src

#+RESULTS:
: The  age  you  entered  is  not  a  valid  number  format.

The following table lists common exception types and the conditions under which you would
throw them:

| Exception                     | Condition                                                                                                   |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.argumentexception?view=net-6.0][ArgumentException]]             | A non-null argument that is passed to a method is invalid.                                                  |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.argumentnullexception?view=net-6.0][ArgumentNullException]]         | An argument that is passed to a method is null.                                                             |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.argumentoutofrangeexception?view=net-6.0][ArgumentOutOfRangeException]]   | An argument is outside the range of valid values.                                                           |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.io.directorynotfoundexception?view=net-6.0][DirectoryNotFoundException]]    | Part of a directory path is not valid.                                                                      |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.dividebyzeroexception?view=net-6.0][DivideByZeroException]]         | The denominator in an integer or Decimal division operation is zero.                                        |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.io.drivenotfoundexception?view=net-6.0][DriveNotFoundException]]        | A drive is unavailable or does not exist.                                                                   |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.io.filenotfoundexception?view=net-6.0][FileNotFoundException]]         | A file does not exist.                                                                                      |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.formatexception?view=net-6.0][FormatException]]               | A value is not in an appropriate format to be converted from a string by a conversion method such as Parse. |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.indexoutofrangeexception?view=net-6.0][IndexOutOfRangeException]]      | An index is outside the bounds of an array or collection.                                                   |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.invalidoperationexception?view=net-6.0][InvalidOperationException]]     | A method call is invalid in an object's current state.                                                      |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.keynotfoundexception?view=net-6.0][KeyNotFoundException]]          | The specified key for accessing a member in a collection cannot be found.                                   |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.notimplementedexception?view=net-6.0][NotImplementedException]]       | A method or operation is not implemented.                                                                   |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.notsupportedexception?view=net-6.0][NotSupportedException]]         | A method or operation is not supported.                                                                     |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.objectdisposedexception?view=net-6.0][ObjectDisposedException]]       | An operation is performed on an object that has been disposed.                                              |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.overflowexception?view=net-6.0][OverflowException]]             | An arithmetic, casting, or conversion operation results in an overflow.                                     |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.io.pathtoolongexception?view=net-6.0][PathTooLongException]]          | A path or file name exceeds the maximum system-defined length.                                              |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.platformnotsupportedexception?view=net-6.0][PlatformNotSupportedException]] | The operation is not supported on the current platform.                                                     |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.rankexception?view=net-6.0][RankException]]                 | An array with the wrong number of dimensions is passed to a method.                                         |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.timeoutexception?view=net-6.0][TimeoutException]]              | The time interval allotted to an operation has expired.                                                     |
| [[https://docs.microsoft.com/en-us/dotnet/api/system.uriformatexception?view=net-6.0][UriFormatException]]            | An invalid Uniform Resource Identifier (URI) is used.                                                       |
|-------------------------------+-------------------------------------------------------------------------------------------------------------|

**** Checking for Overflow
The checked statement tells .NET to throw an exception when an overflow happens
instead of allowing it to happen silently.

We will set the initial value of an int variable to its maximum value minus one.
Then, we will increment it several times, outputting its value each time. Once it
gets above its maximum value, it overflows to its minimum value and continues
incrementing from there:
#+begin_src csharp
int x = int.MaxValue - 1;
WriteLine($"Initial value: {x}");
x++;
WriteLine($"After incrementing: {x}");
x++;
WriteLine($"After incrementing: {x}");
x++;
WriteLine($"After incrementing: {x}");
#+end_src

#+RESULTS:
: Initial  value:         2147483646
: After    incrementing:  2147483647
: After    incrementing: -2147483648
: After    incrementing: -2147483647

Now, let's get the compiler to warn us about the overflow by wrapping the
statements using ~checked~
** Array Syntax
| Syntax                                                          | Declaration                                                      |
|-----------------------------------------------------------------+------------------------------------------------------------------|
| ~int[] array1 = new int[5];~                                    | Declare a single-dimensional array of 5 integers.                |
| ~int[] array2 = new int[] { 1, 3, 5, 7, 9 };~                   | Declare and set array element values.                            |
| ~int[,] multiDimensionalArray1 = new int[2, 3];~                | Declare a two dimensional array.                                 |
| ~int[,] multiDimensionalArray2 = { { 1, 2, 3 }, { 4, 5, 6 } };~ | Declare and set array element values.                            |
| ~int[][] jaggedArray = new int[6][];~                           | Declare a jagged array                                           |
| ~jaggedArray[0] = new int[4] { 1, 2, 3, 4 };~                   | Set the values of the first array in the jagged array structure. |
|-----------------------------------------------------------------+------------------------------------------------------------------|
** Lambada
*Check [[#delegates][delegates]] & [[#events][events]]*
In C#, lambdas use special syntax. We pass lambda expressions to other methods to specify a behavior that the method uses.

Remember that lambdas are just methods. They can always be replaced with class-level methods. We can use types like Action and Func to represent them.

A common place to use lambdas is with List. Here we use FindIndex, which receives a Predicate method. We specify this as a lambda expression.

#+begin_src csharp
List<int> elements = new List<int>() { 10, 20, 31, 40 };
int oddIndex = elements.FindIndex(x => x % 2 != 0);
Console.WriteLine(elements[oddIndex]);
#+end_src

#+RESULTS:
: 31

* Building O.O.P
An object in the real world is a thing, such as a car or a person, whereas an object in
programming often represents something in the real world, such as a product or bank account,
but this can also be something more abstract.

In C#, we use the ~class~ (mostly) or ~struct~ (sometimes) C# keywords to define a type of
object.


The following tables should give you a review for the concepts of object-oriented
programming, in brief:

| Concept       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|---------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Encapsulation | is the combination of the data and actions that are related to an object. For example, a ~BankAccount~ type might have data, such as ~Balance~ and ~AccountName~, as well as actions, such as ~Deposit~ and Withdraw. When encapsulating, you often want to control what can access those actions and the data, for example, restricting how the internal state of an object can be accessed or modified from the outside.                                                                                                                                                                      |
| Composition   | Composition is about what an object is made of. For example, a car is composed of different parts, such as four wheels, several seats, and an engine.                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Aggregation   | Aggregation is about what can be combined with an object. For example, a person is not part of a car object, but they could sit in the driver's seat and then becomes the car's driver. Two separate objects that are aggregated together to form a new component.                                                                                                                                                                                                                                                                                                                              |
| Inheritance   | Inheritance is about reusing code by having a subclass derive from a base or super class. All functionality in the base class is inherited by and becomes available in the derived class. For example, the base or super Exception class has some members that have the same implementation across all exceptions, and the sub or derived SqlException class inherits those members and has extra members only relevant to when an SQL database exception occurs like a property for the database connection.                                                                                   |
| Abstraction   | Abstraction is about capturing the core idea of an object and ignoring the details or specifics. C# has an ~abstract~ keyword which formalizes the concept. If a class is not explicitly abstract then it can be described as being concrete. *Base or super classes are often abstract*, for example, the super class Stream is abstract and its sub classes like FileStream and MemoryStream are concrete. Abstraction is a tricky balance. If you make a class more abstract, more classes would be able to inherit from it, but at the same time there will be less functionality to share. |
| Polymorphism  | Polymorphism is about allowing a derived class to override an inherited action to provide custom behavior.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|---------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
** Referencing an Assembly
Before we can instantiate a class, we need to reference the assembly that contains it,
create a new project in a sub-directory in the directory of the class library, let it be
~People~, by running: ~dotnet new console~. Now, navigate to ~People.csproj~ and add the
following markup to add a project reference to ~PacketLibrary~:
#+begin_src html
<ItemGroup>
<ProjectReference Include="../PacktLibrary/PacktLibrary.csproj" />
</ItemGroup>
#+end_src
*Note: ~..~ in this case is a /container directory/. ~../..~ means "up" twice*

For example, if your current directory is ~C:/projects/a/b/c~ then ~../..~ will be ~C:/projects/a~

Now you are ready to run ~dotnet build~
** Access Modifiers
In classes we define fields starting with its access modifier, for example:
#+begin_src csharp
public class Person {
    public string? name;
    public DateTime DateOfBirth;
}
#+end_src
An important part of the concept of encapsulating is considering the accessibility of data
members carefully.

Note that, like we did with the class, we explicitly applied the public keyword to
these fields. If we hadn't, then they would be implicitly private to the class, which
means they are accessible only inside the class.

There are four access modifier keywords, and two combinations of access modifier
keywords that you can apply to a class member, such as a field or method, as shown
in the following table:

| Access Modifier      | Description                                                                                                    |
|----------------------+----------------------------------------------------------------------------------------------------------------|
| ~private~            | Member is accessible inside the type only. This is the default                                                 |
| ~internal~           | Member is accessible inside the type and any type in the *same assembly*                                       |
| ~protected~          | Member is accessible inside the type and any type that inherits from the type                                  |
| ~internal protected~ | Member is accessible inside the type, any type in the same assembly, and any type that inherits from the type. |
| ~private protected~  | Member is accessible inside the type, or any type that inherits from the type and is in the same assembly.     |

** Static Field
The fields that we have created so far have all been instance members, meaning that a
different value of each field exists for each instance of the class that is created. The bob
variable has a different Name value to alice. Sometimes, you want to define a field that
only has one value that is shared across all instances. These are called static members.

** Constant, Read-only, and Event
Consider the difference between access modifier and other categories is field, the following
are *not* access modifiers: ~constant~, ~readonly~, ~event~, however you might confuse
read-only with constant:

+ *Constant*: The data never changes. The compiler literally copies the data into any code that reads it.

+ *Read-only* cannot change after the class is instantiated, but the data can be calculated or loaded from an external source at the time of instantiation.

+ *Event*: The data references one or more methods that you want to execute when something happens, such as clicking on a button, or responding to a request from other code

** Tuples to Return More Than One Value
Imagine that we want to define a method named GetTheData that returns
both a string value and an int value. We could define a new class named
~TextAndNumber~ with a string field and an int field, and return an instance of that
complex type.

But defining a class just to combine two values together is unnecessary, because in
modern versions of C# we can use tuples. I pronounce them as tuh-ples but I have
heard other developers pronounce them as too-ples.

Tuples have been a part of some languages such as F# since their first version, but
.NET only added support for them in .NET 4.0 with the System.Tuple type.
It was only in C# 7.0 that C# added language syntax support for tuples and at the
same time, .NET added a new System.ValueTuple type that is more efficient in
some common scenarios than the old .NET 4.0 System.Tuple type, and the C# tuple
uses the more efficient one.

System.ValueTuple is not part of .NET Standard 1.6, and therefore not available by
default in .NET Core 1.0 or 1.1 projects. System.ValueTuple is built in with .NET
Standard 2.0, and therefore, .NET Core 2.0 and later. An example of returning tuples is


#+begin_src csharp
public (string, int) GetNameAndNumber() {
return ("Ahmed", 13);
}
#+end_src

To access the fields of a tuple, the default names are Item1, Item2, and so on. You can
explicitly specify the field names.

#+begin_src csharp
public (string Name, int Number) GetNamedFruit() {
return (Name: "Apples", Number: 5);
}
#+end_src

*Tip*: You can easily swap elements using tuples, like:
#+begin_src csharp
int a = 10;
int b = 2;
(a, b) = (b, a);
#+end_src

** Virtual, Override
The virtual keyword is used to modify a method, property, indexer, or event declaration and
allow for it to be overridden in a derived class. For example, this method can be overridden
by any class that inherits it:

#+begin_src csharp
public virtual double Area()
{
    return x * y;
}
#+end_src

When a virtual method is invoked, the run-time type of the object is checked for an
overriding member. The overriding member in the most derived class is called, which might be
the original member, if no derived class has overridden the member.

By default, methods are non-virtual. You cannot override a non-virtual method.

#+begin_src csharp
class MyBaseClass
{
    public virtual string Name { get; set; }
    private int _num;
    public virtual int Number
    {
        get { return _num; }
        set { _num = value; }
    }
}

class MyDerivedClass : MyBaseClass
{
    private string _name;
    public override string Name
    {
        get
        {
            return _name;
        }
        set
        {
            if (!string.IsNullOrEmpty(value))
            {
                _name = value;
            }
            else
            {
                _name = "Unknown";
            }
        }
    }
}
#+end_src

** ~Params~
In some cases we need to pass more than one argument to a method, a very obsolete example is
that we have a method ~sum~ which take an ~n~ numbers and returns their sum, a proper method
to implement this function without instantiating it more than 100 times, is using a ~List~
or an ~Array~ and pass it to ~sum~, another (and faster) approach is to use the keyword
~params~:

#+begin_src csharp
static int sum(int s = 0, params int[] p) {
    foreach (int i in p)
    {
        s += i;
    }
    return s;
}
#+end_src

*Note*: A params parameter must be the last parameter in a formal parameter list, you can't
do this:
#+begin_src csharp
static int sum(params int[] p, int s = 0) {
    return s;
}
#+end_src
** Abstract
If a class is defined as abstract then we can't create an instance of that class. By the
creation of the derived class object where an abstract class is inherit from, we can call
the method of the abstract class.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace ConsoleApplication13 {
    abstract class mcn {
        public int add(int a, int b) {
            return (a + b);
        }
    }
    class mcn1: mcn {
        public int mul(int a, int b) {
            return a * b;
        }
    }
    class test {
        static void Main(string[] args) {
            mcn1 ob = new mcn1();
            int result = ob.add(5, 10);
            Console.WriteLine("the result is {0}", result);
        }
    }
}

#+end_src

In the above program we can call the method of the abstract class mcn with the help of an
object of the mcn1 class which inherits from the class mcn. When we run the above program
the output is the addition of 5 & 10 (i.e. 15) which is shown as,

An Abstract method is a method without a body. The implementation of an abstract method is
done by a derived class. When the derived class inherits the abstract method from the
abstract class, it must override the abstract method. This requirment is enforced at compile
time and is also called dynamic polymorphism.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace ConsoleApplication14 {
    abstract class test1 {
        public int add(int i, int j) {
            return i + j;
        }
        public abstract int mul(int i, int j);
    }
    class test2: test1 {
        public override int mul(int i, int j) {
            return i * j;
        }
    }
    class test3: test1 {
        public override int mul(int i, int j) {
            return i - j;
        }
    }
    class test4: test2 {
        public override int mul(int i, int j) {
            return i + j;
        }
    }
    class myclass {
        public static void main(string[] args) {
            test2 ob = new test4();
            int a = ob.mul(2, 4);
            test1 ob1 = new test2();
            int b = ob1.mul(4, 2);
            test1 ob2 = new test3();
            int c = ob2.mul(4, 2);
            Console.Write("{0},{1},{2}", a, b, c);
            Console.ReadLine();
        }
    }
}
#+end_src

** Generic
Generics introduces the concept of type parameters to .NET, which make it possible to design
classes and methods that defer the specification of one or more types until the class or
method is declared and instantiated by client code. For example, by using a generic type
parameter ~T~, you can write a single class that other client code can use without incurring
the cost or risk of runtime casts or boxing operations, as shown here:

#+begin_src csharp
public class GenericList<T>
{
    public void Add(T input) { }
}
class TestGenericList
{
    private class ExampleClass { }
    static void Main()
    {
        GenericList<int> list1 = new GenericList<int>();
        list1.Add(1);

        GenericList<string> list2 = new GenericList<string>();
        list2.Add("");

        GenericList<ExampleClass> list3 = new GenericList<ExampleClass>();
        list3.Add(new ExampleClass());
    }
}
#+end_src
** Extension
The extension method concept allows you to add new methods in the existing class or in the
structure without modifying the source code of the original type and you do not require any
kind of special permission from the original type and there is no need to re-compile the
original type. It is introduced in C# 3.0.

#+begin_src csharp
static void Main() {
    int id = 12;
    x.PrintHelloWorld(id);
}


static void PrintHelloWorld(this string g, int id) {
    Console.WriteLine($"Hello World with the ID of {id}");
}
#+end_src

*Note*: You must write ~this~ parameter as the first argument in your method.
** Yield
:PROPERTIES:
:CUSTOM_ID: yield
:END:
You use a yield return statement to return each element one at a time.

The sequence returned from an iterator method can be consumed by using a foreach statement
or LINQ query. Each iteration of the foreach loop calls the iterator method. When a yield
return statement is reached in the iterator method, expression is returned, and the current
location in code is retained. Execution is restarted from that location the next time that
the iterator function is called.

When the iterator returns an System.Collections.Generic.IAsyncEnumerable<T>, that sequence
can be consumed asynchronously using an await foreach statement. The iteration of the loop
is analogous to the foreach statement. The difference is that each iteration may be
suspended for an asynchronous operation before returning the expression for the next
element.

#+begin_src csharp
public class PowersOf2
{
    static void Main()
    {
        // Display powers of 2 up to the exponent of 8:
        foreach (int i in Power(2, 8))
        {
            Console.Write("{0} ", i);
        }
    }

    public static System.Collections.Generic.IEnumerable<int> Power(int number, int exponent)
    {
        int result = 1;

        for (int i = 0; i < exponent; i++)
        {
            result = result * number;
            yield return result;
        }
    }

}
#+end_src

** Implementing Interfaces
Interfaces are a way of connecting different types together to make new things.  Think of
them like the studs on top of LEGO™ bricks, which allow them to "stick"

together, or electrical standards for plugs and sockets.  If a type implements an interface,
then it is making a promise to the rest of .NET that it supports a certain feature.

Here are some common interfaces that your types might need to implement:
| Interface           | Method(s)                       | Description                                                                                                     |
|---------------------+---------------------------------+-----------------------------------------------------------------------------------------------------------------|
| ~IComparer~         | ~Compare(first, second)~        | This defines a comparison method that a secondary type implements to order or sort instances of a primary type. |
| ~IComparable~       | ~CompareTo(other)~              | This defines a comparison method that a type implements to order or sort its instances.                         |
| ~IEnumerator~       | ~MoveNext()~, ~Reset()~         | Makes your class iteratable on the ~foreach~ iteration statement                                                |
| ~ICloneable~        | ~Clone()~                       | Supports cloning, which creates a new instance of a class with the same value as an existing instance.          |
| ~IEqualityComparer~ | ~Equals(T,T)~, ~GetHashCode(T)~ |                                                                                                                 |
| ~IDisposable~       | ~Dispose~                       | This defines a disposal method to release unmanaged resources more efficiently than waiting for a finalizer     |
|---------------------+---------------------------------+-----------------------------------------------------------------------------------------------------------------|
*** ~IComparer~
*Note*: When using any compare function that return an ~int~, you should consider the
following cases:
 + First, if you calling it using an object, i.e. ~x.CompareTo("Khaled")~, consider ~x as an ~string~.
   | Returns | Case                                                                                                                                                         |
   |---------+--------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | *1*     | The object which in the parameter should come *first* in the sorting, or you may say it's smaller than the calling objact.                                   |
   | *0*     | They are completely equal to each others                                                                                                                     |
   | *-1*    | The calling object should come *first* in the sorting, or it's smaller than the object between the parenthesis (so the object between parenthesis is bigger) |
   |---------+--------------------------------------------------------------------------------------------------------------------------------------------------------------|
 + Second, if you are using ~Compare(first, second)~ function
   | Returns | Case                              |
   |---------+-----------------------------------|
   | *1*     | ~second~ object should come first |
   | *0*     | They are equal                    |
   | *-1*    | ~first~ objcet should come first  |
   |---------+-----------------------------------|
    Consider the following example to compare the ~Person~ class object using ~IComparer~
   interface in another class:
    #+begin_src csharp
    public class PersonCompare : IComparer<Person>
    {
        public int Compare(Person x, Person y)
        {
            if (x.id > y.id)
            { // if Person X's id is bigger, then y should comes first, so return 1
                return 1;
            }
            else if (x.id < y.id)
            { // If person Y's id is bigger, then y should come after x, so returns - 1
                return -1;
            }
            return 0; // in this case, they are equal, no need to change any arrangement
        }
    }
    #+end_src
*** ~IComparable~
*** ~IEnumerator~
IEnumerator is the base interface for all non-generic enumerators. Its generic equivalent is
the System.Collections.Generic.IEnumerator<T> interface.

The foreach statement of the C# language (for each in Visual Basic) hides the complexity of
the enumerators. Therefore, using foreach is recommended instead of directly manipulating
the enumerator.

When you use foreach with an enumerable class like this:

#+begin_src csharp
var array = new int [] {1,2,3,4,5};
foreach (var a in array) {
   Console.WriteLine(a);
 }
#+end_src

#+RESULTS:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |

In IL, this is converted to some code like this:
#+begin_src csharp
var array = new int [] {1,2,3,4,5};
var enumer = array.GetEnumerator();
while(enumer.MoveNext()) {
    Console.WriteLine(enumer.Current);
}
#+end_src

#+RESULTS:
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |

To use the ~foreach~ syntactic your object/class has to implement the ~IEnumerable~
interface.

#+begin_src csharp
using System;
using System.Collections;
public class Person
{
    public Person(string fName, string lName)
    {
        this.firstName = fName;
        this.lastName = lName;
    }

    public string firstName;
    public string lastName;
}

// Collection of Person objects. This class
// implements IEnumerable so that it can be used
// with ForEach syntax.
public class People : IEnumerable
{
    private Person[] _people;
    public People(Person[] pArray)
    {
        _people = new Person[pArray.Length];

        for (int i = 0; i < pArray.Length; i++)
        {
            _people[i] = pArray[i];
        }
    }

    // Implementation for the GetEnumerator method.
    IEnumerator IEnumerable.GetEnumerator()
    {
        return (IEnumerator)GetEnumerator();
    }

    public PeopleEnum GetEnumerator()
    {
        return new PeopleEnum(_people);
    }
}

// When you implement IEnumerable, you must also implement IEnumerator.
public class PeopleEnum : IEnumerator
{
    public Person[] _people;

    // Enumerators are positioned before the first element
    // until the first MoveNext() call.
    int position = -1;

    public PeopleEnum(Person[] list)
    {
        _people = list;
    }

    public bool MoveNext()
    {
        position++;
        return (position < _people.Length);
    }

    public void Reset()
    {
        position = -1;
    }

    object IEnumerator.Current
    {
        get
        {
            return Current;
        }
    }

    public Person Current
    {
        get
        {
            try
            {
                return _people[position];
            }
            catch (IndexOutOfRangeException)
            {
                throw new InvalidOperationException();
            }
        }
    }
}

class App
{
    static void Main()
    {
        Person[] peopleArray = new Person[3]
        {
            new Person("John", "Smith"),
            new Person("Jim", "Johnson"),
            new Person("Sue", "Rabon"),
        };
        People peopleList = new People(peopleArray);
        foreach (Person p in peopleList)
            Console.WriteLine(p.firstName + " " + p.lastName);
    }
}
#+end_src

However, since C# 4, the ~PeopleEnum~ can be easily replaced with the ~yield~ keyword (Check
[[#yield][yield]]):
#+begin_src csharp
using System;
using System.Collections;
public class Person
{
    public Person(string fName, string lName)
    {
        this.firstName = fName;
        this.lastName = lName;
    }

    public string firstName;
    public string lastName;
}
public class People : IEnumerable
{
    private Person[] _people;
    public People(Person[] pArray)
    {
        _people = new Person[pArray.Length];

        for (int i = 0; i < pArray.Length; i++)
        {
            _people[i] = pArray[i];
        }
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        foreach (var one in _people)
        {
            yield return one;
        }
    }
}

class App
{
    static void Main()
    {
        Person[] peopleArray = new Person[3]
        {
            new Person("John", "Smith"),
            new Person("Jim", "Johnson"),
            new Person("Sue", "Rabon"),
        };
        People peopleList = new People(peopleArray);
        foreach (Person p in peopleList)
            Console.WriteLine(p.firstName + " " + p.lastName);
    }
}
#+end_src

*** ~ICloneable~ /You don't want to implement this!/ and Copying Methods
:PROPERTIES:
:CUSTOM_ID: ICloneable
:END:
#+begin_quote
Microsoft recommends against implementing ICloneable because there's no clear indication
from the interface whether your Clone method performs a "deep" or "shallow" clone.
#+end_quote

The ICloneable interface contains one member, Clone, which is intended to support cloning
beyond that supplied by MemberwiseClone. It is a procedure that can create a true, distinct
copy of an object and all its dependent object, is to rely on the serialization features of
the .NET framework.

There are two ways to clone an instance:

- Shallow copy - may be linked to data shared by both the original and the copy
- Deep copy - contains the complete encapsulated data of the original object
  Example:
  #+begin_src csharp
using System;

class Car : ICloneable {
   int width;

   public Car(int width) {
      this.width = width;
   }

   public object Clone() {
      return new Car(this.width);
   }

   public override string ToString() {
      return string.Format("Width of car = {0}",this.width);
   }
}

class Program {
   static void Main() {
      Car carOne = new Car(1695);
      Car carTwo = carOne.Clone() as Car;
      Console.WriteLine("{0}mm", carOne);
      Console.WriteLine("{0}mm", carTwo);
   }
}
  #+end_src

**** Copying

When we copy one instance to another using C# what happen is that both instances share the
same memory address. But this is not the behavior we want most of the time.

When we create a copy of an object, for example:

#+begin_src csharp
MyClass obj=new MyClass()
MyClass obj2=obj;
#+end_src

Then the '=' operator copies the reference and not the object (and it works fine for a Value
Type).

By default we get this behavior using the MemberwiseClone() method that is defined in the
super class called System.Object. This is called “Shallow Copy” (The assignment operator
doesn't implement a shallow operator, rather it's another kind of copying, which is not a
real 'copying').

To get the same behavior for a Reference Type as well as a Value Type we use the Clone()
method that belongs to the System.ICloneable interface. This is called a “Deep Copy”.


#+begin_src csharp
class ShallowCopy
{
    public int I {get;set;}
    public int J {get;set;}
}

class Demo
{
    public static void Main()
    {
        ShallowCopy obj=new ShallowCopy();
        ShallowCopy objClone=obj;
        obj.I=10;// setting obj value after cloning..
        Console.WriteLine(“objvalue : {0} \t Clone value : {1}”,obj.I,objClone.I=10);
    }
}
#+end_src


Deep Copy is used to make a complete deep copy of the internal reference types, for this we
need to configure the object returned by MemberwiseClone().

#+begin_src csharp
class ReferenceType
{
    public int RFT {  get;  set; }
}
class ShallowCopy :  ICloneable
{
    public int I {  get;  set; }
    public int J {  get;  set; }
    public ReferenceType K =  new ReferenceType();
    //Method updated for reference type ..
    public object Clone()
    {
        // Shalllow Copy..
        ShallowCopy SC = (ShallowCopy)this.MemberwiseClone();
        // Deep copy...
        ReferenceType RT =  new ReferenceType();
        RT.RFT =  this.K.RFT;
        SC.K = RT;
        return SC;
    }
    public static void Main(String[] args)
    {
        ShallowCopy obj =  new ShallowCopy();
        obj.K.RFT = 100;
        ShallowCopy objclone = (ShallowCopy)obj.Clone();
        obj.K.RFT = 200;  // make changes in obj.
        Console.WriteLine(objclone.K.RFT);
    }
}
#+end_src

*** ~IEqualityComparer~
:PROPERTIES:
:CUSTOM_ID: IEquality
:END:
#+begin_src csharp
using System;
using System.Collections.Generic;

class Example
{
   static void Main()
   {
      BoxEqualityComparer boxEqC = new BoxEqualityComparer();

      var boxes = new Dictionary<Box, string>(boxEqC);

      var redBox = new Box(4, 3, 4);
      AddBox(boxes, redBox, "red");

      var blueBox = new Box(4, 3, 4);
      AddBox(boxes, blueBox, "blue");

      var greenBox = new Box(3, 4, 3);
      AddBox(boxes, greenBox, "green");
      Console.WriteLine();

      Console.WriteLine("The dictionary contains {0} Box objects.",
                        boxes.Count);
   }

   private static void AddBox(Dictionary<Box, String> dict, Box box, String name)
   {
      try {
         dict.Add(box, name);
      }
      catch (ArgumentException e) {
         Console.WriteLine("Unable to add {0}: {1}", box, e.Message);
      }
   }
}

public class Box
{
    public Box(int h,  int l, int w)
    {
        this.Height = h;
        this.Length = l;
        this.Width = w;
    }

    public int Height { get; set; }
    public int Length { get; set; }
    public int Width { get; set; }

    public override String ToString()
    {
       return String.Format("({0}, {1}, {2})", Height, Length, Width);
    }
}

class BoxEqualityComparer : IEqualityComparer<Box>
{
    public bool Equals(Box b1, Box b2)
    {
        if (b2 == null && b1 == null)
           return true;
        else if (b1 == null || b2 == null)
           return false;
        else if(b1.Height == b2.Height && b1.Length == b2.Length
                            && b1.Width == b2.Width)
            return true;
        else
            return false;
    }

    public int GetHashCode(Box bx)
    {
        int hCode = bx.Height ^ bx.Length ^ bx.Width;
        return hCode.GetHashCode();
    }
}
#+end_src

** Interfaces: A point
First and foremost, interfaces in C# are a means to get around the lack of multiple
inheritances in C#, meaning you cannot inherit from multiple classes but you can implement
multiple interfaces. OOP tries to resemble how objects are defined in real life, and
interfaces are a very logical way of grouping objects in terms of behavior.

An interface is a contract between itself and any class that implements it. This contract
states that any class that implements the interface will implement the interface's
properties, methods and/or events. An interface contains no implementation, only the
signatures of the functionality the interface provides. An interface can contain signatures
of methods, properties, indexers, and events.

You can think of an interface as an abstract class with the implementation stripped out. An
interface doesn't actually do anything, like a class or abstract class, it merely defines
what a class that implements it will do. An interface can also inherit/implement other
interfaces.

So if an interface implements no functionality then why should we use them? Using
interface-based design concepts provides loose coupling, component-based programming, easier
maintainability, makes your code base more scalable and makes code reuse much more
accessible because the implementation is separated from the interface. Interfaces add a plug
and play like architecture into your applications. Interfaces help define a contract
(agreement or blueprint, however you chose to define it), between your application and other
objects. This indicates what sort of methods, properties, and events are exposed by an
object.

For example, let's take a vehicle. All vehicles have similar items but are different enough
that we could design an interface that holds all the common items of a vehicle. Some
vehicles have two wheels, some have four wheels, and some even have one wheel. Though these
are differences, they all have things in common: they're all movable, they all have some
sort of engine, they all have doors, but each of these items may vary. So we can create an
interface of a vehicle that has these properties, then we inherit from that interface to
implement it.

While wheels, doors, and engines are different they all rely on the same interface (I sure
hope this is making sense). Interfaces allow us to create nice layouts for what a class is
going to implement. Because of the guarantee that the interface gives us, when many
components use the same interface it allows us to easily interchange one component for
another which is using the same interface. Dynamic programs begin to form easily from this.
An interface is a contract that defines the signature of some piece of functionality.

So here's a simple example of an interface and how to implement it. From the above example,
we're created an IVehicle interface that looks like this

#+begin_src csharp
namespace InterfaceExample {
 public interface IVehicle {
  int Doors {
   get;
   set;
  }
  int Wheels {
   get;
   set;
  }
  Color VehicleColor {
   get;
   set;
  }
  int TopSpeed {
   get;
   set;
  }
  int Cylinders {
   get;
   set;
  }
  int CurrentSpeed {
   get;
  }
  string DisplayTopSpeed();
  void Accelerate(int step);
 }
}
#+end_src

Now we have our vehicle blueprint, and all classes that implement it must implement the
items in our interface, whether it be a motorcycle, car, or truck class we know that all of
them will contain the same functionality. Now for a sample implementation, in this example,
we'll create a Motorcycle class that implements our IVehicle class. This class will contain
everything we have defined in our interface.

#+begin_src csharp
namespace InterfaceExample {
 public class Motorcycle: IVehicle {
  private int _currentSpeed = 0;
  public int Doors {
   get;
   set;
  }
  public int Wheels {
   get;
   set;
  }
  public Color VehicleColor {
   get;
   set;
  }
  public int TopSpeed {
   get;
   set;
  }
  public int HorsePower {
   get;
   set;
  }
  public int Cylinders {
   get;
   set;
  }
  public int CurrentSpeed {
   get {
    return _currentSpeed;
   }
  }
  public Motorcycle(int doors, int wheels, Color color, int topSpeed, int horsePower, int cylinders, int currentSpeed) {
   this.Doors = doors;
   this.Wheels = wheels;
   this.VehicleColor = color;
   this.TopSpeed = topSpeed;
   this.HorsePower = horsePower;
   this.Cylinders = cylinders;
   this._currentSpeed = currentSpeed;
  }
  public string DisplayTopSpeed() {
   return "Top speed is: " + this.TopSpeed;
  }
  public void Accelerate(int step) {
   this._currentSpeed += step;
  }
 }
#+end_src

** Delegates
:PROPERTIES:
:CUSTOM_ID: delegates
:END:
Delegate is just about passing a function as a paramter, consider the following C++ code:
#+begin_src cpp
bool Myfunction() {
    return true;
}

bool FunctionThatRecievesAFunction(bool Checking_The_Situation()) {
    return Checking_The_Situation();
}
#+end_src
Elegant, but we can't perform such a thing using C#, why? This is not so important but let's
say that all languages that run on top of the CLR (Common Language Runtime), such as C#, F#,
and Visual Basic, work under a VM that runs higher level code than machine code. It follows
that methods aren't Assembly subroutines, nor are they values, unlike JavaScript and most
functional languages; rather, they're symbols that CLR recognizes. Thus, you cannot think to
pass a method as a parameter, because methods don't produce any values themselves, as
they're not expressions but statements, which are stored in the generated assemblies. At
this point, you'll face delegates.

To use delegate in your function, tell your function "You are going to receive a delegate of
type X", to do so we should first tell what is ~X~ type, to do so define your first
delegate:
#+begin_src csharp
public delegate bool MyFunctionType();
#+end_src
Here we are stating that we are defining a function type of boolean that doesn't take
any parameters, now let's use it in another function. *Notice* that delegate does not
contain any implementation! It is just a type declaration.
#+begin_src csharp
public bool FunctionThatRecievesAFunction(MyFunctionType MyFunction) {
    return MyFunction();
}
#+end_src

The full simulation of C++'s ~Myfunction~ in Csharp:
#+begin_src csharp
public delegate bool MyFunctionType();
public static bool FunctionRec(MyFunctionType e)
{
    return e();
}
public static bool Functionf() { return true; }
public static void Main(string[] args)
{
    Console.WriteLine(FunctionRec(Functionf));
}
#+end_src

*** Anonymous Delegate
Instead of using a function to pass within delegate, you can implement the delegate function
in line using anonymous function.
#+begin_src csharp
public static void Main(string[] args)
{
    Console.WriteLine(FunctionRec(delegate (/* Your Arguments here */) { return true; }));
}
#+end_src


**** Lambda Expression
You can use the Lambda as well:
#+begin_src csharp
Console.WriteLine(FunctionRec(() => true ));
#+end_src

** Events
:PROPERTIES:
:CUSTOM_ID: events
:END:
Methods are often described as actions that an object can perform, either on itself or to
related objects. For example, List can add an item to itself or clear itself, and File can
create or delete a file in the filesystem.

Events are often described as actions that happen to an object. For example, in a
user interface, Button has a Click event, click being something that happens to a
button. Another way of thinking of events is that they provide a way of exchanging
messages between two objects.

Events are built on delegates, so let's start by having a look at how delegates work.

#+begin_src csharp
namespace delegates
{
   public delegate void IPChanged((string, string) l) ;
}



using delegates;
namespace net
{
    public class ip
    {
        public string address;
        public event IPChanged? OnChange;
        public ip() => address = "";
        public ip(params int[] s) => address = String.Join(".", s);

        public (string, string) ChengeIP(params int[] NewIP)
        {
            string temp = address;
            address = String.Join(".", NewIP);
            var change = (temp, address);
            if(OnChange != null) OnChange(change);
            return change;
        }
    }
 }
using net;
namespace MainClass
{
    internal class Program
    {
        public static void Main()
        {
            var ThisUser = new ip(11, 2, 3, 41, 55);
            int i = 10;
            ThisUser.OnChange += AlertChange;
            // ThisUser.OnChange += HereAnotherFunction;
            ThisUser.ChengeIP(11, 22, 44, 15, 16);
            Console.WriteLine("All is done!");
            int b = i;
        }
        static void AlertChange((string, string) Changes)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine("IMPORTANT!!");
            Console.WriteLine("IP IS CHANGED");
            Console.WriteLine("------------------");
            Console.WriteLine($"OLD IP : {Changes.Item1}");
            Console.WriteLine($"NEW IP : {Changes.Item2}");
            Console.ForegroundColor = ConsoleColor.White;
        }
        public static void HereAnotherFunction()
        {
            Console.WriteLine("Events are nice!");
        }
        struct ko
        {
            public int i;
            private int k;
        };
    }
}
#+end_src
** Attributes
Reflection is a programming feature that allows code to understand and manipulate
itself. An assembly is made up of up to four parts:

+ Assembly metadata and manifest: Name, assembly, and file version, referenced assemblies, and so on.
+ Type metadata: Information about the types, their members, and so on.
+ IL code: Implementation of methods, properties, constructors, and so on.
+ Embedded Resources (optional): Images, strings, JavaScript, and so on.

  The metadata comprises items of information about your code. The metadata is applied to
  your code using attributes.

Attributes can be applied at multiple levels: to assemblies, to types, and to their
members, as shown in the following code:

#+begin_src csharp
[assembly: AssemblyTitle("Working with Reflection")]
// a type-level attribute
[Serializable]
public class Person
// a member-level attribute
[Obsolete("Deprecated: use Run instead.")]
public void Walk()
{
// ...
}
#+end_src


Version numbers in .NET are a combination of three numbers, with two optional additions. If
you follow the rules of semantic versioning:

+ Major: Breaking changes.
+ Minor: Non-breaking changes, including new features and bug fixes.
+ Patch: Non-breaking bug fixes.

When updating a NuGet package, you should specify an optional flag to make sure that you
only upgrade to the highest minor to avoid breaking changes, or to the highest patch if you
are extra cautious and only want to receive bug fixes, as shown in the following commands:
#+begin_src bash
Update-Package Newtonsoft.Json -ToHighestMinor
Update-Package EPiServer.Cms -ToHighestPatch
#+end_src

The .Net Framework provides three pre-defined attributes −

+ AttributeUsage
+ Conditional
+ Obsolete

The pre-defined attribute AttributeUsage describes how a custom attribute class can be used.
It specifies the types of items to which the attribute can be applied.

Syntax for specifying this attribute is as follows −

#+begin_src csharp
[AttributeUsage (
   validon,
   AllowMultiple = allowmultiple,
   Inherited = inherited
)]
#+end_src

Where,

+ The parameter validon specifies the language elements on which the attribute can be placed. It is a combination of the value of an enumerator AttributeTargets. The default value is AttributeTargets.All.

+ The parameter allowmultiple (optional) provides value for the AllowMultiple property of this attribute, a Boolean value. If this is true, the attribute is multiuse. The default is false (single-use).

+ The parameter inherited (optional) provides value for the Inherited property of this attribute, a Boolean value. If it is true, the attribute is inherited by derived classes. The default value is false (not inherited).

For example:
#+begin_src csharp
[AttributeUsage(
   AttributeTargets.Class |
   AttributeTargets.Constructor |
   AttributeTargets.Field |
   AttributeTargets.Method |
   AttributeTargets.Property,
   AllowMultiple = true)]
#+end_src

*** Conditional Attribute
This predefined attribute marks a conditional method whose execution depends on a specified
preprocessing identifier.

It causes conditional compilation of method calls, depending on the specified value such as
Debug or Trace. For example, it displays the values of the variables while debugging a code.

For example:
#+begin_src csharp
[Conditional("DEBUG")]
#+end_src

#+begin_src csharp
#define DEBUG
using System;
using System.Diagnostics;

public class Myclass {
   [Conditional("DEBUG")]

   public static void Message(string msg) {
      Console.WriteLine(msg);
   }
}
class Test {
   static void function1() {
      Myclass.Message("In Function 1.");
      function2();
   }
   static void function2() {
      Myclass.Message("In Function 2.");
   }
   public static void Main() {
      Myclass.Message("In Main function.");
      function1();
      Console.ReadKey();
   }
}
#+end_src


*** Obselete Attribute

This predefined attribute marks a program entity that should not be used. It enables you to
inform the compiler to discard a particular target element. For example, when a new method
is being used in a class and if you still want to retain the old method in the class, you
may mark it as obsolete by displaying a message the new method should be used, instead of
the old method.

Syntax for specifying this attribute is as follows:

#+begin_src csharp
Obsolete (
   message
)]

[Obsolete (
   message,
   iserror
)]

#+end_src

Where,

The parameter message, is a string describing the reason why the item is obsolete and what
to use instead.

The parameter iserror, is a Boolean value. If its value is true, the compiler should treat
the use of the item as an error. Default value is false (compiler generates a warning).



The following program demonstrates this −


#+begin_src csharp
using System;

public class MyClass {
   [Obsolete("Don't use OldMethod, use NewMethod instead", true)]

   static void OldMethod() {
      Console.WriteLine("It is the old method");
   }
   static void NewMethod() {
      Console.WriteLine("It is the new method");
   }
   public static void Main() {
      OldMethod();
   }
}
#+end_src
When you try to compile the program, the compiler gives an error message stating −

#+begin_src bash
 Don't use OldMethod, use NewMethod instead
#+end_src
*** Creating Custom Attribute
The .Net Framework allows creation of custom attributes that can be used to store
declarative information and can be retrieved at run-time. This information can be related to
any target element depending upon the design criteria and application need.

Creating and using custom attributes involve four steps −

- Declaring a custom attribute
- Constructing the custom attribute
- Apply the custom attribute on a target program element
- Accessing Attributes Through Reflection

The Last step involves writing a simple program to read through the metadata to find various
notations. Metadata is data about data or information used for describing other data. This
program should use reflections for accessing attributes at runtime. This we will discuss in
the next chapter.


A new custom attribute should is derived from the System.Attribute class. For example,

#+begin_src csharp
//a custom attribute BugFix to be assigned to a class and its members
[AttributeUsage(
   AttributeTargets.Class |
   AttributeTargets.Constructor |
   AttributeTargets.Field |
   AttributeTargets.Method |
   AttributeTargets.Property,
   AllowMultiple = true)]

public class DeBugInfo : System.Attribute
#+end_src

* Common Types
** String
In C#, string is an object of System.String class that represent sequence of characters. We
can perform many operations on strings such as concatenation, comparision, getting
substring, search, trim, replacement etc.

These are the most used methods in the ~string~ class, all methods can be found [[https://docs.microsoft.com/en-us/dotnet/api/system.string?view=net-6.0#methods][here]].
| Method                           | Usage                                                                                                                                                                                                | Notes                                                                                                                                                                                                                                                                                                                                                                       |
|----------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~Clone()~                        | It is used to return a reference to this instance of String.                                                                                                                                         | Not very useful in most case, exists because the ~string~ class does implement the ~ICloneable~ interface, see [[#ICloneable][ICloneable]].                                                                                                                                                                                                                                                  |
| ~Compare(String, String)~        | compares two specified String objects. It returns an integer that indicates their relative position in the sort order.                                                                               |                                                                                                                                                                                                                                                                                                                                                                             |
| ~CompareOrdinal(String, String)~ | It is used to compare two specified String objects by evaluating the numeric values of the corresponding Char objects in each string..                                                               |                                                                                                                                                                                                                                                                                                                                                                             |
| ~CompareTo(String)~              | It is used to compare this instance with a specified String object. It indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string. |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Concat(String, String)~         | It is used to concatenate two specified instances of String.                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Contains(String)~               | It is used to return a value indicating whether a specified substring occurs within this string.                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                             |
| ~EndsWith(String)~               | It is used to check that the end of this string instance matches the specified string.                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Equals(String, String)~         | It is used to determine that two specified String objects have the same value.                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                             |
| ~IndexOf(String)~                | It is used to report the zero-based index of the first occurrence of the specified string in this instance.                                                                                          |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Insert(Int32, String)~          | It is used to return a new string in which a specified string is inserted at a specified index position.                                                                                             |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Intern(String)~                 | It is used to retrieve the system's reference to the specified String.                                                                                                                               | The C# Intern() method is used to retrieve reference to the specified String. It goes to intern pool (memory area) to search for a string equal to the specified String. If such a string exists, its reference in the intern pool is returned. If the string does not exist, a reference to specified String is added to the intern pool, then that reference is returned. |
| ~IsInterned(String)~             | It is used to retrieve a reference to a specified String.                                                                                                                                            | The difference between ~Intern()~ and ~IsInterned()~ is that ~Intern()~ method interns the string if it is not interned but ~IsInterned()~ doesn't do so. In such case, ~IsInterned()~ method returns null.                                                                                                                                                                 |
| ~IsNullOrEmpty(String)~          | It is used to indicate that the specified string is null or an Empty string.                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                             |
| ~IsNullOrWhiteSpace(String)~     | It is used to indicate whether a specified string is null, empty, or consists only of white-space characters.                                                                                        |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Join(String, String[])~         | It is used to concatenate all the elements of a string array, using the specified separator between each element.                                                                                    | See [[#join][~join~ example.]]                                                                                                                                                                                                                                                                                                                                                         |
| ~LastIndexOf(Char)~              | It is used to report the zero-based index position of the last occurrence of a specified character within String.                                                                                    |                                                                                                                                                                                                                                                                                                                                                                             |
| ~LastIndexOfAny(Char[])~         | It is used to report the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.                                                   |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Remove(Int32)~                  | It is used to return a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.                |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Replace(String, String)~        | It is used to return a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.                                                 |                                                                                                                                                                                                                                                                                                                                                                             |
| ~Split(Char[])~                  | It is used to split a string into substrings that are based on the characters in an array.                                                                                                           | See [[#split][split example]].                                                                                                                                                                                                                                                                                                                                                          |
| ~StartsWith(String)~             | It is used to check whether the beginning of this string instance matches the specified string.                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                             |
| ~ToLower()~                      | It is used to convert String into lowercase.                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                             |
| ~ToUpper()~                      | It is used to convert String into uppercase.                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                             |
*** Join Example
:PROPERTIES:
:CUSTOM_ID: join
:END:
#+begin_src csharp
string[] s1 = {"Hello","C#", "Fuck Microsoft"};
string s3 = string.Join("-",s1);
Console.WriteLine(s3);
#+end_src

#+RESULTS:
: Hello-C#-Fuck Microsoft

*** Split Example
:PROPERTIES:
:CUSTOM_ID: split
:END:
#+begin_src csharp
string s1 = "Hello C Sharp";
string[] s2 = s1.Split(' ');
foreach (string s3 in s2)
{
 Console.WriteLine(s3);
}
#+end_src

#+RESULTS:
| Hello |
| C     |
| Sharp |

** Collections
Another of the most common types of data is collections. If you need to store
multiple values in a variable, then you can use a collection.

A collection is a data structure in memory that can manage multiple items in
different ways, although all collections have some shared functionality.

*** ~List<T>~
:PROPERTIES:
:CUSTOM_ID: list
:END:
Lists are a good choice when you want to manually control the order of items in
a collection. Each item in a list has a unique index (or position) that is automatically
assigned. Items can be any type defined by T and items can be duplicated. Indexes
are int types and start from 0, so the first item in a list is at index 0.
**** Constructors
| Constructor               | Description                                                                                                                                                                            |
|---------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~List<T>()~               | Initializes a new instance of the ~List<T>~ class that is empty and has the default initial capacity.                                                                                  |
| ~List<T>(IEnumerable<T>)~ | Initializes a new instance of the ~List<T>~ class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied. |
| ~List<T>(Int32)~          | Initializes a new instance of the ~List<T>~ class that is empty and has the specified initial capacity.                                                                                |

#+begin_src csharp
// using the first empty construtor
List<int>ListOfNumers = new List<int>(); //empty, add numbers using proper method.
int [] arr= new int [] {1,2,3,4,5};
Console.WriteLine(ListOfNumers.Count);
List<int>ListOfNumers_2 = new List<int>(arr);
Console.WriteLine(ListOfNumers_2.Count);
List<int>ListOfNumers_3 = new List<int>(12);
Console.WriteLine(ListOfNumers_3.Count);
#+end_src

#+RESULTS:
| 0 |
| 5 |
| 0 |

However the last constructor is not so popluar as the previous ones, it is very handy and
useful in a lot of cases. What it actually does, is drecreasing the amount taken for memory
reallocation, this takes time and memory and gives the garbage collector stuff to do.

Here are some benchmarks for 100 .Adds:


#+begin_src txt
Method A: Dictionary, no capacity
Time:     1350 ms

Method B: Dictionary, has capacity
Time:     700 ms

Method C: Dictionary, const capacity
Time:     760 ms

Method D: Dictionary, over-large capacity
Time:     1005 ms

Method E: List, no capacity
Time:     1010 ms

Method F: List, accurate capacity
Time:     575 ms

#+end_src

**** Methods
| Method                                         | Description                                                                                                                                                                                                                                                                    |
|------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~Add(T)~                                       | Adds an object to the end of the List<T>.                                                                                                                                                                                                                                      |
| ~AddRange(IEnumerable<T>)~                     | Adds the elements of the specified collection to the end of the List<T>. See [[#addrange][example]]                                                                                                                                                                                           |
| ~AsReadOnly()~                                 | Returns a read-only ReadOnlyCollection<T> wrapper for the current collection.                                                                                                                                                                                                  |
| ~BinarySearch(Int32, Int32, T, IComparer<T>l)~ | Searches a range of elements in the sorted List<T> for an element using the specified comparer and returns the zero-based index of the element. [[#binaryseach][Example]]                                                                                                                        |
| ~Clear()~                                      | Removes all elements from the List<T>.                                                                                                                                                                                                                                         |
| ~Contains(T)~                                  | Determines whether an element is in the List<T>.                                                                                                                                                                                                                               |
| ~CopyTo(T[])~                                  | Copies the entire List<T> to a compatible one-dimensional array, starting at the beginning of the target array. [[#copyto][Example]]                                                                                                                                                        |
| ~Exists(Predicate<T>)~                         | Determines whether the List<T> contains elements that match the conditions defined by the specified predicate. [[#exist][Example]]                                                                                                                                                         |
| ~Find(Predicate<T>)~                           | Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire List<T>. [[#find][Example]]                                                                                                                    |
| ~EnsureCapacity(Int32)~                        | Ensures that the capacity of this list is at least the specified capacity. If the current capacity is less than capacity, it is successively increased to twice the current capacity until it is at least the specified capacity.                                              |
| ~FindAll(Predicate<T>)~                        | Retrieves all the elements that match the conditions defined by the specified predicate.                                                                                                                                                                                       |
| ~FindIndex(Int32, Predicate<T>)~               | Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the List<T> that extends from the specified index to the last element.                        |
| ~FindIndex(Int32, Int32, Predicate<T>)~        | Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the List<T> that starts at the specified index and contains the specified number of elements. |
| ~FindLast(Predicate<T>)~                       | Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire List<T>.                                                                                                                             |
| ~FindLastIndex(Int32, Int32, Predicate<T>)~    | Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the List<T> that contains the specified number of elements and ends at the specified index.    |
| ~FindLastIndex(Int32, Predicate<T>)~           | ~                                                                                                                                                                                                                                                                              |
| ~ForEach(Action<T>)~                           | Performs the specified action on each element of the List<T>. [[#foreach][Example]]                                                                                                                                                                                                          |
| ~Insert(Int32, T)~                             | Inserts an element into the List<T> at the specified index.                                                                                                                                                                                                                    |
| ~LastIndexOf(T)~                               | Searches for the specified object and returns the zero-based index of the last occurrence within the entire List<T>.                                                                                                                                                           |
| ~Remove(T)~                                    | Removes the first occurrence of a specific object from the List<T>.                                                                                                                                                                                                            |
| ~RemoveAll(Predicate<T>)~                      | Removes all the elements that match the conditions defined by the specified predicate.                                                                                                                                                                                         |
| ~RemoveAt(Int32)~                              | Removes the element at the specified index of the List<T>.                                                                                                                                                                                                                     |
| ~RemoveRange(Int32, Int32)~                    | Removes a range of elements from the List<T>.                                                                                                                                                                                                                                  |
| ~Reverse()~                                    | Reverses the order of the elements in the entire List<T>.                                                                                                                                                                                                                      |
| ~Reverse(Int32, Int32)~                        | Reverses the order of the elements in the specified range.                                                                                                                                                                                                                     |
| ~Sort()~                                       | Sorts the elements in the entire List<T> using the default comparer.

                                                                                                                                                                                                                                                                               |   |   |
                                                                                                                                                                                                                                                                               |   |   |
                                                                                                                                                                                                                                                                               |   |   |
                                                                                                                                                                                                                                                                               |   |   |
***** ~AddRange(IEnumerable<T>)~ Example
:PROPERTIES:
:CUSTOM_ID: addrange
:END:
#+begin_src csharp
var list = new List<int>();
list.Add(1);
list.Add(2);
list.Add(5);
list.Add(6);

var array = new int[3];
array[0] = 7;
array[1] = 6;
array[2] = 7;

list.AddRange(array);
foreach (int value in list) {
    Console.WriteLine("VALUE: {0}", value);
}
#+end_src

#+RESULTS:
| VALUE: | 1 |
| VALUE: | 2 |
| VALUE: | 5 |
| VALUE: | 6 |
| VALUE: | 7 |
| VALUE: | 6 |
| VALUE: | 7 |

***** ~BinarySearch(Int32, Int32, T, IComparer<T>l)~ Example
:PROPERTIES:
:CUSTOM_ID: binaryseach
:END:
#+begin_src csharp
var data = new List<string>() { "banana", "peach", "apple" };

// Part 1: ensure list is sorted.
data.Sort();
Console.WriteLine(string.Join(",", data));

// Part 2: test the results of BinarySearch.
int i = data.BinarySearch("peach");
Console.WriteLine(i);

i = data.BinarySearch("banana");
Console.WriteLine(i);

i = data.BinarySearch("apple");
Console.WriteLine(i);
#+end_src

#+RESULTS:
| apple,banana,peach |
|                  2 |
|                  1 |
|                  0 |

***** ~CopyTo(T[])~ Example

#+begin_src csharp
var list = new List<int>() { 10, 20, 30 };
int[] array = new int[5];
list.CopyTo(array, 2);
Console.WriteLine("LIST:  " + string.Join(",", list));
Console.WriteLine("ARRAY: " + string.Join(",", array));
#+end_src

#+RESULTS:
| LIST:  10  20  30         |
| ARRAY: 0    0  10  20  30 |

Or:
#+begin_src csharp
var list = new List<int>() { 5, 6, 7 };
int[] array = new int[list.Count];
list.CopyTo(array);
Console.WriteLine(array[0]);
Console.WriteLine(array[1]);
Console.WriteLine(array[2]);
#+end_src

#+RESULTS:
| 5 |
| 6 |
| 7 |

***** ~Exist(Predicate<T>)~ Example
#+begin_src csharp
List<int> list = new List<int>();
list.Add(7);
list.Add(11);
list.Add(13);

// See if any elements with values greater than 10 exist.
bool exists = list.Exists(element => element > 10);
Console.WriteLine(exists);

// Check for numbers less than 7.
exists = list.Exists(element => element < 7);
Console.WriteLine(exists);
#+end_src

#+RESULTS:
| True  |
| False |

***** ~Find(Predicate<T>)~ Example
#+begin_src csharp
List<int> list = new List<int>(new int[] { 19, 23, 29 });
int result = list.Find(item => item > 20);
Console.WriteLine(result);
#+end_src
#+RESULTS:
: 23

***** ~FindIndex(Int32, Predicate<T>)~ Example
Start search from the index of the Int32
#+begin_src csharp
List<int> listOfNumers3 = new List<int> {1, 1, 3, 4, 5, 1 };
Console.WriteLine(listOfNumers3.FindIndex(2, x=> x == 1));
#+end_src

#+RESULTS:
: 5

***** ~ForEach(Action<T>)~ Example
#+begin_src csharp
List<int> ListOfNumers_3 = new List<int> { 1, 2, 3, 4, 5, 6 };
int[] MyNewList = new int[2];
ListOfNumers_3.ForEach(x => Console.WriteLine(x));
#+end_src
**** Properties
| Property    | Description                                                                                      |
|-------------+--------------------------------------------------------------------------------------------------|
| Capacity    | Gets or sets the total number of elements the internal data structure can hold without resizing. |
| Count       | Gets the number of elements contained in the List<T>.                                            |
| ~Item[int]~ | Gets or sets the element at the specified index.                                                 |

*** ~Dictionary<T_Key, T_Value>~
Dictionaries are a good choice when each value (or object) has a unique sub value
(or a made-up value) that can be used as a key to quickly find the value in the
collection later. The key must be unique. For example, if you are storing a list of
people, you could choose to use a government-issued identity number as the key.

Think of the key as being like an index entry in a real-world dictionary. It allows you
to quickly find the definition of a word because the words (for example, keys) are
kept sorted, and if we know we're looking for the definition of manatee, we would
jump to the middle of the dictionary to start looking, because the letter M is in the
middle of the alphabet.

*Note: most of the C# predifend collections share the very corresponding methods,
constructors and properties that are shown in [[#list][~List<T>~,]] (since all of them implement common
interfaces like ~IEnumerable~ and others, to save time, I will not declare any of it again.*

**** Constructors

| Constructor                                                                                | Description                                                                                                                                                                                        |
|--------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ~Dictionary<TKey,TValue>()~                                                                | Initializes a new instance of the Dictionary<TKey,TValue> class that is empty, has the default initial capacity, and uses the default equality comparer for the key type.                          |
| ~Dictionary<TKey,TValue>(IDictionary<TKey,TValue>)~                                        | Initializes a new instance of the Dictionary<TKey,TValue> class that contains elements copied from the specified IDictionary<TKey,TValue> and uses the default equality comparer for the key type. |
| ~Dictionary<TKey,TValue>(IDictionary<TKey,TValue>, IEqualityComparer<TKey>)~               | Initializes a new instance of the Dictionary<TKey,TValue> class that contains elements copied from the specified IDictionary<TKey,TValue> and uses the specified IEqualityComparer<T>.             |
| ~Dictionary<TKey,TValue>(IEnumerable<KeyValuePair<TKey,TValue>>)~                          | Initializes a new instance of the Dictionary<TKey,TValue> class that contains elements copied from the specified IEnumerable<T>.                                                                   |
| ~Dictionary<TKey,TValue>(IEnumerable<KeyValuePair<TKey,TValue>>, IEqualityComparer<TKey>)~ | Initializes a new instance of the Dictionary<TKey,TValue> class that contains elements copied from the specified IEnumerable<T> and uses the specified IEqualityComparer<T>.                       |
| ~Dictionary<TKey,TValue>(IEqualityComparer<TKey>)~                                         | Initializes a new instance of the Dictionary<TKey,TValue> class that is empty, has the default initial capacity, and uses the specified IEqualityComparer<T>.                                      |
| ~Dictionary<TKey,TValue>(Int32)~                                                           | Initializes a new instance of the Dictionary<TKey,TValue> class that is empty, has the specified initial capacity, and uses the default equality comparer for the key type.                        |
| ~Dictionary<TKey,TValue>(Int32, IEqualityComparer<TKey>)~                                  | Initializes a new instance of the Dictionary<TKey,TValue> class that is empty, has the specified initial capacity, and uses the specified IEqualityComparer<T>.                                    |
| ~Dictionary<TKey,TValue>(SerializationInfo, StreamingContext)~                             | Initializes a new instance of the Dictionary<TKey,TValue> class with serialized data.                                                                                                              |
|--------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

**** Properties
   | Properties | Description                                                                                                        |
   |------------+--------------------------------------------------------------------------------------------------------------------|
   | Comparer   | Gets the IEqualityComparer<T> that is used to determine equality of keys for the dictionary. See [[#IEquality][IEqualityComparer]] |
   | Count Gets | the number of key/value pairs contained in the Dictionary<TKey,TValue>.                                            |
   | Item[TKey] | Gets or sets the value associated with the specified key.                                                          |
   | Keys       | Gets a collection containing the keys in the Dictionary<TKey,TValue>.                                              |
   | Values     | Gets a collection containing the values in the Dictionary<TKey,TValue>.                                            |

*** ~Stack~
:PROPERTIES:
:CUSTOM_ID: stack
:END:
Stacks are a good choice when you want to implement the last-in, first-out (LIFO)
behavior. With a stack, you can only directly access or remove the one item at the top
of the stack, although you can enumerate to read through the whole stack of items.
You cannot, for example, directly access the second item in a stack.
**** Constructors
| Constructor                | Description                                                                                                                                                                            |
| ~Stack<T>()~               | Initializes a new instance of the Stack<T> class that is empty and has the default initial capacity.                                                                                   |
| ~Stack<T>(IEnumerable<T>)~ | Initializes a new instance of the Stack<T> class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied. |
| ~Stack<T>(Int32)~          | Initializes a new instance of the Stack<T> class that is empty and has the specified initial capacity or the default initial capacity, whichever is greater.                           |

**** Methods
| Method       | Description                                                                                                                                                                                  |
| ~Peek()~     | Returns the object at the top of the Stack<T> without removing it.                                                                                                                           |
| ~Pop()~      | Removes and returns the object at the top of the Stack<T>.                                                                                                                                   |
| ~TryPeek(T)~ | Returns a value that indicates whether there is an object at the top of the Stack<T>, and if one is present, copies it to the result parameter. The object is not removed from the Stack<T>. |
| ~TryPop(T)~  | Returns a value that indicates whether there is an object at the top of the Stack<T>, and if one is present, copies it to the result parameter, and removes it from the Stack<T>.            |

**** Properties
+ ~Count~: Gets the number of elements contained in the Stack<T>.

*** ~Queue~
Queues are a good choice when you want to implement the first-in, first-out (FIFO)
behavior. With a queue, you can only directly access or remove the one item at the
front of the queue, although you can enumerate to read through the whole queue of
items. You cannot, for example, directly access the second item in a queue.

*** ~LinkedList<T>~
A linked list is a linear collection of data elements whose order is not given by their
physical placement in memory. Instead, each element points to the next. It is a data
structure consisting of a collection of nodes which together represent a sequence.
**** Methods
| Method                                            | Description                                                                                             |
|---------------------------------------------------+---------------------------------------------------------------------------------------------------------|
| ~AddAfter(LinkedListNode<T>, LinkedListNode<T>)~  | Adds the specified new node after the specified existing node in the LinkedList<T>.                     |
| ~AddAfter(LinkedListNode<T>, T)~                  | Adds a new node containing the specified value after the specified existing node in the LinkedList<T>.  |
| ~AddBefore(LinkedListNode<T>, LinkedListNode<T>)~ | Adds the specified new node before the specified existing node in the LinkedList<T>.                    |
| ~AddBefore(LinkedListNode<T>, T)~                 | Adds a new node containing the specified value before the specified existing node in the LinkedList<T>. |
| ~AddFirst(LinkedListNode<T>)~                     | Adds the specified new node at the start of the LinkedList<T>.                                          |
| ~AddFirst(T)~                                     | Adds a new node containing the specified value at the start of the LinkedList<T>.                       |
| ~AddLast(LinkedListNode<T>)~                      | Adds the specified new node at the end of the LinkedList<T>.                                            |
| ~AddLast(T)~                                      | Adds a new node containing the specified value at the end of the LinkedList<T>.                         |
**** Properties
| Property | Description                                                       |
|----------+-------------------------------------------------------------------|
| ~Count~  | Gets the number of nodes actually contained in the LinkedList<T>. |
| ~First~  | Gets the first node of the LinkedList<T>.                         |
| ~Last~   | Gets the last node of the LinkedList<T>.                          |
*** TODO ~HashSet~, ~SortedSet~
*** TODO ~ConcurrentQueue<T>~
*** TODO ~ConcurrentQueue<T>~
*** TODO ~ConcurrentStack<T>~
*** TODO ~ConcurrentDictionary<TKey,TValue>~
* Assemblies, Namespaces, Packages, and Frameworks
An *assembly* is where a type is stored in the filesystem. Assemblies are a mechanism
for _deploying code_. For example, the ~System.Data.dll~ assembly contains types for
managing data. To use types in other assemblies, they must be referenced.

Assemblies are often distributed as NuGet packages, which can contain multiple
assemblies and other resources. You will also hear about ~metapackages~ and
platforms, which are combinations of NuGet packages.

A namespace is the address of a type. Namespaces are a mechanism to uniquely
identify a type by requiring a full address rather than just a short name.

In .NET, the ~IActionFilter~ interface of the ~System.Web.Mvc~ namespace is different
from the ~IActionFilter~ interface of the ~System.Web.Http.Filters~ namespace.

If an assembly is compiled as a class library and provides types for other assemblies
to use, then it has the file extension ~.dll~ (dynamic link library), and it cannot be
executed standalone.

Likewise, if an assembly is compiled as an application, then it has the file extension
~.exe~ (executable) and can be executed standalone. Before .NET Core 3.0, console
apps were compiled to .dll files and had to be executed by the dotnet run
command or a host executable.

Any assembly can reference one or more class library assemblies as dependencies,
but you cannot have circular references. So, assembly B cannot reference assembly
A, if assembly A already references assembly B. The compiler will warn you if you
attempt to add a dependency reference that would cause a circular reference.

.NET Core is split into a set of packages, distributed using a Microsoft-supported
package management technology named NuGet. Each of these packages represents
a single assembly of the same name. For example, the System.Collections package
contains the System.Collections.dll assembly.

The following are the benefits of packages:
- Packages can ship on their own schedule.
- Packages can be tested independently of other packages.
- Packages can support different OSes and CPUs by including multiple versions of the same assemblies (built for different CPUs).
- Apps are smaller because unreferenced packages are not a part of the distribution

There is a two-way relationship between frameworks and packages. *Packages define the APIs,
while frameworks group packages*. A framework without any packages would not define any
APIs.

.NET packages each support a set of frameworks. For example, the System.IO.FileSystem
package version 4.3.0 supports the following frameworks:
   -   .NET Standard, version 1.3 or later.
   -   .NET Framework, version 4.6 or later.
   -   Six Mono and Xamarin platforms (for example, Xamarin.iOS 1.0).

Before .NET Standard, there were Portable Class Libraries (PCLs). With PCLs, you
could create a library of code and explicitly specify which platforms you want the
library to support, such as Xamarin, Silverlight, and Windows 8. Your library could
then use the intersection of APIs that are supported by the specified platforms.

Microsoft realized that this is unsustainable, so they created .NET Standard—a single
API that all future .NET platforms will support. There are older versions of .NET
Standard, but only .NET Standard 2.0 and later is supported by multiple .NET
platforms. For the rest of this book I will use the term .NET Standard to mean .NET
Standard 2.0 or later.

.NET Standard is similar to HTML5 in that they are both standards that a platform should
support. Just as Chrome browser and Edge browser implement the HTML5 standard, so .NET Core,
.NET Framework, and Xamarin all implement .NET Standard. If you want to create a library of
types that will work across variants of .NET, you can do so most easily with .NET Standard.

* Difference between .NET Framework and .NET Core
There are three key differences as shown in the following table:
| .NET Core                                                                                                                                             | .NET Framework                                                                                          |
|-------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------|
| Distributed as NuGet packages, so each application can be deployed with its own app-local copy of the version of .NET Core that it needs              | Distributed as a system-wide, shared set of assemblies (literally, in the Global Assembly Cache (GAC))  |
| Split into small, layered components, so a minimal deployment can be performed.                                                                       | Single, monolithic deployment.                                                                          |
| Removes older technologies, such as ASP.NET Web Forms, and non-cross- platform features, such as AppDomains, .NET Remoting, and binary serialization. | As well as the technologies in .NET Core, it retains some older technologies such as ASP.NET Web Forms. |
|-------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------|

* Publishing
There are three ways to publish and deploy a .NET Core application. They are:

** Framework-dependent deployment (FDD).
If you choose to deploy your application and its package dependencies, but not .NET
Core itself, then you rely on .NET Core already being on the target computer. This
works well for web applications deployed to a server because .NET Core and lots of
other web applications are likely already on the server.

** Framework-dependent executables (FDEs).
Apps published as framework-dependent are cross-platform and don't include the .NET runtime.
The user of your app is required to install the .NET runtime.

Publishing an app as framework-dependent produces a cross-platform binary as a dll file, and
a platform-specific executable that targets your current platform. The dll is cross-platform
while the executable isn't. For example, if you publish an app named word_reader and target
Windows, a word_reader.exe executable is created along with word_reader.dll. When targeting
Linux or macOS, a word_reader executable is created along with word_reader.dll.

The cross-platform binary of your app can be run with the dotnet <filename.dll> command, and
can be run on any platform. If the app uses a NuGet package that has platform-specific
implementations, all platforms' dependencies are copied to the publish folder along with the
app.

You can create an executable for a specific platform by passing the ~-r <RID>
--self-contained~ false parameters to the dotnet publish command. When the ~-r~ parameter is
omitted, an executable is created for your current platform. Any ~NuGet~ packages that have
platform-specific dependencies for the targeted platform are copied to the publish folder.
If you don't need a platform-specific executable, you can specify
~<UseAppHost>False</UseAppHost>~ in the project file. For more information, see MSBuild
reference for .NET SDK projects.

*** Advantages
+ Small deployment
  Only your app and its dependencies are distributed. The .NET runtime and libraries are
  installed by the user and all apps share the runtime.
+ Cross-platform
  Your app and any .NET-based library runs on other operating systems. You don't need to define a target platform for your app. For information about the .NET file format, see .NET Assembly File Format.
+ Uses the latest patched runtime
  The app uses the latest runtime (within the targeted major-minor family of .NET)
  installed on the target system. This means your app automatically uses the latest patched
  version of the .NET runtime. This default behavior can be overridden. For more
  information, see framework-dependent apps roll forward.
*** Disadvantages
- Requires pre-installing the runtime
 Your app can run only if the version of .NET your app targets is already installed on the
  host system. You can configure roll-forward behavior for the app to either require a
  specific version of .NET or allow a newer version of .NET. For more information, see
  framework-dependent apps roll forward.
- .NET may change
 It's possible for the .NET runtime and libraries to be updated on the machine where the app is run. In rare cases, this may change the behavior of your app if you use the .NET libraries, which most apps do. You can configure how your app uses newer versions of .NET. For more information, see framework-dependent apps roll forward.
** Self-contained.
Sometimes, you want to be able to give someone a USB stick containing your
application and know that it can execute on their computer. You want to perform
a self-contained deployment. While the size of the deployment files will be larger,
you'll know that it will work.

Publishing your app as self-contained produces a platform-specific executable. The output
publishing folder contains all components of the app, including the .NET libraries and
target runtime. The app is isolated from other .NET apps and doesn't use a locally installed
shared runtime. The user of your app isn't required to download and install .NET.

The executable binary is produced for the specified target platform. For example, if you
have an app named word_reader, and you publish a self-contained executable for Windows, a
word_reader.exe file is created. Publishing for Linux or macOS, a word_reader file is
created. The target platform and architecture is specified with the -r <RID> parameter for
the dotnet publish command. For more information about RIDs, see .NET RID Catalog.

If the app has platform-specific dependencies, such as a NuGet package containing
platform-specific dependencies, these are copied to the publish folder along with the app.
*** Advantages
- Control .NET version
  You control which version of .NET is deployed with your app.
- Platform-specific targeting
  Because you have to publish your app for each platform, you know where your app will run.
  If .NET introduces a new platform, users can't run your app on that platform until you
  release a version targeting that platform. You can test your app for compatibility
  problems before your users run your app on the new platform.


*** Disadvantages
- Larger deployments
 Because your app includes the .NET runtime and all of your app dependencies, the download
 size and hard drive space required is greater than a framework-dependent version.

------
To publish your project to run by platforms, add the following identifier in ~csproj~:
#+begin_src html
<RuntimeIdentifiers>
win10-x64;osx-x64;freebsd.13-x64;arch-x64
</RuntimeIdentifiers>
#+end_src

- The ~win10-x64~ RID value means Windows 10 or Windows Server 2016.
- The ~osx-x64~ RID value means macOS Sierra 10.12 or later.
- The ~freebsd.13-x64~ RID value means FreeBSD 13 is supported or later.
- The ~arch-x64~ means that Arch Linux is supported.
* /Misc Notes/
** Operators
*** Null-conditional operators ~??~ and ~??=~

The null-coalescing operator ~??~ returns the value of its left-hand operand if it isn't null;
otherwise, it evaluates the right-hand operand and returns its result. The ~??~ operator
doesn't evaluate its right-hand operand if the left-hand operand evaluates to non-null.

#+begin_src csharp
string l = null;
string k = l ?? "It is null";
Console.WriteLine(k);
l = "Not Null";
k = l ?? "It is null";
Console.WriteLine(k);
#+end_src


Available in C# 8.0 and later, the null-coalescing assignment operator ~??=~ assigns the value
of its right-hand operand to its left-hand operand only if the left-hand operand evaluates
to null. The ~??=~ operator doesn't evaluate its right-hand operand if the left-hand operand
evaluates to non-null.

#+begin_src csharp
string? x = null;
x ??= "It was null, now it is not";
Console.WriteLine(x);
#+end_src
#+RESULTS:
: It was null, now it is not
*** Null-conditional Operators ~?.~ and ~?[]~

Available in C# 6 and later, a null-conditional operator applies a member access, ~?.$, or
element access, ~?[]~, operation to its operand only if that operand evaluates to non-null;
otherwise, it returns null. That is,

If a evaluates to null, the result of ~a?.x~ or ~a?[x]~ is null.

If a evaluates to non-null, the result of ~a?.x~ or ~a?[x]~ is the same as the result of ~a.x~ or
~a[x]~, respectively.
*** Range Operator ~..~
The ~..~ operator specifies the start and end of a range of indices as its operands. *The
left-hand operand is an /inclusive/ start of a range. The right-hand operand is an /exclusive/
end of a range.* Either of operands can be an index from the start or from the end of a
sequence, as the following example shows:
#+begin_src csharp
int[] numbers = new[] { 0, 10, 20, 30, 40, 50 };
int start = 1;
int amountToTake = 3;
int[] subset = numbers[start..(start + amountToTake)];
Display(subset);  // output: 10 20 30

int margin = 1;
int[] inner = numbers[margin..^margin];
Display(inner);  // output: 10 20 30 40

string line = "one two three";
int amountToTakeFromEnd = 5;
Range endIndices = ^amountToTakeFromEnd..^0;
string end = line[endIndices];
Console.WriteLine(end);  // output: three
void Display<T>(IEnumerable<T> xs) => Console.WriteLine(string.Join(" ", xs));
#+end_src
** Static class
A static class is basically the same as a non-static class, but there is one difference: a
static class cannot be instantiated. In other words, you cannot use the new operator to
create a variable of the class type. Because there is no instance variable, you access the
members of a static class by using the class name itself. For example, if you have a static
class that is named UtilityClass that has a public static method named MethodA, you call the
method as shown in the following example:

The following list provides the main features of a static class:
- Contains only static members.
- Cannot be instantiated.
- Is sealed.
- Cannot contain Instance Constructors.

** Constants?
Constants should be avoided for two important reasons: the value must be known at compile
time, and it must be expressible as a literal string, Boolean, or number value. Every
reference to the ~const~ field is replaced with the literal value at compile time, which
will, therefore, not be reflected if the value changes in a future version and you do not
recompile any assemblies that reference it to get the new value.

** ~{get; set}~
The following syntax:

#+begin_src csharp
public class Genre {
    public string Name { get; set; }
}
#+end_src

using ~{set; get;}~ is called auto property, it is a shorthand for the following code:

#+begin_src csharp
private string name;
public string Name {
    get {
        return this.name;
    }
    set {
        this.name = value;
    }
}
#+end_src
** ~partial class~

It is possible to split the definition of a class, a struct, an interface or a method over
two or more source files. Each source file contains a section of the type or method
definition, and all parts are combined when the application is compiled.

There are several situations when splitting a class definition is desirable:

+ When working on large projects, spreading a class over separate files enables multiple programmers to work on it at the same time.
+ When working with automatically generated source, code can be added to the class without having to recreate the source file. Visual Studio uses this approach when it creates Windows Forms, Web service wrapper code, and so on. You can create code that uses these classes without having to modify the file created by Visual Studio.
+ When using source generators to generate additional functionality in a class.

To split a class definition, use the partial keyword modifier, as shown here:

#+begin_src csharp
public partial class Employee {
    public void DoWork() {

    }
}

public partial class Employee {
    public void GoToLunch() {

    }
}
#+end_src

** Use ~class~, Use ~struct~

There are two categories of memory: *stack memory* and *heap memory*. With
modern operating systems, the stack and heap can be anywhere in physical or
virtual memory.

Stack memory is faster to work with (because it is managed directly by the CPU
and because it uses a first-in, first-out mechanism, it is more likely to have the data
in its L1 or L2 cache) but limited in size, while heap memory is slower but much
more plentiful. For example, on my terminal, I can enter the command:
~ulimit -a~ to discover that stack size is limited to 32,192 KB and other memory is
"unlimited." This is why it is so easy to get a "stack overflow."

There are two C# keywords that you can use to create object types: class and
struct. Both can have the same members, such as fields and methods. The
difference between the two is how memory is allocated.

When you define a type using class, you are defining a reference type. This means
that the memory for the object itself is allocated on the heap, and only the memory
address of the object (and a little overhead) is stored on the stack.

When you define a type using struct, you are defining a value type. This means
that the memory for the object itself is allocated on the stack.

If a struct uses field types that are not of the struct type, then those fields will be
stored on the heap, meaning the data for that object is stored in both the stack and
the heap!

These are the most common struct types:

- Numbers: ~byte~, ~sbyte~, ~short~, ~ushort~, ~int~, ~uint~, ~long~, ~ulong~, ~float~, ~double~, and ~decimal~
- Miscellaneous: ~char~ and ~bool~
- System.Drawing: ~Color~, ~Point~, and ~Rectangle~

Almost all the other types are ~class~ types, including string. Apart from the difference in
where in memory the data for a type is stored, the other major difference is that you cannot
inherit from a ~struct~.


*Tip*:

If the total bytes used by all the fields in your type is 16 bytes or less, your type only
uses ~struct~ types for its fields, and you will never want to derive from your type, then
Microsoft recommends that you use ~struct~. If your type uses more than 16 bytes of stack
memory, if it uses ~class~ types for its fields, or if you might want to inherit from it, then
use ~class~.

** Mutable vs. Immutable
Mutable and immutable are English words that mean "can change" and "cannot change"
respectively. The meaning of these words is the same in C# programming language; that means
the mutable types are those whose data members can be changed after the instance is created
but Immutable types are those whose data members can not be changed after the instance is
created.

When we change the value of mutable objects, value is changed in same memory. But in
immutable type, the new memory is created and the modified value is stored in new memory.
*** ~String~
Strings are immutable, which means we are creating new memory everytime instead of working
on existing memory.

So, whenever we are modifying a value of the existing string, i.e., we are creating a new
object which refers to that modified string and the old one becomes unreferenced. Hence, if
we are modifying the existing string continuously, then numbers of the unreferenced object
will be increased and it will wait for the garbage collector to free the unreferenced object
and our application performance will be decreased.

#+begin_src csharp
string str = string.Empty;
for (int i = 0; i < 1000; i++)
{
    str += "Modified ";
}
#+end_src
In the code given above, string str will update 1000 times inside the loop and every time it
will create new instance so all old values will be collected by garbage collector after some
time.

It is not a good approach for this solution so, it’s better to go for mutable type. So in
C#, we have StringBuilder which is a mutable type. We have some advantages of immutable
classes like immutable objects are simpler to construct, test, and use. immutable objects
are always thread-safe and etc.

*** ~StringBuilder~
StringBuilder is a mutable type, that means we are using the same memory location and keep
on appending/modifying the stuff to one instance. It will not create any further instances
hence it will not decrease the performance of the application.


#+begin_src csharp
StringBuilder strB = new StringBuilder();

for (int i = 0; i < 10000; i++)
{
    strB.Append("Modified ");
}
#+end_src

*** Creating an Immutable Class
Make the variables read-only so we can not modify the variable after assigning the first time.
#+begin_src csharp
class MyClass
{
        private readonly string myStr;
}
#+end_src
Use parameterized constructor for assigning the myStr value for the class while creating the object of the class as below
#+begin_src csharp
class MyClass
    {
        private readonly string myStr;

        public MyClass(string str)
        {
            myStr = str;
        }
    }
#+end_src
Use properties for getting the variables of the class and remove the setters of the property, use only getters as below.
#+begin_src csharp
class MyClass
    {
        private readonly string myStr;

        public MyClass(string str)
        {
            myStr = str;
        }

        public string GetStr
        {
            get { return myStr; }
        }
    }

#+end_src

* Take a Look
- [[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading#overloadable-operators][Overloadable operators]]
- [[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions][Best practices for exceptions]]
- [[https://stackoverflow.com/questions/40943117/local-function-vs-lambda-c-sharp-7-0][Local Function vs Lambada]]
- [[https://stackoverflow.com/questions/50635937/local-functions-and-solid-principles-c-sharp][Local Function & SOLID]]
- [[https://stackoverflow.com/questions/15394032/difference-between-casting-and-using-the-convert-to-method/15395832#15395832][Casting & Convert.To()]]
- [[https://xunit.net/docs/getting-started/netfx/jetbrains-rider][xUnit testing with Rider]]
- [[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await][Await Operator]]
- [[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/][XML documentation comments]]
- [[https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines][Naming Guidelines]]
- [[https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions][Coding Conventions]]
- [[https://docs.microsoft.com/en-us/archive/blogs/csharpfaq/][C# Frequently Asked Questions]]
- [[https://docs.microsoft.com/en-us/dotnet/api/system.string.isnormalized?view=net-6.0][Is Normalized]]

* TODOs Topics..
** TODO Exception (Check All Types)
** TODO Implement ~IDisposable~
** TODO Implement ~IFormatter~
** TODO Implement ~IFormattable~
** TODO Implement ~IFormatProvider~
** PROJ GetHash
** TODO ~checked~ and ~unchecked~
** TODO ~Span~
** TODO [[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/query-keywords][Query Keywords]]
* Thinking
- How to end function of if statements? using return 0 or else with last value?
  #+begin_src csharp
    public int Compare(Person x, Person y) {
        if (x.id > y.id) {
            // if Person X's id is bigger, then y should comes first, so return 1
                return 1;
        }
        else if (x.id < y.id) {
            // If person Y's id is bigger, then y should come after x, so returns -1
            return -1;
        }
        return 0; // in this case, they are equal, no need to change any arrangement
    }
  #+end_src
- Why we need to call like this?
  #+begin_src csharp
Array.Sort(people, new PersonCompare());
  #+end_src
  and not just
  #+begin_src csharp
Array.Sort(people, PersonCompare);
  #+end_src

