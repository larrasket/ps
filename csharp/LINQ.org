#+title: "LINQ Notes"
#+draft: true
#+date: 2022-01-08T05:28:26+02:00
* Motivation
*What is LINQ?*

Suppose you are writing an application using .NET. Chances are high that at
some point you’ll need to persist objects to a database, query the database, and load the
results back into objects. The problem is that in most cases, at least with relational
databases, there is a gap between your programming language and the database. Good attempts
have been made to provide object-oriented databases, which would be closer to
object-oriented platforms and imperative programming lan- guages such as C# and VB.NET.
However, after all these years, relational databases are still pervasive, and you still have
to struggle with data access and persistence in all of your programs.

The original motivation behind LINQ was to address the conceptual and tech- nical
difficulties encountered when using databases with .NET programming lan- guages. With LINQ,
Microsoft’s intention was to provide a solution for the problem of object-relational
mapping, as well as to simplify the interaction between objects and data sources. LINQ
eventually evolved into a general-purpose language-integrated querying toolset. This toolset
can be used to access data com- ing from in-memory objects (LINQ to Objects), databases
(LINQ to SQL), XML documents (LINQ to XML), a file-system, or any other source.

sions to these languages: LINQ means Language-INtegrated Query.
 Before LINQ, we had to juggle different languages like SQL, XML, or XPath
along with various technologies and APIs like ADO.NET or System.Xml in every
application written using general-purpose languages such as C# or VB.NET. It goes
without saying that this approach had several drawbacks.1 LINQ glues several
worlds together. It helps us avoid the bumps we would usually find on the road
from one world to another: using XML with objects, objects with relational data,
and relational data with XML are some of the tasks that LINQ will simplify.

 One of the key aspects of LINQ is that it was designed to be used against any
type of object or data source and to provide a consistent programming model for
doing so. The syntax and concepts are the same across all of its uses: Once you
learn how to use LINQ against an array or a collection, you also know most of the
concepts needed to take advantage of LINQ with a database or an XML file.

*Why Do We Need LINQ?*

We have just provided you with an overview of LINQ. The big questions at this point are: Why
do we want a tool like LINQ? What makes the previous tools incon- venient? Was LINQ created
only to make working with programming languages, relational data, and XML at the same time
more convenient?


At the origin of the LINQ project is a simple fact: The vast majority of applica- tions that
are developed access data or talk to a relational database. Consequently, in order to
program applications, learning a language such as C# is not enough. You also have to learn
another language such as SQL, and the APIs that tie it together with C# to form your full
application.

 We’ll start by taking a look at a piece of data-access code that uses the standard
.NET APIs. This will allow us to point out the common problems that are encoun-
tered in this kind of code. We will then extend our analysis by showing how these
problems exist with other kinds of data such as XML. You’ll see that LINQ
addresses a general impedance mismatch between data sources and programming
languages. Finally, a short code sample will give you a glimpse at how LINQ is a
solution to the problem.

The frequent use of databases in applications requires that the .NET Framework
address the need for APIs that can access the data stored within. Of course, this
has been the case since the first appearance of .NET. The .NET Framework Class
Library (FCL) includes ADO.NET, which provides an API to access relational data-
bases and to represent relational data in memory. This API consists of classes such
as SqlConnection, SqlCommand, SqlReader, DataSet, and DataTable, to name a
few. The problem with these classes is that they force the developer to work explic-
itly with tables, records, and columns, while modern languages such as C# and
VB.NET use object-oriented paradigms.

Now that the object-oriented paradigm is the prevailing model in software
development, developers incur a large amount of overhead in mapping it to other
abstractions, specifically relational databases and XML. The result is that a lot of
time is spent on writing plumbing code.3 Removing this burden would increase
productivity in data-intensive programming, which LINQ helps us do.

But it’s not only about productivity! It also impacts quality. Writing tedious
and fragile plumbing code can lead to insidious defects in software or degraded
performance.

* Hello LINQ to Object
#+begin_src csharp
string[] words = new string[] { "Hello", "Wonderful", "Linq", "Beatiful", "World" };
var shortWords =
    from word in words
    where word.Length <= 5
    select word;
foreach (var word in shortWords) Console.WriteLine(word);
#+end_src

#+RESULTS:
| Hello |
| Linq  |
| World |
|       |
As is evident from the results, we have filtered a list of words to select only the
ones whose length is less than or equal to five characters.

We could argue that the same result could be achieved without LINQ using the following code:
#+begin_src csharp
string[] words = new string[] {
  "hello", "wonderful", "linq", "beautiful", "world" };
foreach (string word in words)
  if (word.Length <= 5)
   Console.WriteLine(word);
#+end_src

* LINQ to SQL
The time has come to look at some code using LINQ to SQL. As you saw in our
Hello LINQ example, we are able to write queries against a collection of objects.
The following C# code snippet filters an in-memory collection of contacts based
on their city:

#+begin_src sql
from contact in contacts
where contact.City == "Paris"
select contact;
#+end_src

The good news is that thanks to LINQ to SQL, doing the same on data from a relational
database is direct:
#+begin_src csharp
from contact in db.GetTable<Contact>()
where contact.City == "Paris"
select contact;
#+end_src

This query works on a list of contacts from a database. Notice how subtle the dif-
ference is between the two queries. Only the object on which we are working is
different; the query syntax is exactly the same. This shows how we’ll be able to
work the same way with multiple types of data.

Let’s walk through a simple complete example. To begin with,
you’re probably wondering what ~db.GetTable<Contact>()~ means in our LINQ to SQL.

* LINQ in Depth [22/50]
After being familiar with LINQ basic syntax, you should be able to write queries using old
knowledge in querying any quaring language (i.e SQL) and use it with LINQ intuitively,
therefore I will not include the banal basic querying methods.

You may want to read [[https://salehmu.github.io/notes/psql/][Introduction into PostgreSQL]].
** DONE ~IEnumerable~ and ~IQueryable~
Consider the following program:
#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> integerList = new List<int>()
            {
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10
            };

            var QuerySyntax = from obj in integerList
                              where obj > 5
                              select obj;

            foreach (var item in QuerySyntax)
            {
                Console.Write(item + " ");
            }

            Console.ReadKey();
        }
    }
}
#+end_src

we use the var keyword to create the variable and store the result of the LINQ query. So
let’s check what is the type of the variable? In order to check this, just mouseover the
pointer on to the QuerySynntax variable and you will see that the type is ~IEnumerable<int>~
which is a generic type. So it is important to understand what is ~IEnumerable~?

~IEnumerable~ is an interface that is available in ~System.Collection~ namespace. The
~IEnumerable~ interface is a type of iteration design pattern. It means we can iterate on the
collection of the type ~IEnumerable~. As you can see in the above definition, the ~IEnumerable~
interface has one method called ~GetEnumerator~ which will return an ~IEnumerator~ that iterates
through a collection.

The most important point that you need to remember is, in C#, all the collection classes
(both generic and non-generic) implements the ~IEnumerable~ interface.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<Student> studentList = new List<Student>()
            {
                new Student(){ID = 1, Name = "James", Gender = "Male"},
                new Student(){ID = 2, Name = "Sara", Gender = "Female"},
                new Student(){ID = 3, Name = "Steve", Gender = "Male"},
                new Student(){ID = 4, Name = "Pam", Gender = "Female"}
            };

            //Linq Query to Fetch all students with Gender Male
            IEnumerable<Student> QuerySyntax = from std in studentList
                                               where std.Gender == "Male"
                                               select std;
            //Iterate through the collection
            foreach (var student in QuerySyntax)
            {
                Console.WriteLine( $"ID : {student.ID}  Name : {student.Name}");
            }

            Console.ReadKey();
        }
    }

    public class Student
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public string Gender { get; set; }
    }
}
#+end_src

*IQueryable*

~IQueryable~ is an interface and it is available in ~System.Linq~ namespace. The ~IQuerable~
interface is a child of the ~IEnumerable~ interface. So we can store ~IQuerable~ in a variable
of type IEnumerable. The ~IQuerable~ interface has a property called Provider which is of type
~IQueryProvider~ interface:

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<Student> studentList = new List<Student>()
            {
                new Student(){ID = 1, Name = "James", Gender = "Male"},
                new Student(){ID = 2, Name = "Sara", Gender = "Female"},
                new Student(){ID = 3, Name = "Steve", Gender = "Male"},
                new Student(){ID = 4, Name = "Pam", Gender = "Female"}
            };

            //Linq Query to Fetch all students with Gender Male
            IQueryable<Student> MethodSyntax = studentList.AsQueryable()
                                .Where(std => std.Gender == "Male");

            //Iterate through the collection
            foreach (var student in MethodSyntax)
            {
                Console.WriteLine( $"ID : {student.ID}  Name : {student.Name}");
            }

            Console.ReadKey();
        }
    }

    public class Student
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public string Gender { get; set; }
    }
}
#+end_src
** DONE Differences between ~IEnumerable~ and ~IQueryable~
The ~IEnumerable~ and ~IQueryable~ are used to hold a collection of data and also used to
perform data manipulation operations such as filtering, Ordering, Grouping, etc.

[[file:LINQ_in_Depth/2022-03-14_00-56-04_screenshot.png]]


Here in this demo, we will create a console application that will retrieve the data from the
SQL Server database using Entity Framework database first approach. We are going to fetch
the following Student information from the Student table.


[[file:LINQ_in_Depth/2022-03-14_00-57-20_c-users-pranaya-pictures-student-data-png.png]]


Here is my scheme:
#+begin_src sql
-- Create the required Student table
CREATE TABLE Student
(
     ID INT PRIMARY KEY,
     FirstName VARCHAR(50),
     LastName VARCHAR(50),
     Gender VARCHAR(50)
)
GO

-- Insert the required test data
INSERT INTO Student VALUES (101, 'Steve', 'Smith', 'Male')
INSERT INTO Student VALUES (102, 'Sara', 'Pound', 'Female')
INSERT INTO Student VALUES (103, 'Ben', 'Stokes', 'Male')
INSERT INTO Student VALUES (104, 'Jos', 'Butler', 'Male')
INSERT INTO Student VALUES (105, 'Pam', 'Semi', 'Female')
GO
#+end_src

Let us modify the Program class as shown below.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            StudentDBContext dBContext = new StudentDBContext();
            IEnumerable<Student> listStudents = dBContext.Students.Where(x => x.Gender == "Male");
            listStudents = listStudents.Take(2);

            foreach(var std in listStudents)
            {
                Console.WriteLine(std.FirstName + " " + std.LastName);
            }

            Console.ReadKey();
        }
    }
}
#+end_src

Here we create the LINQ Query using ~IEnumerable~. Please use SQL Profiler to log the SQL
Script. Now run the application and you will see the following SQL Script is generated and
executed.

#+begin_src sql
SELECT
    [Extent1].[ID] AS [ID],
    [Extent1].[FirstName] AS [FirstName],
    [Extent1].[LastName] AS [LastName],
    [Extent1].[Gender] AS [Gender]
    FROM [dbo].[Student] AS [Extent1]
    WHERE 'Male' = [Extent1].[Gender]
#+end_src

As shown in the above SQL Script, it will not use the TOP clause. So here it will fetch the
data from SQL Server to in-memory and then it will filter the data.

Let's check it again using ~IQuerable~:

#+begin_src csharp
using System;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            StudentDBContext dBContext = new StudentDBContext();
            IQueryable<Student> listStudents = dBContext.Students
                                .AsQueryable()
                                .Where(x => x.Gender == "Male");
            listStudents = listStudents.Take(2);

            foreach(var std in listStudents)
            {
                Console.WriteLine(std.FirstName + " " + std.LastName);
            }

            Console.ReadKey();
        }
    }
}
#+end_src

Check the SQL Script:
#+begin_src sql
SELECT TOP (2)
    [Extent1].[ID] AS [ID],
    [Extent1].[FirstName] AS [FirstName],
    [Extent1].[LastName] AS [LastName],
    [Extent1].[Gender] AS [Gender]
    FROM [dbo].[Student] AS [Extent1]
    WHERE 'Male' = [Extent1].[Gender]
#+end_src

As you can see it includes the TOP clause in the SQL Script and then fetches the data from
the database.

*Main differences:*

| ~IEnumerable~                                                                                                                                                                                                                                 | ~IQuerable~                                                                                                                                                                     |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *While querying the data from the database, the ~IEnumerable~ executes the “select statement” on the server-side (i.e. on the database), loads data into memory on the client-side, and then only applied the filters on the retrieved data.* | While querying the data from a database, the ~IQueryable~ executes the “select query” with the applied filter on the server-side i.e. on the database, and then retrieves data. |
| So you need to use the ~IEnumerable~ when you need to query the data from in-memory collections like List, Array, and so on.                                                                                                                  | So you need to use the ~IQueryable~ when you want to query the data from out-memory such as remote database, service, etc.                                                      |
| The ~IEnumerable~ is mostly used for LINQ to Object and LINQ to XML queries.                                                                                                                                                                  | ~IQueryable~ is mostly used for LINQ to SQL and LINQ to Entities queries.                                                                                                       |
| The ~IEnumerable~ collection is of type forward only. That means it can only move in forward, it can’t move backward and between the items.                                                                                                   | The collection of type IQueryable can move only forward, it can’t move backward and between the items.                                                                          |
| ~IEnumerable~ supports deferred execution.                                                                                                                                                                                                    | ~IQueryable~ supports deferred execution.                                                                                                                                       |
| It doesn’t support custom queries.                                                                                                                                                                                                            | It also supports custom queries using ~CreateQuery~ and Executes methods.                                                                                                        |
| The ~IEnumerable~ doesn’t support lazy loading. Hence, it is not suitable for paging like scenarios.                                                                                                                                          | ~IQueryable~ supports lazy loading and hence it is suitable for paging like scenarios.                                                                                            |

** DONE ~OfType~
The ~OfType~ Operator in LINQ is used to filter specific type data from a data source based on
the data type we passed to this operator. For example, if we have a collection that stores
both integer and string values and if we need to fetch either only the integer values or
only the string values from that collection then we need to use the ~OfType~ operator.


#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<object> dataSource = new List<object>()
            {
                "Tom", "Mary", 50, "Prince", "Jack", 10, 20, 30, 40, "James"
            };

            List<int> intData = dataSource.OfType<int>().ToList();

            foreach (int number in intData)
            {
                Console.Write(number + " ");
            }

            Console.ReadKey();
        }
    }
}
#+end_src

In querying syntax:
#+begin_src csharp
            var stringData = (from name in dataSource
                           where name is string
                           select name).ToList();
#+end_src
** DONE ~Distinct~
The LINQ Distinct Method in C# is used to return the distinct elements from a single data
source.

The one and the only difference between these two methods is the second overloaded version
takes an ~IEqualityComparer~ as input that means the Distinct Operator can also be used with
Comparer also. If this is not clear at the moment, don’t worry we will cover the use of the
Comparer in this article also.


#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> intCollection = new List<int>()
            {
                1,2,3,2,3,4,4,5,6,3,4,5
            };

            //Using Method Syntax
            var MS = intCollection.Distinct();

            //Using Query Syntax
            var QS = (from num in intCollection
                      select num).Distinct();
            foreach (var item in MS)
            {
                Console.WriteLine(item);
            }

            Console.ReadKey();
        }
    }
}
#+end_src

** DONE ~Except~
The LINQ Except Method in C# is used to return the elements which are present in the first data source but not in the second data source.
#+begin_src csharp
using System;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> dataSource1 = new List<int>() { 1, 2, 3, 4, 5, 6 };
            List<int> dataSource2 = new List<int>() { 1, 3, 5, 8, 9, 10 };

            //Method Syntax
            var MS = dataSource1.Except(dataSource2).ToList();

            //Query Syntax
            var QS = (from num in dataSource1
                      select num)
                      .Except(dataSource2).ToList();

            foreach (var item in QS)
            {
                Console.WriteLine(item);
            }

            Console.ReadKey();
        }
    }
}
#+end_src
** DONE ~Intersect~
The LINQ Intersect Method in C# is used to return the common elements from both the
collections. The elements that are present in both the data sources.

The one and the only difference between the above two LINQ Intersect methods is that the
second overloaded version takes IEqualityComparer as an argument. That means the Intersect
Method is also used for Comparer.

#+begin_src csharp
using System.Collections.Generic;
using System;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> dataSource1 = new List<int>() { 1, 2, 3, 4, 5, 6 };
            List<int> dataSource2 = new List<int>() { 1, 3, 5, 8, 9, 10 };

            //Method Syntax
            var MS = dataSource1.Intersect(dataSource2).ToList();

            //Query Syntax
            var QS = (from num in dataSource1
                      select num)
                      .Intersect(dataSource2).ToList();

            foreach (var item in MS)
            {
                Console.WriteLine(item);
            }

            Console.ReadKey();
        }
    }
}
#+end_src

** DONE ~Union~
The LINQ Union Method in C# is used to combine the multiple data sources into one data
source by removing the duplicate elements.

#+begin_src csharp
using System.Collections.Generic;
using System;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> dataSource1 = new List<int>() { 1, 2, 3, 4, 5, 6 };
            List<int> dataSource2 = new List<int>() { 1, 3, 5, 8, 9, 10 };

            //Method Syntax
            var MS = dataSource1.Union(dataSource2).ToList();

            //Query Syntax
            var QS = (from num in dataSource1
                      select num)
                      .Union(dataSource2).ToList();

            foreach (var item in MS)
            {
                Console.WriteLine(item);
            }

            Console.ReadKey();
        }
    }
}
#+end_src
** DONE ~SelectMany~
The ~SelectMany~ in LINQ is used to project each element of a sequence to an IEnumerable<T>
and then flatten the resulting sequences into one sequence. That means the ~SelectMany~
operator combines the records from a sequence of results and then converts it into one
result. If this is not clear at the moment, then don’t worry we will see it in practice.

#+begin_src csharp
List<string> nameList =new List<string>(){"Pranaya", "Kumar" }; IEnumerable<char>
methodSyntax = nameList.SelectMany(x => x); foreach(char c in methodSyntax) {
Console.Write(c + " "); } #+end_src

#+RESULTS:
: P r a n a y a K u m a r

** DONE ~Concat~
The Linq Concat Method in C# is used to concatenate two sequences into one sequence.
#+begin_src csharp
using System.Linq;
using System;
using System.Collections.Generic;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> sequence1 = new List<int> { 1, 2, 3, 4 };
            List<int> sequence2 = new List<int> { 2, 4, 6, 8 };

            var result = sequence1.Concat(sequence2);

            foreach (var item in result)
            {
                Console.WriteLine(item);
            }

            Console.ReadLine();
        }
    }
}
#+end_src
** DONE ~OrderBy~
The Linq OrderBy method in C# is used to sort the data in ascending order. The most
important point that you need to keep in mind is this method is not going to change the data
rather it is just changing the order of the data.

You can use the OrderBy method on any data type i.e. you can use character, string, decimal,
integer, etc. Let us understand the use of the LINQ OrderBy method in C# using both query
syntax and method syntax.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> intList = new List<int>() { 10, 45, 35, 29, 100, 69, 58, 50 };

            Console.WriteLine("Before Sorting : ");
            foreach (var item in intList)
            {
                Console.Write(item + " ");
            }

            //Sorting the data in Ascending Order
            //Using Method Syntax
            var MS = intList.OrderBy(num => num);

            //Using Query Syntax
            var QS = (from num in intList
                      orderby num
                      select num).ToList();

            Console.WriteLine();
            Console.WriteLine("After Sorting : ");
            foreach (var item in QS)
            {
                Console.Write(item + " ");
            }

            Console.ReadKey();
        }
    }
}
#+end_src
** DONE ~OrderByDescending~
The LINQ OrderByDescending method in C# is used to sort the data in descending order. The
point that you need to remember is, the OrderByDescending method is not going to change the
data, it is just changing the order of the data.

Like the OrderBy method, you can also use the OrderByDescending method on any data type such
as string, character, float, integer, etc. Let us understand how to use the
OrderByDescending method in C# using both query and method syntax.


#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> intList = new List<int>() { 10, 45, 35, 29, 100, 69, 58, 50 };

            Console.WriteLine("Before Sorting the Data: ");
            foreach (var item in intList)
            {
                Console.Write(item + " ");
            }

            //Sorting the data in Descending Order
            //Using Method Syntax
            var MS = intList.OrderByDescending(num => num);

            //Using Query Syntax
            var QS = (from num in intList
                      orderby num descending
                      select num).ToList();

            Console.WriteLine();
            Console.WriteLine("After Sorting the Data in Descending Order: ");
            foreach (var item in QS)
            {
                Console.Write(item + " ");
            }

            Console.ReadKey();
        }
    }
}
#+end_src

** DONE ~ThenBy~ and ~ThenByDescending~
The LINQ OrderBy or OrderByDescending method works fine when you want to sort the data based
on a single value or a single expression. But if you want to sort the data based on multiple
values or multiple expressions then you need to use the LINQ ~ThenBy~ and ~ThenByDescending~
Method along with ~OrderBy~ or ~OrderByDescending~ Method.

The Linq ThenBy Method in C# is
used to sort the data in ascending order from the second level onwards. On the other hand,
the  Linq ~ThenByDescending~ Method in C# is used to sort the data in descending order also
from the second level onwards.

These two methods are used along with OrderBy or OrderByDescending method. You can use the
ThenBy or ThenByDescending method more than once in the same LINQ query.

The OrderBy or OrderByDescending method is generally used for primary sorting. ThenBy or
ThenByDescending are used for secondary sorting and so on. For example, first, sort the
student by First Name and then sort the student by the Last Name.


#+begin_src csharp
using System.Collections.Generic;
using System;
using System.Linq;
namespace LINQDemo
{
    public class Student
    {
        public int ID { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Branch { get; set; }

        public static List<Student> GetAllStudents()
        {
            List<Student> listStudents = new List<Student>()
            {
                new Student{ID= 101,FirstName = "Preety",LastName = "Tiwary",Branch = "CSE"},
                new Student{ID= 102,FirstName = "Preety",LastName = "Agrawal",Branch = "ETC"},
                new Student{ID= 103,FirstName = "Priyanka",LastName = "Dewangan",Branch = "ETC"},
                new Student{ID= 104,FirstName = "Hina",LastName = "Sharma",Branch = "ETC"},
                new Student{ID= 105,FirstName = "Anugrag",LastName = "Mohanty",Branch = "CSE"},
                new Student{ID= 106,FirstName = "Anurag",LastName = "Sharma",Branch = "CSE"},
                new Student{ID= 107,FirstName = "Pranaya",LastName = "Kumar",Branch = "CSE"},
                new Student{ID= 108,FirstName = "Manoj",LastName = "Kumar",Branch = "ETC"},
                new Student{ID= 109,FirstName = "Pranaya",LastName = "Rout",Branch = "ETC"},
                new Student{ID= 110,FirstName = "Saurav",LastName = "Rout",Branch = "CSE"}
            };

            return listStudents;
        }
    }
}

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //Method Syntax
            var MS = Student.GetAllStudents()
                              .OrderBy(x => x.FirstName)
                              .ThenBy(y => y.LastName)
                              .ToList();

            foreach (var student in MS)
            {
                Console.WriteLine( "First Name :" + student.FirstName + ", Last Name : " + student.LastName);
            }

            Console.ReadKey();
        }
    }
}

#+end_src

** DONE ~Reverse~
The LINQ Reverse method is used to reverse the data stored in a data source. That means this
method will not change the data rather it simple reverse the data stored in the data source.
So, as a result, we will get the output in reverse order.

The Reverse Method is implemented in two different namespaces such as System.LInq and
System.Collections.Generic namespaces.

#+begin_src csharp
using System.Collections.Generic;
using System;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] intArray = new int[] { 10, 30, 50, 40,60,20,70,100 };
            Console.WriteLine("Before Reverse the Data");
            foreach (var number in intArray)
            {
                Console.Write(number + " ");
            }
            Console.WriteLine();

            IEnumerable<int> ArrayReversedData = intArray.Reverse();
            Console.WriteLine("After Reverse the Data");
            foreach (var number in ArrayReversedData)
            {
                Console.Write(number + " ");
            }

            Console.ReadKey();
        }
    }
}
#+end_src


** DONE ~Aggregate~
The Linq Aggregate extension method performs an accumulative operation.
#+begin_src csharp
using System;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] skills = { "C#.NET", "MVC", "WCF", "SQL", "LINQ", "ASP.NET" };

            string result = skills.Aggregate((s1, s2) => s1 + ", " + s2);

            Console.WriteLine(result);
            Console.ReadKey();
        }
    }
}
#+end_src
** DONE ~All~
The Linq All Operator in C# is used to check whether all the elements of a data source
satisfy a given condition or not. If all the elements satisfy the condition, then it returns
true else return false.

#+begin_src csharp
using System;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] IntArray = { 11, 22, 33, 44, 55 };
            var Result = IntArray.All(x => x > 10);
            Console.WriteLine("Is All Numbers are greater than 10 : " + Result);
            Console.ReadKey();
        }
    }
}
#+end_src

** DONE ~Any~
The C# Linq Any Operator is used to check whether at least one of the elements of a data
source satisfies a given condition or not. If any of the elements satisfy the given
condition, then it returns true else return false.

It is also used to check whether a collection contains some data or not. That means it
checks the length of the collection also. If it contains any data then it returns true else
return false.


#+begin_src csharp
using System;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] IntArray = { 11, 22, 33, 44, 55 };

            //Using Method Syntax
            var ResultMS = IntArray.Any();

            //Using Query Syntax
            var ResultQS = (from num in IntArray
                            select num).Any();

            Console.WriteLine("Is there any element in the collection : " + ResultMS);
            Console.ReadKey();
        }
    }
}
#+end_src
** DONE ~Contains~
The Linq Contains Method in C# is used to check whether a sequence or collection (i.e. data
source) contains a specified element or not. If the data source contains the specified
element, then it returns true else return false.
#+begin_src csharp
using System;
using System.Linq;
namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] IntArray = { 11, 22, 33, 44, 55 };

            //Using Method Syntax
            var IsExistsMS = IntArray.Contains(33);

            //Using Query Syntax
            var IsExistsQS = (from num in IntArray
                              select num).Contains(33);

            Console.WriteLine(IsExistsMS);
            Console.ReadKey();
        }
    }
}
#+end_src

** DONE ~Contains~ or ~Any~?
~Contains~ takes an object, ~Any~ takes a predicate.

Contains:
#+begin_src csharp
listOFInts.Contains(1);
#+end_src
Any:
#+begin_src csharp
listOfInts.Any(i => i == 1);
listOfInts.Any(i => i % 2 == 0); // Check if any element is an Even Number
#+end_src

** DONE ~GroupBy~
The Linq GroupBy in C# belongs to the Grouping Operators category and exactly does the same
thing as the Group By clause does in SQL Query. This method takes a flat sequence of
elements and then organizes the elements into groups (i.e. ~IGrouping<TKey, TSource>~) based
on a given key.

If you go the definition of ~GroupBy~ method then you will see that it return an
~IEnumerable<IGrouping<TKey, TSource>>~ where TKey is nothing but the Key value on which the
grouping has been formed and ~TSource~ is the collection of elements that matches the grouping
key value.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace GroupByDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //Using Method Syntax
            var GroupByMS = Student.GetStudents().GroupBy(s => s.Barnch);

            //Using Query Syntax
            IEnumerable<IGrouping<string, Student>> GroupByQS = (from std in Student.GetStudents()
                             group std by std.Barnch);

            //It will iterate through each groups
            foreach(var group in GroupByMS)
            {
                Console.WriteLine(group.Key +" : " + group.Count());

                //Iterate through each student of a group
                foreach(var student in group)
                {
                    Console.WriteLine("  Name :" + student.Name + ", Age: " + student.Age + ", Gender :" + student.Gender);
                }
            }

            Console.Read();
        }
    }
}
#+end_src

** DONE ~Zip~
The Linq Zip Method in C# is used to apply a specified function to the corresponding
elements of two sequences and producing a sequence of the results.

#+begin_src csharp
using System;
using System.Linq;
int[] numbersSequence = { 10, 20, 30, 40, 50 };
string[] wordsSequence = { "Ten", "Twenty", "Thirty", "Fourty" };
var resultSequence = numbersSequence.Zip(wordsSequence, (first, second) => first + " - " + second);
foreach (var item in resultSequence)
{
    Console.WriteLine(item);
}
#+end_src

#+RESULTS:
| 10  -  Ten    |
| 20  -  Twenty |
| 30  -  Thirty |
| 40  -  Fourty |

** TODO ~GroupBy~ By Multiple Keys
** DONE Deferred Execution vs Immediate Execution
The LINQ queries are executed in two different ways as follows.

- Deferred execution
- Immediate execution

Based on the above two types of execution, the LINQ operators are divided into 2 categories.
They are as follows:

1. Deferred or Lazy Operators:  These query operators are used for deferred execution. For example – ~select~, ~SelectMany~, ~where~, ~Take~, ~Skip~, etc. are belongs to Deferred or Lazy Operators category.
2. Immediate or Greedy Operators: These query operators are used for immediate execution. For Example – ~count~, ~average~, ~min~, ~max~, ~First~, ~Last~, ~ToArray~, ~ToList~, etc. are belongs to the Immediate or Greedy Operators category.


*** Deferred Execution

In this case, the LINQ Query is not executed at the point of its declaration. That means,
when we write a LINQ query, it doesn’t execute by itself. It executes only when we access
the query results. So, here the execution of the query is deferred until the query variable
is iterated over using for each loop.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int Salary { get; set; }
    }

    class Program
    {
        public static void Main()
        {
            List<Employee> listEmployees = new List<Employee>
            {
                new Employee { ID= 1001, Name = "Priyanka", Salary = 80000 },
                new Employee { ID= 1002, Name = "Anurag", Salary = 90000 },
                new Employee { ID= 1003, Name = "Preety", Salary = 80000 }
            };

            // In the below statement the LINQ Query is only defined and not executed
            // If the query is executed here, then the result should not display Santosh
            IEnumerable<Employee> result = from emp in listEmployees
                                           where emp.Salary == 80000
                                           select emp;

            // Adding a new employee with Salary = 80000 to the collection listEmployees
            listEmployees.Add(new Employee { ID = 1004, Name = "Santosh", Salary = 80000 });

            // The LINQ query is actually executed when we iterate thru using a for each loop
            // This is proved because Santosh is also included in the result
            foreach (Employee emp in result)
            {
                Console.WriteLine($" {emp.ID} {emp.Name} {emp.Salary}");
            }
            Console.ReadKey();
        }
    }
}
#+end_src

We will get the following advantages

1. It avoids unnecessary query execution which improves the performance of the application.
2. The Query creation and the Query execution are decoupled which provide us the flexibility to create the query in several steps.
3. A Linq deferred execution query is always re-evaluated when we re-enumerate. As a result, we always get the updated data.

In the case of Immediate Execution, the LINQ query is executed at the point of its
declaration. So, it forces the query to execute and gets the result immediately. Let us
see an example for a better understanding. The following example is self-explained. So,
please go through the comment lines.


*** Immediate Execution
In the case of Immediate Execution, the LINQ query is executed at the point of its
declaration. So, it forces the query to execute and gets the result immediately. Let us see
an example for a better understanding. The following example is self-explained. So, please
go through the comment lines.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int Salary { get; set; }
    }

    class Program
    {
        public static void Main()
        {
            List<Employee> listEmployees = new List<Employee>
            {
                new Employee { ID= 1001, Name = "Priyanka", Salary = 80000 },
                new Employee { ID= 1002, Name = "Anurag", Salary = 90000 },
                new Employee { ID= 1003, Name = "Preety", Salary = 80000 }
            };

            // In the following statement, the LINQ Query is executed immediately as we are
            // Using the ToList() method which is a greedy operator which forces the query
            // to be executed immediately
            IEnumerable<Employee> result = (from emp in listEmployees
                                           where emp.Salary == 80000
                                           select emp).ToList();

            // Adding a new employee with Salary = 80000 to the collection listEmployees
            // will not have any effect on the result as the query is already executed
            listEmployees.Add(new Employee { ID = 1004, Name = "Santosh", Salary = 80000 });

            // The above LINQ query is executed at the time of its creation.
            // This is proved because Santosh is not included in the result
            foreach (Employee emp in result)
            {
                Console.WriteLine($" {emp.ID} {emp.Name} {emp.Salary}");
            }

            Console.ReadKey();
        }
    }
}
#+end_src

** DONE ~ToLookup~
The Linq ~ToLookup~ Method in C# exactly does the same thing as the ~GroupBy~ Operator does in
Linq. The only difference between these two methods is the GroupBy method uses deferred
execution whereas the execution of the ~ToLookup~ method is immediate.
#+begin_src csharp
using System;
using System.Linq;

namespace GroupByDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //Using Method Syntax
            var GroupByMS = Student.GetStudents().ToLookup(s => s.Barnch);

            //Using Query Syntax
            var GroupByQS = (from std in Student.GetStudents()
                             select std).ToLookup(x => x.Barnch);

            //It will iterate through each group
            foreach (var group in GroupByMS)
            {
                Console.WriteLine(group.Key + " : " + group.Count());

                //Iterate through each student of a group
                foreach (var student in group)
                {
                    Console.WriteLine("  Name :" + student.Name + ", Age: " + student.Age + ", Gender :" + student.Gender);
                }
            }

            Console.Read();
        }
    }
}
#+end_src
** TODO Inner Join
** TODO Join with Multiple Data Sources
** TODO Group Join
** TODO Left Join
** TODO Cross Join
** TODO Element Operators
** TODO ~ElementAt~ and ~ElementAtOrDefault~
** TODO ~First~ and ~FirstOrDefault~
** TODO ~Last~ and ~LastOrDefault~
** TODO ~Single~ and ~SingleOrDefault~
** TODO ~DefaultIfEmpty~
** TODO ~SequenceEqual~
** TODO ~Partitioning~
** TODO ~Take~
** TODO ~TakeWhile~
** TODO ~Skip~
** TODO ~SkipWhile~
** TODO Paging Using Skip and Take
** TODO ~Range~
** TODO ~Repeat~
** TODO ~Empty~
** TODO ~Append~
** TODO ~Prepend~
** TODO ~ToList~ and ~ToArray~
** TODO ~ToDictionary~
** TODO Cast Operator
** TODO Difference between Cast and OfType Operators
