#+TITLE: STD Notes
#+hugo_tags: "Computer Science" "C++"
* C/STD Notes
** Sorting
*** Sorting Custom Objects
You can sort array of custom objects using the ~std::sort~ like this:
#+begin_src cpp
struct MyStruct
{
    int key;
    std::string stringValue;

    MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}
};

struct less_than_key
{
    inline bool operator() (const MyStruct& struct1, const MyStruct& struct2)
    {
        return (struct1.key < struct2.key);
    }
};

std::vector < MyStruct > vec;

vec.push_back(MyStruct(4, "test"));
vec.push_back(MyStruct(3, "a"));
vec.push_back(MyStruct(2, "is"));
vec.push_back(MyStruct(1, "this"));

std::sort(vec.begin(), vec.end(), less_than_key());

#+end_src
Also, since C++14 you can write an embedded functions inside the sort function:
#+begin_src cpp
#include <vector>
#include <algorithm>

using namespace std;

vector< MyStruct > values;

sort( values.begin( ), values.end( ), [ ]( const auto& lhs, const auto& rhs )
{
   return lhs.key < rhs.key;
});
#+end_src
*** Sorting Descending
#+begin_src cpp
sort(begin, end, greater<int>());
#+end_src
*** When to return 1 in compare function
-1 = means point 1 should come before point 2
+1 = means point 2 should come before point 1
 0 = means they r equal
** Numbers
*** Check If Prime Number
#+begin_src C
bool isPrimeNumber(int n) {
   if (n <= 1) return false;
   if (n <= 3) return true;
   if (n%2 == 0 || n%3 == 0) return false;
   for (int i=5; i*i<=n; i=i+6)
      if (n%i == 0 || n%(i+2) == 0)
         return false;
   return true;
}
#+end_src
*** Greater Common Divisor
#+begin_src cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
	cout << __gcd(6, 20) << endl;
}

#+end_src

#+RESULTS:
: 2

** ~for_each~
https://en.cppreference.com/w/cpp/algorithm/for_each
#+begin_src cpp
#include <vector>
#include <algorithm>
#include <iostream>

struct Sum
{
    void operator()(int n) { sum += n; }
    int sum{0};
};

int main()
{
    std::vector<int> nums{3, 4, 2, 8, 15, 267};

    auto print = [](const int& n) { std::cout << " " << n; };

    std::cout << "before:";
    std::for_each(nums.cbegin(), nums.cend(), print);
    std::cout << '\n';

    std::for_each(nums.begin(), nums.end(), [](int &n){ n++; });

    // calls Sum::operator() for each number
    Sum s = std::for_each(nums.begin(), nums.end(), Sum());

    std::cout << "after: ";
    std::for_each(nums.cbegin(), nums.cend(), print);
    std::cout << '\n';
    std::cout << "sum: " << s.sum << '\n';
}
#+end_src

** Other
*** Get Intersections
#+begin_src cpp
#include <iostream>     // std::cout
#include <algorithm>    // std::set_intersection, std::sort
#include <vector>       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector<int> v(10);                      // 0  0  0  0  0  0  0  0  0  0
  std::vector<int>::iterator it;

  std::sort (first,first+5);     //  5 10 15 20 25
  std::sort (second,second+5);   // 10 20 30 40 50

  it=std::set_intersection (first, first+5, second, second+5, v.begin());
                                               // 10 20 0  0  0  0  0  0  0  0
  v.resize(it-v.begin());                      // 10 20

  std::cout << "The intersection has " << (v.size()) << " elements:\n";
  for (it=v.begin(); it!=v.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
#+end_src

#+RESULTS:
| The | intersection | has | 2 | elements: |
|  10 |           20 |     |   |           |

** Lambda
Basic syntax:
#+begin_src
[ capture clause ] (parameters) -> return-type
{
   definition of method
}
#+end_src
Basic example:
#+begin_src C++
int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int f = accumulate(arr, arr + 10, 1, [](int i, int j)
    {
        return i * j;
    });
    cout << "Factorial of 10 is : " << f << endl;
}
#+end_src

Capturing methods:
   -  [&] : capture all external variable by reference
   -  [=] : capture all external variable by value
   -  [a, &b] : capture a by value and b by reference

Explicitly specifying a return type using ~ -> T ~:
#+begin_src C++
void func4(std::vector<double>& v) {
    std::transform(v.begin(), v.end(), v.begin(),
        [](double d) -> double {
            if (d < 0.0001) {
                return 0;
            } else {
                return d;
            }
        });
}

#+end_src

** Strings
Get all substrings
#+begin_src c++
void subString(string str, int n) {
  for (int len = 1; len <= n; len++) {
    for (int i = 0; i <= n - len; i++) {
      int j = i + len - 1;
      cout << str.substr(i, n - j);
      cout << endl;
    }
  }
}
#+end_src
** String/Char to int in C(++)
#+begin_src cpp
#include <sstream>
#include <iostream>
using namespace std;

int main() {
    string s = "12345";
    stringstream geek(s);
    int x = 0;
    geek >> x;
    cout << "Value of x : " << x;
}
#+end_src
#+RESULTS:
: Value of x : 12345
*** Using ~stoi()~
#+begin_src cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string str1 = "45";
    string str2 = "3.14159";
    string str3 = "31337 geek";

    int myint1 = stoi(str1);
    int myint2 = stoi(str2);
    int myint3 = stoi(str3);

    cout << "stoi(\"" << str1 << "\") is "
         << myint1 << '\n';
    cout << "stoi(\"" << str2 << "\") is "
         << myint2 << '\n';
    cout << "stoi(\"" << str3 << "\") is "
         << myint3 << '\n';

    return 0;
}
#+end_src
*** Using ~atoi()~
#+begin_src c++
#include <cstdlib>
#include <iostream>
using namespace std;

int main()
{
    const char* str1 = "42";
    const char* str2 = "3.14159";
    const char* str3 = "31337 geek";

    int num1 = atoi(str1);
    int num2 = atoi(str2);
    int num3 = atoi(str3);

    cout << "atoi(\"" << str1 << "\") is " << num1 << '\n';
    cout << "atoi(\"" << str2 << "\") is " << num2 << '\n';
    cout << "atoi(\"" << str3 << "\") is " << num3 << '\n';

    return 0;

#+end_src
*** Which one to use?
I find std::atoi() a horrible function: It returns zero on error. If you consider zero as a
valid input, then you cannot tell whether there was an error during the conversion or the
input was zero. That's just bad.

If you don't care about correctness or you know for sure that you won't have zero as input
or you consider that an error anyway, then, perhaps the C functions might be faster
(probably due to the lack of exception handling). It depends on your compiler, your standard
library implementation, your hardware, your input, etc. The best way is to measure it.
However, I suspect that the difference, if any, is negligible.

*** Using char asci
#+begin_src c
char a = '4';
int ia = a - '0';
#+end_src

** Multiplay all elements of vector with n
#+begin_src c++
std::transform(myv1.begin(), myv1.end(), myv1.begin(),
               std::bind(std::multiplies<T>(), std::placeholders::_1, n));
#+end_src

** Extract Vector
#+begin_src csharp
vector<T>::const_iterator first = myVec.begin() + 100000;
vector<T>::const_iterator last = myVec.begin() + 101000;
vector<T> newVec(first, last);
#+end_src

* C# Notes
** Get a Random Set of String
#+begin_src csharp
public static string RandomString(int length)
{
    const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    return new string(Enumerable.Repeat(chars, length)
        .Select(s => s[random.Next(s.Length)]).ToArray());
}
#+end_src
