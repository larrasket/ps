#+TITLE: STD Notes
#+hugo_tags: "Computer Science" "C++"
* C/STD Notes
** Sorting
*** Sorting Custom Objects
You can sort array of custom objects using the ~std::sort~ like this:
#+begin_src cpp
struct MyStruct
{
    int key;
    std::string stringValue;

    MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}
};

struct less_than_key
{
    inline bool operator() (const MyStruct& struct1, const MyStruct& struct2)
    {
        return (struct1.key < struct2.key);
    }
};

std::vector < MyStruct > vec;

vec.push_back(MyStruct(4, "test"));
vec.push_back(MyStruct(3, "a"));
vec.push_back(MyStruct(2, "is"));
vec.push_back(MyStruct(1, "this"));

std::sort(vec.begin(), vec.end(), less_than_key());

#+end_src

#+RESULTS:

Also, since C++14 you can write an embedded functions inside the sort function:
#+begin_src cpp
#include <vector>
#include <algorithm>

using namespace std;

vector< MyStruct > values;

sort( values.begin( ), values.end( ), [ ]( const auto& lhs, const auto& rhs )
{
   return lhs.key < rhs.key;
});
#+end_src
*** Sorting Descending
#+begin_src cpp
sort(begin, end, greater<int>());
#+end_src
*** When to return 1 in compare function
-1 = means point 1 should come before point 2
+1 = means point 2 should come before point 1
 0 = means they r equal
** Numbers
*** Check If Prime Number
#+begin_src C
bool isPrimeNumber(int n) {
   if (n <= 1) return false;
   if (n <= 3) return true;
   if (n%2 == 0 || n%3 == 0) return false;
   for (int i=5; i*i<=n; i=i+6)
      if (n%i == 0 || n%(i+2) == 0)
         return false;
   return true;
}
#+end_src
*** Greater Common Divisor
#+begin_src cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
	cout << __gcd(6, 20) << endl;
}

#+end_src

#+RESULTS:
: 2

** ~for_each~
https://en.cppreference.com/w/cpp/algorithm/for_each
#+begin_src cpp
#include <vector>
#include <algorithm>
#include <iostream>

struct Sum
{
    void operator()(int n) { sum += n; }
    int sum{0};
};

int main()
{
    std::vector<int> nums{3, 4, 2, 8, 15, 267};

    auto print = [](const int& n) { std::cout << " " << n; };

    std::cout << "before:";
    std::for_each(nums.cbegin(), nums.cend(), print);
    std::cout << '\n';

    std::for_each(nums.begin(), nums.end(), [](int &n){ n++; });

    // calls Sum::operator() for each number
    Sum s = std::for_each(nums.begin(), nums.end(), Sum());

    std::cout << "after: ";
    std::for_each(nums.cbegin(), nums.cend(), print);
    std::cout << '\n';
    std::cout << "sum: " << s.sum << '\n';
}
#+end_src

** Other
*** Get Intersections
#+begin_src cpp
#include <iostream>     // std::cout
#include <algorithm>    // std::set_intersection, std::sort
#include <vector>       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector<int> v(10);                      // 0  0  0  0  0  0  0  0  0  0
  std::vector<int>::iterator it;

  std::sort (first,first+5);     //  5 10 15 20 25
  std::sort (second,second+5);   // 10 20 30 40 50

  it=std::set_intersection (first, first+5, second, second+5, v.begin());
                                               // 10 20 0  0  0  0  0  0  0  0
  v.resize(it-v.begin());                      // 10 20

  std::cout << "The intersection has " << (v.size()) << " elements:\n";
  for (it=v.begin(); it!=v.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
#+end_src

#+RESULTS:
| The | intersection | has | 2 | elements: |
|  10 |           20 |     |   |           |

** Lambda
Basic syntax:
#+begin_src
[ capture clause ] (parameters) -> return-type
{
   definition of method
}
#+end_src
Basic example:
#+begin_src C++
int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int f = accumulate(arr, arr + 10, 1, [](int i, int j)
    {
        return i * j;
    });
    cout << "Factorial of 10 is : " << f << endl;
}
#+end_src

Capturing methods:
   -  [&] : capture all external variable by reference
   -  [=] : capture all external variable by value
   -  [a, &b] : capture a by value and b by reference

Explicitly specifying a return type using ~ -> T ~:
#+begin_src C++
void func4(std::vector<double>& v) {
    std::transform(v.begin(), v.end(), v.begin(),
        [](double d) -> double {
            if (d < 0.0001) {
                return 0;
            } else {
                return d;
            }
        });
}

#+end_src

** Strings
Get all substrings
#+begin_src c++
void subString(string str, int n) {
  for (int len = 1; len <= n; len++) {
    for (int i = 0; i <= n - len; i++) {
      int j = i + len - 1;
      cout << str.substr(i, n - j);
      cout << endl;
    }
  }
}
#+end_src
** String/Char to int in C(++)
#+begin_src cpp
#include <sstream>
#include <iostream>
using namespace std;

int main() {
    string s = "12345";
    stringstream geek(s);
    int x = 0;
    geek >> x;
    cout << "Value of x : " << x;
}
#+end_src
#+RESULTS:
: Value of x : 12345
*** Using ~stoi()~
#+begin_src cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string str1 = "45";
    string str2 = "3.14159";
    string str3 = "31337 geek";

    int myint1 = stoi(str1);
    int myint2 = stoi(str2);
    int myint3 = stoi(str3);

    cout << "stoi(\"" << str1 << "\") is "
         << myint1 << '\n';
    cout << "stoi(\"" << str2 << "\") is "
         << myint2 << '\n';
    cout << "stoi(\"" << str3 << "\") is "
         << myint3 << '\n';

    return 0;
}
#+end_src
*** Using ~atoi()~
#+begin_src c++
#include <cstdlib>
#include <iostream>
using namespace std;

int main()
{
    const char* str1 = "42";
    const char* str2 = "3.14159";
    const char* str3 = "31337 geek";

    int num1 = atoi(str1);
    int num2 = atoi(str2);
    int num3 = atoi(str3);

    cout << "atoi(\"" << str1 << "\") is " << num1 << '\n';
    cout << "atoi(\"" << str2 << "\") is " << num2 << '\n';
    cout << "atoi(\"" << str3 << "\") is " << num3 << '\n';

    return 0;

#+end_src
*** Which one to use?
I find std::atoi() a horrible function: It returns zero on error. If you consider zero as a
valid input, then you cannot tell whether there was an error during the conversion or the
input was zero. That's just bad.

If you don't care about correctness or you know for sure that you won't have zero as input
or you consider that an error anyway, then, perhaps the C functions might be faster
(probably due to the lack of exception handling). It depends on your compiler, your standard
library implementation, your hardware, your input, etc. The best way is to measure it.
However, I suspect that the difference, if any, is negligible.

*** Using char asci
#+begin_src c
char a = '4';
int ia = a - '0';
#+end_src

** Multiplay all elements of vector with n
#+begin_src c++
std::transform(myv1.begin(), myv1.end(), myv1.begin(),
               std::bind(std::multiplies<T>(), std::placeholders::_1, n));
#+end_src

** Extract Vector
#+begin_src csharp
vector<T>::const_iterator first = myVec.begin() + 100000;
vector<T>::const_iterator last = myVec.begin() + 101000;
vector<T> newVec(first, last);
#+end_src

* C# Notes
** Get a Random Set of String
#+begin_src csharp
public static string RandomString(int length)
{
    var random = new Random();
    const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    return new string(Enumerable.Repeat(chars, length)
        .Select(s => s[random.Next(s.Length)]).ToArray());
}
#+end_src
** ~StringWriter~ vs ~StringBuilder~
~StringWriter~ derives from ~TextWriter~, which allows various classes to write text without
caring where it's going. In the case of ~StringWriter~, the output is just into memory. You
would use this if you're calling an API which needs a ~TextWriter~ but you only want to build
up results in memory.

~StringBuilder~ is essentially a buffer which allows you to perform multiple operations
(typically appends) to a "logical string" without creating a new string object each time.
You would use this to construct a string in multiple operations.

** Deferred Execution vs Immediate Execution
The LINQ queries are executed in two different ways as follows.

- Deferred execution
- Immediate execution

Based on the above two types of execution, the LINQ operators are divided into 2 categories.
They are as follows:

1. Deferred or Lazy Operators:  These query operators are used for deferred execution. For example – ~select~, ~SelectMany~, ~where~, ~Take~, ~Skip~, etc. are belongs to Deferred or Lazy Operators category.
2. Immediate or Greedy Operators: These query operators are used for immediate execution. For Example – ~count~, ~average~, ~min~, ~max~, ~First~, ~Last~, ~ToArray~, ~ToList~, etc. are belongs to the Immediate or Greedy Operators category.


*** Deferred Execution

In this case, the LINQ Query is not executed at the point of its declaration. That means,
when we write a LINQ query, it doesn’t execute by itself. It executes only when we access
the query results. So, here the execution of the query is deferred until the query variable
is iterated over using for each loop.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int Salary { get; set; }
    }

    class Program
    {
        public static void Main()
        {
            List<Employee> listEmployees = new List<Employee>
            {
                new Employee { ID= 1001, Name = "Priyanka", Salary = 80000 },
                new Employee { ID= 1002, Name = "Anurag", Salary = 90000 },
                new Employee { ID= 1003, Name = "Preety", Salary = 80000 }
            };

            // In the below statement the LINQ Query is only defined and not executed
            // If the query is executed here, then the result should not display Santosh
            IEnumerable<Employee> result = from emp in listEmployees
                                           where emp.Salary == 80000
                                           select emp;

            // Adding a new employee with Salary = 80000 to the collection listEmployees
            listEmployees.Add(new Employee { ID = 1004, Name = "Santosh", Salary = 80000 });

            // The LINQ query is actually executed when we iterate thru using a for each loop
            // This is proved because Santosh is also included in the result
            foreach (Employee emp in result)
            {
                Console.WriteLine($" {emp.ID} {emp.Name} {emp.Salary}");
            }
            Console.ReadKey();
        }
    }
}
#+end_src

We will get the following advantages

1. It avoids unnecessary query execution which improves the performance of the application.
2. The Query creation and the Query execution are decoupled which provide us the flexibility to create the query in several steps.
3. A Linq deferred execution query is always re-evaluated when we re-enumerate. As a result, we always get the updated data.

In the case of Immediate Execution, the LINQ query is executed at the point of its
declaration. So, it forces the query to execute and gets the result immediately. Let us
see an example for a better understanding. The following example is self-explained. So,
please go through the comment lines.

*** Immediate Execution
In the case of Immediate Execution, the LINQ query is executed at the point of its
declaration. So, it forces the query to execute and gets the result immediately. Let us see
an example for a better understanding. The following example is self-explained. So, please
go through the comment lines.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    public class Employee
    {
        public int ID { get; set; }
        public string Name { get; set; }
        public int Salary { get; set; }
    }

    class Program
    {
        public static void Main()
        {
            List<Employee> listEmployees = new List<Employee>
            {
                new Employee { ID= 1001, Name = "Priyanka", Salary = 80000 },
                new Employee { ID= 1002, Name = "Anurag", Salary = 90000 },
                new Employee { ID= 1003, Name = "Preety", Salary = 80000 }
            };

            // In the following statement, the LINQ Query is executed immediately as we are
            // Using the ToList() method which is a greedy operator which forces the query
            // to be executed immediately
            IEnumerable<Employee> result = (from emp in listEmployees
                                           where emp.Salary == 80000
                                           select emp).ToList();

            // Adding a new employee with Salary = 80000 to the collection listEmployees
            // will not have any effect on the result as the query is already executed
            listEmployees.Add(new Employee { ID = 1004, Name = "Santosh", Salary = 80000 });

            // The above LINQ query is executed at the time of its creation.
            // This is proved because Santosh is not included in the result
            foreach (Employee emp in result)
            {
                Console.WriteLine($" {emp.ID} {emp.Name} {emp.Salary}");
            }

            Console.ReadKey();
        }
    }
}
#+end_src

*** Differences between ~IEnumerable~ and ~IQueryable~
The ~IEnumerable~ and ~IQueryable~ are used to hold a collection of data and also used to
perform data manipulation operations such as filtering, Ordering, Grouping, etc.


Here in this demo, we will create a console application that will retrieve the data from the
SQL Server database using Entity Framework database first approach. We are going to fetch
the following Student information from the Student table.

Here is my scheme:
#+begin_src sql
-- Create the required Student table
CREATE TABLE Student
(
     ID INT PRIMARY KEY,
     FirstName VARCHAR(50),
     LastName VARCHAR(50),
     Gender VARCHAR(50)
)
GO

-- Insert the required test data
INSERT INTO Student VALUES (101, 'Steve', 'Smith', 'Male')
INSERT INTO Student VALUES (102, 'Sara', 'Pound', 'Female')
INSERT INTO Student VALUES (103, 'Ben', 'Stokes', 'Male')
INSERT INTO Student VALUES (104, 'Jos', 'Butler', 'Male')
INSERT INTO Student VALUES (105, 'Pam', 'Semi', 'Female')
GO
#+end_src

Let us modify the Program class as shown below.

#+begin_src csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            StudentDBContext dBContext = new StudentDBContext();
            IEnumerable<Student> listStudents = dBContext.Students.Where(x => x.Gender == "Male");
            listStudents = listStudents.Take(2);

            foreach(var std in listStudents)
            {
                Console.WriteLine(std.FirstName + " " + std.LastName);
            }

            Console.ReadKey();
        }
    }
}
#+end_src

Here we create the LINQ Query using ~IEnumerable~. Please use SQL Profiler to log the SQL
Script. Now run the application and you will see the following SQL Script is generated and
executed.

#+begin_src sql
SELECT
    [Extent1].[ID] AS [ID],
    [Extent1].[FirstName] AS [FirstName],
    [Extent1].[LastName] AS [LastName],
    [Extent1].[Gender] AS [Gender]
    FROM [dbo].[Student] AS [Extent1]
    WHERE 'Male' = [Extent1].[Gender]
#+end_src

As shown in the above SQL Script, it will not use the TOP clause. So here it will fetch the
data from SQL Server to in-memory and then it will filter the data.

Let's check it again using ~IQuerable~:

#+begin_src csharp
using System;
using System.Linq;

namespace LINQDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            StudentDBContext dBContext = new StudentDBContext();
            IQueryable<Student> listStudents = dBContext.Students
                                .AsQueryable()
                                .Where(x => x.Gender == "Male");
            listStudents = listStudents.Take(2);

            foreach(var std in listStudents)
            {
                Console.WriteLine(std.FirstName + " " + std.LastName);
            }

            Console.ReadKey();
        }
    }
}
#+end_src

Check the SQL Script:
#+begin_src sql
SELECT TOP (2)
    [Extent1].[ID] AS [ID],
    [Extent1].[FirstName] AS [FirstName],
    [Extent1].[LastName] AS [LastName],
    [Extent1].[Gender] AS [Gender]
    FROM [dbo].[Student] AS [Extent1]
    WHERE 'Male' = [Extent1].[Gender]
#+end_src

As you can see it includes the TOP clause in the SQL Script and then fetches the data from
the database.

*Main differences:*

| ~IEnumerable~                                                                                                                                                                                                                                 | ~IQuerable~                                                                                                                                                                     |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *While querying the data from the database, the ~IEnumerable~ executes the “select statement” on the server-side (i.e. on the database), loads data into memory on the client-side, and then only applied the filters on the retrieved data.* | While querying the data from a database, the ~IQueryable~ executes the “select query” with the applied filter on the server-side i.e. on the database, and then retrieves data. |
| So you need to use the ~IEnumerable~ when you need to query the data from in-memory collections like List, Array, and so on.                                                                                                                  | So you need to use the ~IQueryable~ when you want to query the data from out-memory such as remote database, service, etc.                                                      |
| The ~IEnumerable~ is mostly used for LINQ to Object and LINQ to XML queries.                                                                                                                                                                  | ~IQueryable~ is mostly used for LINQ to SQL and LINQ to Entities queries.                                                                                                       |
| The ~IEnumerable~ collection is of type forward only. That means it can only move in forward, it can’t move backward and between the items.                                                                                                   | The collection of type IQueryable can move only forward, it can’t move backward and between the items.                                                                          |
| ~IEnumerable~ supports deferred execution.                                                                                                                                                                                                    | ~IQueryable~ supports deferred execution.                                                                                                                                       |
| It doesn’t support custom queries.                                                                                                                                                                                                            | It also supports custom queries using ~CreateQuery~ and Executes methods.                                                                                                       |
| The ~IEnumerable~ doesn’t support lazy loading. Hence, it is not suitable for paging like scenarios.                                                                                                                                          | ~IQueryable~ supports lazy loading and hence it is suitable for paging like scenarios.                                                                                          |

** ~IEnumerable~, ~ICollection~, ~IList~ and ~List~
*** ~IEnumerable~
First of all, it is important to understand, that there are two different interfaces defined
in the .NET base class library. There is a non-generic ~IEnumerable~ interface and there is a
generic type-safe IEnumerable<T> interface.

The ~IEnumerable~ interface is located in the ~System.Collections~ namespace and contains only a
single method definition. The interface definition looks like this:

#+begin_src csharp
public interface IEnumerable
{
  IEnumerator GetEnumerator();
}
#+end_src

The ~GetEnumerator~ method must return an instance of an object of a class which implements
the ~IEnumerator~ interface.

It is important to know that the C# language foreach keyword works with all types that
implement the IEnumerable interface. Only in C# it also works with things that don’t
explicitly implement IEnumerable or ~IEnumerable<T>~. I believe you have been using the
foreach keyword many times and without worrying about the reason why and how it worked with
that type.

*** ~IEnumerable<T>~
Let’s now take a look at the definition of the generic and type-safe version called
~IEnumerable<T>~ which is located in the ~System.Collections.Generic~ namespace:

#+begin_src csharp
public interface IEnumerable<out T> : IEnumerable
{
  IEnumerator<T> GetEnumerator();
}
#+end_src

As you can see the ~IEnumerable<T>~ interface inherits from the IEnumerable interface.
Therefore a type which implements ~IEnumerable<T>~ has also to implement the members of
~IEnumerable~.

~IEnumerable<T>~ defines a single method ~GetEnumerator~ which returns an instance of an object
that implements the ~IEnumerator<T>~ interface.


*** ~ICollection~
As you can imagine, there are also two versions of ICollection which are
~System.Collections.ICollection~ and the generic version
~System.Collections.Generic.ICollection<T>~.

#+begin_src csharp
public interface ICollection : IEnumerable
{
  int Count { get; }
  bool IsSynchronized { get; }
  Object SyncRoot { get; }

  void CopyTo(Array array, int index);
}
#+end_src

~ICollection~ inherits from ~IEnumerable~. You therefore have all members from the ~IEnumerable~
interface implemented in all classes that implement the ~ICollection~ interface.


*** ~ICollection<T>~
When we look at the generic version of ICollection, you’ll recognize that it does not look
exactly the same as the non-generic equivalent:

#+begin_src csharp
public interface ICollection<T> : IEnumerable<T>, IEnumerable
{
  int Count { get; }
  bool IsReadOnly { get; }
  void Add(T item);
  void Clear();
  bool Contains(T item);
  void CopyTo(T[] array, int arrayIndex);
  bool Remove(T item);
}
#+end_src

*** ~IList~
The ~IList~ interface has of course a non-generic and a generic version. We start with looking
at the non-generic ~IList~ interface:

#+begin_src csharp
public interface IList : ICollection, IEnumerable
{
  bool IsFixedSize { get; }
  bool IsReadOnly { get; }
  Object this[int index] { get; set; }

  int Add(Object value);
  void Clear();
  bool Contains(Object value);
  int IndexOf(Object value);
  void Insert(int index, Object value);
  void Remove(Object value);
  void RemoveAt(int index);
}
#+end_src

*** Which to Use?
If you use a narrower interface type such as ~IEnumerable~ instead of IList, you protect your
code against breaking changes. If you use IEnumerable, the caller of your method can provide
any object which implements the IEnumerable interface. These are nearly all collection types
of the base class library and in addition many custom defined types. The caller code can be
changed in the future and your code won’t break that easily as it would if you had used
ICollection or even worse IList.


If you use a wider interface type such as IList, you are more in danger of breaking code
changes. If someone wants to call your method with a custom defined object which only
implements IEnumerable, it simply won’t work and will result in a compilation error.

The following table gives you an overview of how you can decide which type you should depend
on.


* ASP.NET Notes
** Redirect Manage to Login
#+begin_src csharp
    app.UseEndpoints(endpoints =>
        {
            endpoints.MapGet("/Identity/Account/Register", context => Task.Factory.StartNew(() => context.Response.Redirect("/Identity/Account/Login", true, true)));
            endpoints.MapPost("/Identity/Account/Register", context => Task.Factory.StartNew(() => context.Response.Redirect("/Identity/Account/Login", true, true)));
        });
#+end_src

** Middleware Definition

ASP.NET Core introduced a new concept called Middleware. A middleware is nothing but a
component (class) which is executed on every request in ASP.NET Core application. In the
classic ASP.NET, ~HttpHandlers~ and ~HttpModules~ were part of request pipeline. Middleware is
similar to ~HttpHandlers~ and ~HttpModules~ where both needs to be configured and executed in
each request.

Typically, there will be multiple middleware in ASP.NET Core web application. It can be
either framework provided middleware, added via NuGet or your own custom middleware. We can
set the order of middleware execution in the request pipeline. Each middleware adds or
modifies http request and optionally passes control to the next middleware component. The
following figure illustrates the execution of middleware components.

** Adding User Without Register
You could do this easily by creating a ~CreateRoles~ method in your startup class. This helps
check if the roles are created, and creates the roles if they aren't; on application
startup. Like so.
#+begin_src csharp
private async Task CreateRoles(IServiceProvider serviceProvider)
    {
        //initializing custom roles
        var RoleManager = serviceProvider.GetRequiredService<RoleManager<IdentityRole>>();
        var UserManager = serviceProvider.GetRequiredService<UserManager<ApplicationUser>>();
        string[] roleNames = { "Admin", "Store-Manager", "Member" };
        IdentityResult roleResult;

        foreach (var roleName in roleNames)
        {
            var roleExist = await RoleManager.RoleExistsAsync(roleName);
            // ensure that the role does not exist
            if (!roleExist)
            {
                //create the roles and seed them to the database:
                roleResult = await RoleManager.CreateAsync(new IdentityRole(roleName));
            }
        }
        // find the user with the admin email
        var _user = await UserManager.FindByEmailAsync("admin@email.com");

       // check if the user exists
       if(_user == null)
       {
            //Here you could create the super admin who will maintain the web app
            var poweruser = new ApplicationUser
            {
                UserName = "Admin",
                Email = "admin@email.com",
            };
            string adminPassword = "p@$$w0rd";

            var createPowerUser = await UserManager.CreateAsync(poweruser, adminPassword);
            if (createPowerUser.Succeeded)
            {
                //here we tie the new user to the role
                await UserManager.AddToRoleAsync(poweruser, "Admin");

            }
       }
    }
#+end_src
** Handling Errors
There are several ways in which you can improve on this generic error page. A simple
solution is to check for the HTTP status code 404 in the response. If found, you can
redirect the control to a page that exists. The following code snippet illustrates how you
can write the necessary code in the Configure method of the Startup class to redirect to the
home page if a 404 error has occurred.
*** Check ~Response.StatueCode~

#+begin_src csharp
 app.Use(async (context, next) =>
    {
        await next();
        if (context.Response.StatusCode == 404)
        {
            context.Request.Path = "/Home";
            await next();
        }
    });
#+end_src
*** Using ~UseStatuesCodePages~ Middleware in ASP.NET MVC
#+begin_src csharp
app.UseStatusCodePages();
#+end_src

*** ~UseStatusCodePagesWithReExecute~
~HomeController~ has this action method:

#+begin_src csharp
public IActionResult Error(int statusCode)
{
    if (statusCode == 404)
    {
        var statusFeature = HttpContext.Features.Get<IStatusCodeReExecuteFeature>();
        if (statusFeature != null)
        {
            log.LogWarning("handled 404 for url: {OriginalPath}", statusFeature.OriginalPath);
        }
    }
    return View(statusCode);
}

#+end_src

#+begin_src csharp
[Route("/Home/HandleError/{code:int}")]
public IActionResult HandleError(int code)
{
   ViewData["ErrorMessage"] = $"Error occurred. The ErrorCode is: {code}";
   return View("~/Views/Shared/HandleError.cshtml");
}
#+end_src

And this view:
#+begin_src csharp
@model int
@{
    switch (Model)
    {
        case 400:
            ViewData["Icon"] = "fa fa-ban text-danger";
            ViewData["Title"] = "Bad Request";
            ViewData["Description"] = "Your browser sent a request that this server could not understand.";
            break;
        case 401:
            ViewData["Icon"] = "fa fa-ban text-danger";
            ViewData["Title"] = "Unauthorized";
            ViewData["Description"] = "Sorry, but the page requires authentication.";
        break;
        case 403:
            ViewData["Icon"] = "fa fa-exclamation-circle text-danger";
            ViewData["Title"] = "Forbidden";
            ViewData["Description"] = "Sorry, but you don't have permission to access this page.";
        break;
        case 404:
            ViewData["Icon"] = "fa fa-exclamation-circle text-danger";
            ViewData["Title"] = "Page Not Found";
            ViewData["Description"] = "Sorry, but the page you were looking for can't be found.";
            break;
        case 500:
        default:
            ViewData["Icon"] = "fa fa-exclamation-circle text-danger";
            ViewData["Title"] = "Unexpected Error";
            ViewData["Description"] = "Well, this is embarrassing. An error occurred while processing your request. Rest assured, this problem has been logged and hamsters have been released to fix the problem.";
            break;
    }
}

<div class="jumbotron text-center">
    <header>
        <h1><span aria-hidden="true" class="@ViewData["Icon"]"></span> @ViewData["Title"]</h1>
    </header>
    <p>@ViewData["Description"]</p>
    <a class="btn btn-primary btn-lg" href="@Url.RouteUrl("/")"><span aria-hidden="true" class="fa fa-home"></span> Site Home</a>
</div>

#+end_src

** PSQL Connection String
Standard:
#+begin_src txt
Server=127.0.0.1;Port=5432;Database=myDataBase;User Id=myUsername;Password=myPassword;
#+end_src
** Filters in ASP.NET Core
Filters in ASP.NET Core allow code to run before or after specific stages in the request
processing pipeline. The filter pipeline runs after ASP.NET Core selects the action to execute:

[[file:ASP.NET_Notes/2022-03-29_01-22-54_screenshot.png]]

There are some types of filters:

+ Authorization filter
  + Run first.
  + Determine whether the user is quthorized for the request.
  + Short-circuit the pipeline if the request is not authorized.
+ Resource filiter
  + Run after authorization.
  + ~OnResourceExcuting~ runs code before the rest of filiter pipline.
  + ~OnResourceExcuting~ runs code after the rest of the pipline has completed.
+ Action filiter
  + Run immediately before and after an action method is called.
  + Can change the arguments passed into an action.
  + Can change the result returned from the action.
  + Are not supported in Razor Pages.

The following diagram shows how filter types interact in the filter pipeline:

#+DOWNLOADED: screenshot @ 2022-03-29 01:35:09
[[file:ASP.NET_Notes/2022-03-29_01-35-09_screenshot.png]]

Synchronous filters run before and after their pipeline stage. For example,
~OnActionExecuting~ is called before the action method is called. ~OnActionExecuted~ is called
after the action method returns:

#+begin_src csharp
public class SampleActionFilter : IActionFilter
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
    }
}
#+end_src

Implement either the synchronous or the async version of a filter interface, *not both*. The
runtime checks first to see if the filter implements the async interface, and if so, it
calls that. If not, it calls the synchronous interface's method(s). If both asynchronous and
synchronous interfaces are implemented in one class, _only the async method is called_. When
using abstract classes like ~ActionFilterAttribute~, override only the synchronous methods or
the asynchronous methods for each filter type.

ASP.NET Core includes built-in attribute-based filters that can be subclassed and
customized. For example, the following result filter adds a header to the response:

#+begin_src csharp
public class ResponseHeaderAttribute : ActionFilterAttribute
{
    private readonly string _name;
    private readonly string _value;

    public ResponseHeaderAttribute(string name, string value) =>
        (_name, _value) = (name, value);

    public override void OnResultExecuting(ResultExecutingContext context)
    {
        context.HttpContext.Response.Headers.Add(_name, _value);

        base.OnResultExecuting(context);
    }
}
#+end_src


Attributes allow filters to accept arguments, as shown in the preceding example. Apply the
ResponseHeaderAttribute to a controller or action method and specify the name and value of
the HTTP header:
#+begin_src csharp
[ResponseHeader("Filter-Header", "Filter Value")]
public class ResponseHeaderController : ControllerBase
{
    public IActionResult Index() =>
        Content("Examine the response headers using the F12 developer tools.");

    // ...
#+end_src

A filter can be added to the pipeline at one of three scopes:

- Using an attribute on a controller or Razor Page.
- Using an attribute on a controller action. Filter attributes cannot be applied to Razor Pages handler methods.
- Globally for all controllers, actions, and Razor Pages as shown in the following code:
  #+begin_src csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews(options =>
{
    options.Filters.Add<GlobalSampleActionFilter>();
});
  #+end_src

** Block Filter
You could use a filter to block requests to the register page. This example filter redirects
the request to the root path, but you could redirect to a page informing the user about the
disabled registration. This way you are only adding an attribute without changing any
registration code.

#+begin_src csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using System;

namespace MySite.Filters
{
    public class BlockFilter : IAuthorizationFilter
    {

        public BlockFilter()
        {
        }
        public void OnAuthorization(AuthorizationFilterContext context)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));

            context.Result = new RedirectResult("/"); //Redirect to you desired page
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
    public class BlockAttribute : TypeFilterAttribute
    {
        public BlockAttribute() : base(typeof(BlockFilter))
        {
        }
    }
}
#+end_src
#+begin_src csharp
    services.AddControllersWithViews(options =>
    {
        options.Filters.Add(new BlockAttribute());
    });

    services.AddRazorPages();
#+end_src
#+begin_src csharp
    [AllowAnonymous]
    [Block]
    public class RegisterModel : PageModel
    {
      ....
#+end_src
** Disable Page By Routing
#+begin_src csharp
    app.UseEndpoints(endpoints =>
        {
            endpoints.MapGet("/Identity/Account/Register", context => Task.Factory.StartNew(() => context.Response.Redirect("/Identity/Account/Login", true, true)));
            endpoints.MapPost("/Identity/Account/Register", context => Task.Factory.StartNew(() => context.Response.Redirect("/Identity/Account/Login", true, true)));
        });
#+end_src

** EF Add Unique Key
#+begin_src csharp
class MyContext : DbContext
{
    public DbSet<Person> People { get; set; }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Person>()
            .HasIndex(p => new { p.FirstName, p.LastName })
            .IsUnique(true);
    }
}

public class Person
{
    public int PersonId { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

#+end_src

* Regex
Match everything except for specified strings
#+begin_src regex
^(?!.*(red|green|blue))
#+end_src
