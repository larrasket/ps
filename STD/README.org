#+TITLE: STD Notes
#+hugo_tags: "Computer Science" "C++"
* C/STD Notes
** Sorting
*** Sorting Custom Objects
You can sort array of custom objects using the ~std::sort~ like this:
#+begin_src cpp
struct MyStruct
{
    int key;
    std::string stringValue;

    MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}
};

struct less_than_key
{
    inline bool operator() (const MyStruct& struct1, const MyStruct& struct2)
    {
        return (struct1.key < struct2.key);
    }
};

std::vector < MyStruct > vec;

vec.push_back(MyStruct(4, "test"));
vec.push_back(MyStruct(3, "a"));
vec.push_back(MyStruct(2, "is"));
vec.push_back(MyStruct(1, "this"));

std::sort(vec.begin(), vec.end(), less_than_key());

#+end_src
Also, since C++14 you can write an embedded functions inside the sort function:
#+begin_src cpp
#include <vector>
#include <algorithm>

using namespace std;

vector< MyStruct > values;

sort( values.begin( ), values.end( ), [ ]( const auto& lhs, const auto& rhs )
{
   return lhs.key < rhs.key;
});
#+end_src
*** Sorting Descending
#+begin_src cpp
sort(begin, end, greater<int>());
#+end_src
*** When to return 1 in compare function
-1 = means point 1 should come before point 2
+1 = means point 2 should come before point 1
 0 = means they r equal
** Numbers
*** Check If Prime Number
#+begin_src C
bool isPrimeNumber(int n) {
   if (n <= 1) return false;
   if (n <= 3) return true;
   if (n%2 == 0 || n%3 == 0) return false;
   for (int i=5; i*i<=n; i=i+6)
      if (n%i == 0 || n%(i+2) == 0)
         return false;
   return true;
}
#+end_src
*** Greater Common Divisor
#+begin_src cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
	cout << __gcd(6, 20) << endl;
}

#+end_src

#+RESULTS:
: 2

** ~for_each~
https://en.cppreference.com/w/cpp/algorithm/for_each
#+begin_src cpp
#include <vector>
#include <algorithm>
#include <iostream>

struct Sum
{
    void operator()(int n) { sum += n; }
    int sum{0};
};

int main()
{
    std::vector<int> nums{3, 4, 2, 8, 15, 267};

    auto print = [](const int& n) { std::cout << " " << n; };

    std::cout << "before:";
    std::for_each(nums.cbegin(), nums.cend(), print);
    std::cout << '\n';

    std::for_each(nums.begin(), nums.end(), [](int &n){ n++; });

    // calls Sum::operator() for each number
    Sum s = std::for_each(nums.begin(), nums.end(), Sum());

    std::cout << "after: ";
    std::for_each(nums.cbegin(), nums.cend(), print);
    std::cout << '\n';
    std::cout << "sum: " << s.sum << '\n';
}
#+end_src

** Other
*** Get Intersections
#+begin_src cpp
#include <iostream>     // std::cout
#include <algorithm>    // std::set_intersection, std::sort
#include <vector>       // std::vector

int main () {
  int first[] = {5,10,15,20,25};
  int second[] = {50,40,30,20,10};
  std::vector<int> v(10);                      // 0  0  0  0  0  0  0  0  0  0
  std::vector<int>::iterator it;

  std::sort (first,first+5);     //  5 10 15 20 25
  std::sort (second,second+5);   // 10 20 30 40 50

  it=std::set_intersection (first, first+5, second, second+5, v.begin());
                                               // 10 20 0  0  0  0  0  0  0  0
  v.resize(it-v.begin());                      // 10 20

  std::cout << "The intersection has " << (v.size()) << " elements:\n";
  for (it=v.begin(); it!=v.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
#+end_src

#+RESULTS:
| The | intersection | has | 2 | elements: |
|  10 |           20 |     |   |           |

** Lambda
Basic syntax:
#+begin_src
[ capture clause ] (parameters) -> return-type
{
   definition of method
}
#+end_src
Basic example:
#+begin_src C++
int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int f = accumulate(arr, arr + 10, 1, [](int i, int j)
    {
        return i * j;
    });
    cout << "Factorial of 10 is : " << f << endl;
}
#+end_src

Capturing methods:
   -  [&] : capture all external variable by reference
   -  [=] : capture all external variable by value
   -  [a, &b] : capture a by value and b by reference

Explicitly specifying a return type using ~ -> T ~:
#+begin_src C++
void func4(std::vector<double>& v) {
    std::transform(v.begin(), v.end(), v.begin(),
        [](double d) -> double {
            if (d < 0.0001) {
                return 0;
            } else {
                return d;
            }
        });
}

#+end_src

** Strings
Get all substrings
#+begin_src c++
void subString(string str, int n) {
  for (int len = 1; len <= n; len++) {
    for (int i = 0; i <= n - len; i++) {
      int j = i + len - 1;
      cout << str.substr(i, n - j);
      cout << endl;
    }
  }
}
#+end_src
** String/Char to int in C(++)
#+begin_src cpp
#include <sstream>
#include <iostream>
using namespace std;

int main() {
    string s = "12345";
    stringstream geek(s);
    int x = 0;
    geek >> x;
    cout << "Value of x : " << x;
}
#+end_src
#+RESULTS:
: Value of x : 12345
*** Using ~stoi()~
#+begin_src cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string str1 = "45";
    string str2 = "3.14159";
    string str3 = "31337 geek";

    int myint1 = stoi(str1);
    int myint2 = stoi(str2);
    int myint3 = stoi(str3);

    cout << "stoi(\"" << str1 << "\") is "
         << myint1 << '\n';
    cout << "stoi(\"" << str2 << "\") is "
         << myint2 << '\n';
    cout << "stoi(\"" << str3 << "\") is "
         << myint3 << '\n';

    return 0;
}
#+end_src
*** Using ~atoi()~
#+begin_src c++
#include <cstdlib>
#include <iostream>
using namespace std;

int main()
{
    const char* str1 = "42";
    const char* str2 = "3.14159";
    const char* str3 = "31337 geek";

    int num1 = atoi(str1);
    int num2 = atoi(str2);
    int num3 = atoi(str3);

    cout << "atoi(\"" << str1 << "\") is " << num1 << '\n';
    cout << "atoi(\"" << str2 << "\") is " << num2 << '\n';
    cout << "atoi(\"" << str3 << "\") is " << num3 << '\n';

    return 0;

#+end_src
*** Which one to use?
I find std::atoi() a horrible function: It returns zero on error. If you consider zero as a
valid input, then you cannot tell whether there was an error during the conversion or the
input was zero. That's just bad.

If you don't care about correctness or you know for sure that you won't have zero as input
or you consider that an error anyway, then, perhaps the C functions might be faster
(probably due to the lack of exception handling). It depends on your compiler, your standard
library implementation, your hardware, your input, etc. The best way is to measure it.
However, I suspect that the difference, if any, is negligible.

*** Using char asci
#+begin_src c
char a = '4';
int ia = a - '0';
#+end_src

** Multiplay all elements of vector with n
#+begin_src c++
std::transform(myv1.begin(), myv1.end(), myv1.begin(),
               std::bind(std::multiplies<T>(), std::placeholders::_1, n));
#+end_src

** Extract Vector
#+begin_src csharp
vector<T>::const_iterator first = myVec.begin() + 100000;
vector<T>::const_iterator last = myVec.begin() + 101000;
vector<T> newVec(first, last);
#+end_src

* C# Notes
** Get a Random Set of String
#+begin_src csharp
public static string RandomString(int length)
{
    var random = new Random();
    const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    return new string(Enumerable.Repeat(chars, length)
        .Select(s => s[random.Next(s.Length)]).ToArray());
}
#+end_src
** ~StringWriter~ vs ~StringBuilder~
~StringWriter~ derives from ~TextWriter~, which allows various classes to write text without
caring where it's going. In the case of ~StringWriter~, the output is just into memory. You
would use this if you're calling an API which needs a ~TextWriter~ but you only want to build
up results in memory.

~StringBuilder~ is essentially a buffer which allows you to perform multiple operations
(typically appends) to a "logical string" without creating a new string object each time.
You would use this to construct a string in multiple operations.

* ASP.NET Notes
** Redirect Manage to Login
#+begin_src csharp
    app.UseEndpoints(endpoints =>
        {
            endpoints.MapGet("/Identity/Account/Register", context => Task.Factory.StartNew(() => context.Response.Redirect("/Identity/Account/Login", true, true)));
            endpoints.MapPost("/Identity/Account/Register", context => Task.Factory.StartNew(() => context.Response.Redirect("/Identity/Account/Login", true, true)));
        });
#+end_src

** Middleware Definition

ASP.NET Core introduced a new concept called Middleware. A middleware is nothing but a
component (class) which is executed on every request in ASP.NET Core application. In the
classic ASP.NET, ~HttpHandlers~ and ~HttpModules~ were part of request pipeline. Middleware is
similar to ~HttpHandlers~ and ~HttpModules~ where both needs to be configured and executed in
each request.

Typically, there will be multiple middleware in ASP.NET Core web application. It can be
either framework provided middleware, added via NuGet or your own custom middleware. We can
set the order of middleware execution in the request pipeline. Each middleware adds or
modifies http request and optionally passes control to the next middleware component. The
following figure illustrates the execution of middleware components.

** Adding User Without Register
You could do this easily by creating a CreateRoles method in your startup class. This helps
check if the roles are created, and creates the roles if they aren't; on application
startup. Like so.
#+begin_src csharp
private async Task CreateRoles(IServiceProvider serviceProvider)
    {
        //initializing custom roles
        var RoleManager = serviceProvider.GetRequiredService<RoleManager<IdentityRole>>();
        var UserManager = serviceProvider.GetRequiredService<UserManager<ApplicationUser>>();
        string[] roleNames = { "Admin", "Store-Manager", "Member" };
        IdentityResult roleResult;

        foreach (var roleName in roleNames)
        {
            var roleExist = await RoleManager.RoleExistsAsync(roleName);
            // ensure that the role does not exist
            if (!roleExist)
            {
                //create the roles and seed them to the database:
                roleResult = await RoleManager.CreateAsync(new IdentityRole(roleName));
            }
        }

        // find the user with the admin email
        var _user = await UserManager.FindByEmailAsync("admin@email.com");

       // check if the user exists
       if(_user == null)
       {
            //Here you could create the super admin who will maintain the web app
            var poweruser = new ApplicationUser
            {
                UserName = "Admin",
                Email = "admin@email.com",
            };
            string adminPassword = "p@$$w0rd";

            var createPowerUser = await UserManager.CreateAsync(poweruser, adminPassword);
            if (createPowerUser.Succeeded)
            {
                //here we tie the new user to the role
                await UserManager.AddToRoleAsync(poweruser, "Admin");

            }
       }
    }
#+end_src
** Handling Errors
There are several ways in which you can improve on this generic error page. A simple
solution is to check for the HTTP status code 404 in the response. If found, you can
redirect the control to a page that exists. The following code snippet illustrates how you
can write the necessary code in the Configure method of the Startup class to redirect to the
home page if a 404 error has occurred.
*** Check ~Response.StatueCode~

#+begin_src csharp
 app.Use(async (context, next) =>
    {
        await next();
        if (context.Response.StatusCode == 404)
        {
            context.Request.Path = "/Home";
            await next();
        }
    });
#+end_src
*** Using ~UseStatuesCodePages~ Middleware in ASP.NET MVC
#+begin_src csharp
app.UseStatusCodePages();
#+end_src

*** ~UseStatusCodePagesWithReExecute~
~HomeController~ has this action method:

#+begin_src csharp
public IActionResult Error(int statusCode)
{
    if (statusCode == 404)
    {
        var statusFeature = HttpContext.Features.Get<IStatusCodeReExecuteFeature>();
        if (statusFeature != null)
        {
            log.LogWarning("handled 404 for url: {OriginalPath}", statusFeature.OriginalPath);
        }
    }
    return View(statusCode);
}

#+end_src

#+begin_src csharp
[Route("/Home/HandleError/{code:int}")]
public IActionResult HandleError(int code)
{
   ViewData["ErrorMessage"] = $"Error occurred. The ErrorCode is: {code}";
   return View("~/Views/Shared/HandleError.cshtml");
}
#+end_src

And this view:
#+begin_src csharp
@model int
@{
    switch (Model)
    {
        case 400:
            ViewData["Icon"] = "fa fa-ban text-danger";
            ViewData["Title"] = "Bad Request";
            ViewData["Description"] = "Your browser sent a request that this server could not understand.";
            break;
        case 401:
            ViewData["Icon"] = "fa fa-ban text-danger";
            ViewData["Title"] = "Unauthorized";
            ViewData["Description"] = "Sorry, but the page requires authentication.";
        break;
        case 403:
            ViewData["Icon"] = "fa fa-exclamation-circle text-danger";
            ViewData["Title"] = "Forbidden";
            ViewData["Description"] = "Sorry, but you don't have permission to access this page.";
        break;
        case 404:
            ViewData["Icon"] = "fa fa-exclamation-circle text-danger";
            ViewData["Title"] = "Page Not Found";
            ViewData["Description"] = "Sorry, but the page you were looking for can't be found.";
            break;
        case 500:
        default:
            ViewData["Icon"] = "fa fa-exclamation-circle text-danger";
            ViewData["Title"] = "Unexpected Error";
            ViewData["Description"] = "Well, this is embarrassing. An error occurred while processing your request. Rest assured, this problem has been logged and hamsters have been released to fix the problem.";
            break;
    }
}

<div class="jumbotron text-center">
    <header>
        <h1><span aria-hidden="true" class="@ViewData["Icon"]"></span> @ViewData["Title"]</h1>
    </header>
    <p>@ViewData["Description"]</p>
    <a class="btn btn-primary btn-lg" href="@Url.RouteUrl("/")"><span aria-hidden="true" class="fa fa-home"></span> Site Home</a>
</div>

#+end_src

** PSQL Connection String
Standard:
#+begin_src txt
Server=127.0.0.1;Port=5432;Database=myDataBase;User Id=myUsername;Password=myPassword;
#+end_src
** Filters in ASP.NET Core
Filters in ASP.NET Core allow code to run before or after specific stages in the request
processing pipeline. The filter pipeline runs after ASP.NET Core selects the action to execute:

[[file:ASP.NET_Notes/2022-03-29_01-22-54_screenshot.png]]

There are some types of filters:

+ Authorization filter
  + Run first.
  + Determine whether the user is quthorized for the request.
  + Short-circuit the pipeline if the request is not authorized.
+ Resource filiter
  + Run after authorization.
  + ~OnResourceExcuting~ runs code before the rest of filiter pipline.
  + ~OnResourceExcuting~ runs code after the rest of the pipline has completed.
+ Action filiter
  + Run immediately before and after an action method is called.
  + Can change the arguments passed into an action.
  + Can change the result returned from the action.
  + Are not supported in Razor Pages.

The following diagram shows how filter types interact in the filter pipeline:

#+DOWNLOADED: screenshot @ 2022-03-29 01:35:09
[[file:ASP.NET_Notes/2022-03-29_01-35-09_screenshot.png]]

Synchronous filters run before and after their pipeline stage. For example,
~OnActionExecuting~ is called before the action method is called. ~OnActionExecuted~ is called
after the action method returns:

#+begin_src csharp
public class SampleActionFilter : IActionFilter
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // Do something before the action executes.
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        // Do something after the action executes.
    }
}
#+end_src

Implement either the synchronous or the async version of a filter interface, *not both*. The
runtime checks first to see if the filter implements the async interface, and if so, it
calls that. If not, it calls the synchronous interface's method(s). If both asynchronous and
synchronous interfaces are implemented in one class, _only the async method is called_. When
using abstract classes like ~ActionFilterAttribute~, override only the synchronous methods or
the asynchronous methods for each filter type.

ASP.NET Core includes built-in attribute-based filters that can be subclassed and
customized. For example, the following result filter adds a header to the response:

#+begin_src csharp
public class ResponseHeaderAttribute : ActionFilterAttribute
{
    private readonly string _name;
    private readonly string _value;

    public ResponseHeaderAttribute(string name, string value) =>
        (_name, _value) = (name, value);

    public override void OnResultExecuting(ResultExecutingContext context)
    {
        context.HttpContext.Response.Headers.Add(_name, _value);

        base.OnResultExecuting(context);
    }
}
#+end_src


Attributes allow filters to accept arguments, as shown in the preceding example. Apply the
ResponseHeaderAttribute to a controller or action method and specify the name and value of
the HTTP header:
#+begin_src csharp
[ResponseHeader("Filter-Header", "Filter Value")]
public class ResponseHeaderController : ControllerBase
{
    public IActionResult Index() =>
        Content("Examine the response headers using the F12 developer tools.");

    // ...
#+end_src

A filter can be added to the pipeline at one of three scopes:

- Using an attribute on a controller or Razor Page.
- Using an attribute on a controller action. Filter attributes cannot be applied to Razor Pages handler methods.
- Globally for all controllers, actions, and Razor Pages as shown in the following code:
  #+begin_src csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews(options =>
{
    options.Filters.Add<GlobalSampleActionFilter>();
});
  #+end_src

** Block Filter
You could use a filter to block requests to the register page. This example filter redirects
the request to the root path, but you could redirect to a page informing the user about the
disabled registration. This way you are only adding an attribute without changing any
registration code.

#+begin_src csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using System;

namespace MySite.Filters
{
    public class BlockFilter : IAuthorizationFilter
    {

        public BlockFilter()
        {
        }
        public void OnAuthorization(AuthorizationFilterContext context)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));

            context.Result = new RedirectResult("/"); //Redirect to you desired page

        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
    public class BlockAttribute : TypeFilterAttribute
    {
        public BlockAttribute() : base(typeof(BlockFilter))
        {
        }
    }
}
#+end_src
#+begin_src csharp
    services.AddControllersWithViews(options =>
    {
        options.Filters.Add(new BlockAttribute());
    });

    services.AddRazorPages();
#+end_src
#+begin_src csharp
    [AllowAnonymous]
    [Block]
    public class RegisterModel : PageModel
    {
      ....
#+end_src
* Regex
Match everything except for specified strings
#+begin_src regex
^(?!.*(red|green|blue))
#+end_src
